// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: eth/v1alpha1/beacon_chain.proto

package eth

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type SetAction int32

const (
	SetAction_ADD_VALIDATOR_KEYS    SetAction = 0
	SetAction_REMOVE_VALIDATOR_KEYS SetAction = 1
	SetAction_SET_VALIDATOR_KEYS    SetAction = 2
)

var SetAction_name = map[int32]string{
	0: "ADD_VALIDATOR_KEYS",
	1: "REMOVE_VALIDATOR_KEYS",
	2: "SET_VALIDATOR_KEYS",
}

var SetAction_value = map[string]int32{
	"ADD_VALIDATOR_KEYS":    0,
	"REMOVE_VALIDATOR_KEYS": 1,
	"SET_VALIDATOR_KEYS":    2,
}

func (x SetAction) String() string {
	return proto.EnumName(SetAction_name, int32(x))
}

func (SetAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{0}
}

type ValidatorChangeSet struct {
	Action               SetAction `protobuf:"varint,1,opt,name=action,proto3,enum=ethereum.eth.v1alpha1.SetAction" json:"action,omitempty"`
	PublicKeys           [][]byte  `protobuf:"bytes,2,rep,name=public_keys,json=publicKeys,proto3" json:"public_keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ValidatorChangeSet) Reset()         { *m = ValidatorChangeSet{} }
func (m *ValidatorChangeSet) String() string { return proto.CompactTextString(m) }
func (*ValidatorChangeSet) ProtoMessage()    {}
func (*ValidatorChangeSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{0}
}
func (m *ValidatorChangeSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorChangeSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorChangeSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorChangeSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorChangeSet.Merge(m, src)
}
func (m *ValidatorChangeSet) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorChangeSet) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorChangeSet.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorChangeSet proto.InternalMessageInfo

func (m *ValidatorChangeSet) GetAction() SetAction {
	if m != nil {
		return m.Action
	}
	return SetAction_ADD_VALIDATOR_KEYS
}

func (m *ValidatorChangeSet) GetPublicKeys() [][]byte {
	if m != nil {
		return m.PublicKeys
	}
	return nil
}

type ListIndexedAttestationsRequest struct {
	// Types that are valid to be assigned to QueryFilter:
	//	*ListIndexedAttestationsRequest_Epoch
	//	*ListIndexedAttestationsRequest_GenesisEpoch
	QueryFilter          isListIndexedAttestationsRequest_QueryFilter `protobuf_oneof:"query_filter"`
	PageSize             int32                                        `protobuf:"varint,3,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	PageToken            string                                       `protobuf:"bytes,4,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                     `json:"-"`
	XXX_unrecognized     []byte                                       `json:"-"`
	XXX_sizecache        int32                                        `json:"-"`
}

func (m *ListIndexedAttestationsRequest) Reset()         { *m = ListIndexedAttestationsRequest{} }
func (m *ListIndexedAttestationsRequest) String() string { return proto.CompactTextString(m) }
func (*ListIndexedAttestationsRequest) ProtoMessage()    {}
func (*ListIndexedAttestationsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{1}
}
func (m *ListIndexedAttestationsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListIndexedAttestationsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListIndexedAttestationsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListIndexedAttestationsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListIndexedAttestationsRequest.Merge(m, src)
}
func (m *ListIndexedAttestationsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListIndexedAttestationsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListIndexedAttestationsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListIndexedAttestationsRequest proto.InternalMessageInfo

type isListIndexedAttestationsRequest_QueryFilter interface {
	isListIndexedAttestationsRequest_QueryFilter()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ListIndexedAttestationsRequest_Epoch struct {
	Epoch uint64 `protobuf:"varint,1,opt,name=epoch,proto3,oneof"`
}
type ListIndexedAttestationsRequest_GenesisEpoch struct {
	GenesisEpoch bool `protobuf:"varint,2,opt,name=genesis_epoch,json=genesisEpoch,proto3,oneof"`
}

func (*ListIndexedAttestationsRequest_Epoch) isListIndexedAttestationsRequest_QueryFilter()        {}
func (*ListIndexedAttestationsRequest_GenesisEpoch) isListIndexedAttestationsRequest_QueryFilter() {}

func (m *ListIndexedAttestationsRequest) GetQueryFilter() isListIndexedAttestationsRequest_QueryFilter {
	if m != nil {
		return m.QueryFilter
	}
	return nil
}

func (m *ListIndexedAttestationsRequest) GetEpoch() uint64 {
	if x, ok := m.GetQueryFilter().(*ListIndexedAttestationsRequest_Epoch); ok {
		return x.Epoch
	}
	return 0
}

func (m *ListIndexedAttestationsRequest) GetGenesisEpoch() bool {
	if x, ok := m.GetQueryFilter().(*ListIndexedAttestationsRequest_GenesisEpoch); ok {
		return x.GenesisEpoch
	}
	return false
}

func (m *ListIndexedAttestationsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListIndexedAttestationsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ListIndexedAttestationsRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ListIndexedAttestationsRequest_OneofMarshaler, _ListIndexedAttestationsRequest_OneofUnmarshaler, _ListIndexedAttestationsRequest_OneofSizer, []interface{}{
		(*ListIndexedAttestationsRequest_Epoch)(nil),
		(*ListIndexedAttestationsRequest_GenesisEpoch)(nil),
	}
}

func _ListIndexedAttestationsRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ListIndexedAttestationsRequest)
	// query_filter
	switch x := m.QueryFilter.(type) {
	case *ListIndexedAttestationsRequest_Epoch:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Epoch))
	case *ListIndexedAttestationsRequest_GenesisEpoch:
		t := uint64(0)
		if x.GenesisEpoch {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("ListIndexedAttestationsRequest.QueryFilter has unexpected type %T", x)
	}
	return nil
}

func _ListIndexedAttestationsRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ListIndexedAttestationsRequest)
	switch tag {
	case 1: // query_filter.epoch
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.QueryFilter = &ListIndexedAttestationsRequest_Epoch{x}
		return true, err
	case 2: // query_filter.genesis_epoch
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.QueryFilter = &ListIndexedAttestationsRequest_GenesisEpoch{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _ListIndexedAttestationsRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ListIndexedAttestationsRequest)
	// query_filter
	switch x := m.QueryFilter.(type) {
	case *ListIndexedAttestationsRequest_Epoch:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Epoch))
	case *ListIndexedAttestationsRequest_GenesisEpoch:
		n += 1 // tag and wire
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ListAttestationsRequest struct {
	// Types that are valid to be assigned to QueryFilter:
	//	*ListAttestationsRequest_Epoch
	//	*ListAttestationsRequest_GenesisEpoch
	QueryFilter          isListAttestationsRequest_QueryFilter `protobuf_oneof:"query_filter"`
	PageSize             int32                                 `protobuf:"varint,3,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	PageToken            string                                `protobuf:"bytes,4,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                              `json:"-"`
	XXX_unrecognized     []byte                                `json:"-"`
	XXX_sizecache        int32                                 `json:"-"`
}

func (m *ListAttestationsRequest) Reset()         { *m = ListAttestationsRequest{} }
func (m *ListAttestationsRequest) String() string { return proto.CompactTextString(m) }
func (*ListAttestationsRequest) ProtoMessage()    {}
func (*ListAttestationsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{2}
}
func (m *ListAttestationsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAttestationsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAttestationsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListAttestationsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAttestationsRequest.Merge(m, src)
}
func (m *ListAttestationsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListAttestationsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAttestationsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListAttestationsRequest proto.InternalMessageInfo

type isListAttestationsRequest_QueryFilter interface {
	isListAttestationsRequest_QueryFilter()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ListAttestationsRequest_Epoch struct {
	Epoch uint64 `protobuf:"varint,1,opt,name=epoch,proto3,oneof"`
}
type ListAttestationsRequest_GenesisEpoch struct {
	GenesisEpoch bool `protobuf:"varint,2,opt,name=genesis_epoch,json=genesisEpoch,proto3,oneof"`
}

func (*ListAttestationsRequest_Epoch) isListAttestationsRequest_QueryFilter()        {}
func (*ListAttestationsRequest_GenesisEpoch) isListAttestationsRequest_QueryFilter() {}

func (m *ListAttestationsRequest) GetQueryFilter() isListAttestationsRequest_QueryFilter {
	if m != nil {
		return m.QueryFilter
	}
	return nil
}

func (m *ListAttestationsRequest) GetEpoch() uint64 {
	if x, ok := m.GetQueryFilter().(*ListAttestationsRequest_Epoch); ok {
		return x.Epoch
	}
	return 0
}

func (m *ListAttestationsRequest) GetGenesisEpoch() bool {
	if x, ok := m.GetQueryFilter().(*ListAttestationsRequest_GenesisEpoch); ok {
		return x.GenesisEpoch
	}
	return false
}

func (m *ListAttestationsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListAttestationsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ListAttestationsRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ListAttestationsRequest_OneofMarshaler, _ListAttestationsRequest_OneofUnmarshaler, _ListAttestationsRequest_OneofSizer, []interface{}{
		(*ListAttestationsRequest_Epoch)(nil),
		(*ListAttestationsRequest_GenesisEpoch)(nil),
	}
}

func _ListAttestationsRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ListAttestationsRequest)
	// query_filter
	switch x := m.QueryFilter.(type) {
	case *ListAttestationsRequest_Epoch:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Epoch))
	case *ListAttestationsRequest_GenesisEpoch:
		t := uint64(0)
		if x.GenesisEpoch {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("ListAttestationsRequest.QueryFilter has unexpected type %T", x)
	}
	return nil
}

func _ListAttestationsRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ListAttestationsRequest)
	switch tag {
	case 1: // query_filter.epoch
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.QueryFilter = &ListAttestationsRequest_Epoch{x}
		return true, err
	case 2: // query_filter.genesis_epoch
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.QueryFilter = &ListAttestationsRequest_GenesisEpoch{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _ListAttestationsRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ListAttestationsRequest)
	// query_filter
	switch x := m.QueryFilter.(type) {
	case *ListAttestationsRequest_Epoch:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Epoch))
	case *ListAttestationsRequest_GenesisEpoch:
		n += 1 // tag and wire
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ListAttestationsResponse struct {
	Attestations         []*Attestation `protobuf:"bytes,1,rep,name=attestations,proto3" json:"attestations,omitempty"`
	NextPageToken        string         `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	TotalSize            int32          `protobuf:"varint,3,opt,name=total_size,json=totalSize,proto3" json:"total_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ListAttestationsResponse) Reset()         { *m = ListAttestationsResponse{} }
func (m *ListAttestationsResponse) String() string { return proto.CompactTextString(m) }
func (*ListAttestationsResponse) ProtoMessage()    {}
func (*ListAttestationsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{3}
}
func (m *ListAttestationsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListAttestationsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListAttestationsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListAttestationsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListAttestationsResponse.Merge(m, src)
}
func (m *ListAttestationsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListAttestationsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListAttestationsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListAttestationsResponse proto.InternalMessageInfo

func (m *ListAttestationsResponse) GetAttestations() []*Attestation {
	if m != nil {
		return m.Attestations
	}
	return nil
}

func (m *ListAttestationsResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *ListAttestationsResponse) GetTotalSize() int32 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

type ListIndexedAttestationsResponse struct {
	IndexedAttestations  []*IndexedAttestation `protobuf:"bytes,1,rep,name=indexed_attestations,json=indexedAttestations,proto3" json:"indexed_attestations,omitempty"`
	NextPageToken        string                `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	TotalSize            int32                 `protobuf:"varint,3,opt,name=total_size,json=totalSize,proto3" json:"total_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ListIndexedAttestationsResponse) Reset()         { *m = ListIndexedAttestationsResponse{} }
func (m *ListIndexedAttestationsResponse) String() string { return proto.CompactTextString(m) }
func (*ListIndexedAttestationsResponse) ProtoMessage()    {}
func (*ListIndexedAttestationsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{4}
}
func (m *ListIndexedAttestationsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListIndexedAttestationsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListIndexedAttestationsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListIndexedAttestationsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListIndexedAttestationsResponse.Merge(m, src)
}
func (m *ListIndexedAttestationsResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListIndexedAttestationsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListIndexedAttestationsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListIndexedAttestationsResponse proto.InternalMessageInfo

func (m *ListIndexedAttestationsResponse) GetIndexedAttestations() []*IndexedAttestation {
	if m != nil {
		return m.IndexedAttestations
	}
	return nil
}

func (m *ListIndexedAttestationsResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *ListIndexedAttestationsResponse) GetTotalSize() int32 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

type ListBlocksRequest struct {
	// Types that are valid to be assigned to QueryFilter:
	//	*ListBlocksRequest_Root
	//	*ListBlocksRequest_Slot
	//	*ListBlocksRequest_Epoch
	//	*ListBlocksRequest_Genesis
	QueryFilter          isListBlocksRequest_QueryFilter `protobuf_oneof:"query_filter"`
	PageSize             int32                           `protobuf:"varint,5,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	PageToken            string                          `protobuf:"bytes,6,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                        `json:"-"`
	XXX_unrecognized     []byte                          `json:"-"`
	XXX_sizecache        int32                           `json:"-"`
}

func (m *ListBlocksRequest) Reset()         { *m = ListBlocksRequest{} }
func (m *ListBlocksRequest) String() string { return proto.CompactTextString(m) }
func (*ListBlocksRequest) ProtoMessage()    {}
func (*ListBlocksRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{5}
}
func (m *ListBlocksRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListBlocksRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListBlocksRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListBlocksRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListBlocksRequest.Merge(m, src)
}
func (m *ListBlocksRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListBlocksRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListBlocksRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListBlocksRequest proto.InternalMessageInfo

type isListBlocksRequest_QueryFilter interface {
	isListBlocksRequest_QueryFilter()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ListBlocksRequest_Root struct {
	Root []byte `protobuf:"bytes,1,opt,name=root,proto3,oneof"`
}
type ListBlocksRequest_Slot struct {
	Slot uint64 `protobuf:"varint,2,opt,name=slot,proto3,oneof"`
}
type ListBlocksRequest_Epoch struct {
	Epoch uint64 `protobuf:"varint,3,opt,name=epoch,proto3,oneof"`
}
type ListBlocksRequest_Genesis struct {
	Genesis bool `protobuf:"varint,4,opt,name=genesis,proto3,oneof"`
}

func (*ListBlocksRequest_Root) isListBlocksRequest_QueryFilter()    {}
func (*ListBlocksRequest_Slot) isListBlocksRequest_QueryFilter()    {}
func (*ListBlocksRequest_Epoch) isListBlocksRequest_QueryFilter()   {}
func (*ListBlocksRequest_Genesis) isListBlocksRequest_QueryFilter() {}

func (m *ListBlocksRequest) GetQueryFilter() isListBlocksRequest_QueryFilter {
	if m != nil {
		return m.QueryFilter
	}
	return nil
}

func (m *ListBlocksRequest) GetRoot() []byte {
	if x, ok := m.GetQueryFilter().(*ListBlocksRequest_Root); ok {
		return x.Root
	}
	return nil
}

func (m *ListBlocksRequest) GetSlot() uint64 {
	if x, ok := m.GetQueryFilter().(*ListBlocksRequest_Slot); ok {
		return x.Slot
	}
	return 0
}

func (m *ListBlocksRequest) GetEpoch() uint64 {
	if x, ok := m.GetQueryFilter().(*ListBlocksRequest_Epoch); ok {
		return x.Epoch
	}
	return 0
}

func (m *ListBlocksRequest) GetGenesis() bool {
	if x, ok := m.GetQueryFilter().(*ListBlocksRequest_Genesis); ok {
		return x.Genesis
	}
	return false
}

func (m *ListBlocksRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListBlocksRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ListBlocksRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ListBlocksRequest_OneofMarshaler, _ListBlocksRequest_OneofUnmarshaler, _ListBlocksRequest_OneofSizer, []interface{}{
		(*ListBlocksRequest_Root)(nil),
		(*ListBlocksRequest_Slot)(nil),
		(*ListBlocksRequest_Epoch)(nil),
		(*ListBlocksRequest_Genesis)(nil),
	}
}

func _ListBlocksRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ListBlocksRequest)
	// query_filter
	switch x := m.QueryFilter.(type) {
	case *ListBlocksRequest_Root:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.Root)
	case *ListBlocksRequest_Slot:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Slot))
	case *ListBlocksRequest_Epoch:
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Epoch))
	case *ListBlocksRequest_Genesis:
		t := uint64(0)
		if x.Genesis {
			t = 1
		}
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("ListBlocksRequest.QueryFilter has unexpected type %T", x)
	}
	return nil
}

func _ListBlocksRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ListBlocksRequest)
	switch tag {
	case 1: // query_filter.root
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.QueryFilter = &ListBlocksRequest_Root{x}
		return true, err
	case 2: // query_filter.slot
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.QueryFilter = &ListBlocksRequest_Slot{x}
		return true, err
	case 3: // query_filter.epoch
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.QueryFilter = &ListBlocksRequest_Epoch{x}
		return true, err
	case 4: // query_filter.genesis
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.QueryFilter = &ListBlocksRequest_Genesis{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _ListBlocksRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ListBlocksRequest)
	// query_filter
	switch x := m.QueryFilter.(type) {
	case *ListBlocksRequest_Root:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Root)))
		n += len(x.Root)
	case *ListBlocksRequest_Slot:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Slot))
	case *ListBlocksRequest_Epoch:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Epoch))
	case *ListBlocksRequest_Genesis:
		n += 1 // tag and wire
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ListBlocksResponse struct {
	BlockContainers      []*BeaconBlockContainer `protobuf:"bytes,1,rep,name=blockContainers,proto3" json:"blockContainers,omitempty"`
	NextPageToken        string                  `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	TotalSize            int32                   `protobuf:"varint,3,opt,name=total_size,json=totalSize,proto3" json:"total_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *ListBlocksResponse) Reset()         { *m = ListBlocksResponse{} }
func (m *ListBlocksResponse) String() string { return proto.CompactTextString(m) }
func (*ListBlocksResponse) ProtoMessage()    {}
func (*ListBlocksResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{6}
}
func (m *ListBlocksResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListBlocksResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListBlocksResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListBlocksResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListBlocksResponse.Merge(m, src)
}
func (m *ListBlocksResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListBlocksResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListBlocksResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListBlocksResponse proto.InternalMessageInfo

func (m *ListBlocksResponse) GetBlockContainers() []*BeaconBlockContainer {
	if m != nil {
		return m.BlockContainers
	}
	return nil
}

func (m *ListBlocksResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *ListBlocksResponse) GetTotalSize() int32 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

type BeaconBlockContainer struct {
	Block                *SignedBeaconBlock `protobuf:"bytes,1,opt,name=block,proto3" json:"block,omitempty"`
	BlockRoot            []byte             `protobuf:"bytes,2,opt,name=block_root,json=blockRoot,proto3" json:"block_root,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *BeaconBlockContainer) Reset()         { *m = BeaconBlockContainer{} }
func (m *BeaconBlockContainer) String() string { return proto.CompactTextString(m) }
func (*BeaconBlockContainer) ProtoMessage()    {}
func (*BeaconBlockContainer) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{7}
}
func (m *BeaconBlockContainer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BeaconBlockContainer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BeaconBlockContainer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BeaconBlockContainer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BeaconBlockContainer.Merge(m, src)
}
func (m *BeaconBlockContainer) XXX_Size() int {
	return m.Size()
}
func (m *BeaconBlockContainer) XXX_DiscardUnknown() {
	xxx_messageInfo_BeaconBlockContainer.DiscardUnknown(m)
}

var xxx_messageInfo_BeaconBlockContainer proto.InternalMessageInfo

func (m *BeaconBlockContainer) GetBlock() *SignedBeaconBlock {
	if m != nil {
		return m.Block
	}
	return nil
}

func (m *BeaconBlockContainer) GetBlockRoot() []byte {
	if m != nil {
		return m.BlockRoot
	}
	return nil
}

type ChainHead struct {
	HeadSlot                   uint64   `protobuf:"varint,1,opt,name=head_slot,json=headSlot,proto3" json:"head_slot,omitempty"`
	HeadEpoch                  uint64   `protobuf:"varint,2,opt,name=head_epoch,json=headEpoch,proto3" json:"head_epoch,omitempty"`
	HeadBlockRoot              []byte   `protobuf:"bytes,3,opt,name=head_block_root,json=headBlockRoot,proto3" json:"head_block_root,omitempty" ssz-size:"32"`
	FinalizedSlot              uint64   `protobuf:"varint,4,opt,name=finalized_slot,json=finalizedSlot,proto3" json:"finalized_slot,omitempty"`
	FinalizedEpoch             uint64   `protobuf:"varint,5,opt,name=finalized_epoch,json=finalizedEpoch,proto3" json:"finalized_epoch,omitempty"`
	FinalizedBlockRoot         []byte   `protobuf:"bytes,6,opt,name=finalized_block_root,json=finalizedBlockRoot,proto3" json:"finalized_block_root,omitempty" ssz-size:"32"`
	JustifiedSlot              uint64   `protobuf:"varint,7,opt,name=justified_slot,json=justifiedSlot,proto3" json:"justified_slot,omitempty"`
	JustifiedEpoch             uint64   `protobuf:"varint,8,opt,name=justified_epoch,json=justifiedEpoch,proto3" json:"justified_epoch,omitempty"`
	JustifiedBlockRoot         []byte   `protobuf:"bytes,9,opt,name=justified_block_root,json=justifiedBlockRoot,proto3" json:"justified_block_root,omitempty" ssz-size:"32"`
	PreviousJustifiedSlot      uint64   `protobuf:"varint,10,opt,name=previous_justified_slot,json=previousJustifiedSlot,proto3" json:"previous_justified_slot,omitempty"`
	PreviousJustifiedEpoch     uint64   `protobuf:"varint,11,opt,name=previous_justified_epoch,json=previousJustifiedEpoch,proto3" json:"previous_justified_epoch,omitempty"`
	PreviousJustifiedBlockRoot []byte   `protobuf:"bytes,12,opt,name=previous_justified_block_root,json=previousJustifiedBlockRoot,proto3" json:"previous_justified_block_root,omitempty" ssz-size:"32"`
	XXX_NoUnkeyedLiteral       struct{} `json:"-"`
	XXX_unrecognized           []byte   `json:"-"`
	XXX_sizecache              int32    `json:"-"`
}

func (m *ChainHead) Reset()         { *m = ChainHead{} }
func (m *ChainHead) String() string { return proto.CompactTextString(m) }
func (*ChainHead) ProtoMessage()    {}
func (*ChainHead) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{8}
}
func (m *ChainHead) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainHead) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainHead.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChainHead) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainHead.Merge(m, src)
}
func (m *ChainHead) XXX_Size() int {
	return m.Size()
}
func (m *ChainHead) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainHead.DiscardUnknown(m)
}

var xxx_messageInfo_ChainHead proto.InternalMessageInfo

func (m *ChainHead) GetHeadSlot() uint64 {
	if m != nil {
		return m.HeadSlot
	}
	return 0
}

func (m *ChainHead) GetHeadEpoch() uint64 {
	if m != nil {
		return m.HeadEpoch
	}
	return 0
}

func (m *ChainHead) GetHeadBlockRoot() []byte {
	if m != nil {
		return m.HeadBlockRoot
	}
	return nil
}

func (m *ChainHead) GetFinalizedSlot() uint64 {
	if m != nil {
		return m.FinalizedSlot
	}
	return 0
}

func (m *ChainHead) GetFinalizedEpoch() uint64 {
	if m != nil {
		return m.FinalizedEpoch
	}
	return 0
}

func (m *ChainHead) GetFinalizedBlockRoot() []byte {
	if m != nil {
		return m.FinalizedBlockRoot
	}
	return nil
}

func (m *ChainHead) GetJustifiedSlot() uint64 {
	if m != nil {
		return m.JustifiedSlot
	}
	return 0
}

func (m *ChainHead) GetJustifiedEpoch() uint64 {
	if m != nil {
		return m.JustifiedEpoch
	}
	return 0
}

func (m *ChainHead) GetJustifiedBlockRoot() []byte {
	if m != nil {
		return m.JustifiedBlockRoot
	}
	return nil
}

func (m *ChainHead) GetPreviousJustifiedSlot() uint64 {
	if m != nil {
		return m.PreviousJustifiedSlot
	}
	return 0
}

func (m *ChainHead) GetPreviousJustifiedEpoch() uint64 {
	if m != nil {
		return m.PreviousJustifiedEpoch
	}
	return 0
}

func (m *ChainHead) GetPreviousJustifiedBlockRoot() []byte {
	if m != nil {
		return m.PreviousJustifiedBlockRoot
	}
	return nil
}

type ListCommitteesRequest struct {
	// Types that are valid to be assigned to QueryFilter:
	//	*ListCommitteesRequest_Epoch
	//	*ListCommitteesRequest_Genesis
	QueryFilter          isListCommitteesRequest_QueryFilter `protobuf_oneof:"query_filter"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *ListCommitteesRequest) Reset()         { *m = ListCommitteesRequest{} }
func (m *ListCommitteesRequest) String() string { return proto.CompactTextString(m) }
func (*ListCommitteesRequest) ProtoMessage()    {}
func (*ListCommitteesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{9}
}
func (m *ListCommitteesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListCommitteesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListCommitteesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListCommitteesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListCommitteesRequest.Merge(m, src)
}
func (m *ListCommitteesRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListCommitteesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListCommitteesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListCommitteesRequest proto.InternalMessageInfo

type isListCommitteesRequest_QueryFilter interface {
	isListCommitteesRequest_QueryFilter()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ListCommitteesRequest_Epoch struct {
	Epoch uint64 `protobuf:"varint,1,opt,name=epoch,proto3,oneof"`
}
type ListCommitteesRequest_Genesis struct {
	Genesis bool `protobuf:"varint,2,opt,name=genesis,proto3,oneof"`
}

func (*ListCommitteesRequest_Epoch) isListCommitteesRequest_QueryFilter()   {}
func (*ListCommitteesRequest_Genesis) isListCommitteesRequest_QueryFilter() {}

func (m *ListCommitteesRequest) GetQueryFilter() isListCommitteesRequest_QueryFilter {
	if m != nil {
		return m.QueryFilter
	}
	return nil
}

func (m *ListCommitteesRequest) GetEpoch() uint64 {
	if x, ok := m.GetQueryFilter().(*ListCommitteesRequest_Epoch); ok {
		return x.Epoch
	}
	return 0
}

func (m *ListCommitteesRequest) GetGenesis() bool {
	if x, ok := m.GetQueryFilter().(*ListCommitteesRequest_Genesis); ok {
		return x.Genesis
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ListCommitteesRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ListCommitteesRequest_OneofMarshaler, _ListCommitteesRequest_OneofUnmarshaler, _ListCommitteesRequest_OneofSizer, []interface{}{
		(*ListCommitteesRequest_Epoch)(nil),
		(*ListCommitteesRequest_Genesis)(nil),
	}
}

func _ListCommitteesRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ListCommitteesRequest)
	// query_filter
	switch x := m.QueryFilter.(type) {
	case *ListCommitteesRequest_Epoch:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Epoch))
	case *ListCommitteesRequest_Genesis:
		t := uint64(0)
		if x.Genesis {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("ListCommitteesRequest.QueryFilter has unexpected type %T", x)
	}
	return nil
}

func _ListCommitteesRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ListCommitteesRequest)
	switch tag {
	case 1: // query_filter.epoch
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.QueryFilter = &ListCommitteesRequest_Epoch{x}
		return true, err
	case 2: // query_filter.genesis
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.QueryFilter = &ListCommitteesRequest_Genesis{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _ListCommitteesRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ListCommitteesRequest)
	// query_filter
	switch x := m.QueryFilter.(type) {
	case *ListCommitteesRequest_Epoch:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Epoch))
	case *ListCommitteesRequest_Genesis:
		n += 1 // tag and wire
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type BeaconCommittees struct {
	Epoch                uint64                                      `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	Committees           map[uint64]*BeaconCommittees_CommitteesList `protobuf:"bytes,2,rep,name=committees,proto3" json:"committees,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ActiveValidatorCount uint64                                      `protobuf:"varint,3,opt,name=active_validator_count,json=activeValidatorCount,proto3" json:"active_validator_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                    `json:"-"`
	XXX_unrecognized     []byte                                      `json:"-"`
	XXX_sizecache        int32                                       `json:"-"`
}

func (m *BeaconCommittees) Reset()         { *m = BeaconCommittees{} }
func (m *BeaconCommittees) String() string { return proto.CompactTextString(m) }
func (*BeaconCommittees) ProtoMessage()    {}
func (*BeaconCommittees) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{10}
}
func (m *BeaconCommittees) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BeaconCommittees) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BeaconCommittees.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BeaconCommittees) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BeaconCommittees.Merge(m, src)
}
func (m *BeaconCommittees) XXX_Size() int {
	return m.Size()
}
func (m *BeaconCommittees) XXX_DiscardUnknown() {
	xxx_messageInfo_BeaconCommittees.DiscardUnknown(m)
}

var xxx_messageInfo_BeaconCommittees proto.InternalMessageInfo

func (m *BeaconCommittees) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *BeaconCommittees) GetCommittees() map[uint64]*BeaconCommittees_CommitteesList {
	if m != nil {
		return m.Committees
	}
	return nil
}

func (m *BeaconCommittees) GetActiveValidatorCount() uint64 {
	if m != nil {
		return m.ActiveValidatorCount
	}
	return 0
}

type BeaconCommittees_CommitteeItem struct {
	ValidatorIndices     []uint64 `protobuf:"varint,1,rep,packed,name=validator_indices,json=validatorIndices,proto3" json:"validator_indices,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BeaconCommittees_CommitteeItem) Reset()         { *m = BeaconCommittees_CommitteeItem{} }
func (m *BeaconCommittees_CommitteeItem) String() string { return proto.CompactTextString(m) }
func (*BeaconCommittees_CommitteeItem) ProtoMessage()    {}
func (*BeaconCommittees_CommitteeItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{10, 0}
}
func (m *BeaconCommittees_CommitteeItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BeaconCommittees_CommitteeItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BeaconCommittees_CommitteeItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BeaconCommittees_CommitteeItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BeaconCommittees_CommitteeItem.Merge(m, src)
}
func (m *BeaconCommittees_CommitteeItem) XXX_Size() int {
	return m.Size()
}
func (m *BeaconCommittees_CommitteeItem) XXX_DiscardUnknown() {
	xxx_messageInfo_BeaconCommittees_CommitteeItem.DiscardUnknown(m)
}

var xxx_messageInfo_BeaconCommittees_CommitteeItem proto.InternalMessageInfo

func (m *BeaconCommittees_CommitteeItem) GetValidatorIndices() []uint64 {
	if m != nil {
		return m.ValidatorIndices
	}
	return nil
}

type BeaconCommittees_CommitteesList struct {
	Committees           []*BeaconCommittees_CommitteeItem `protobuf:"bytes,1,rep,name=committees,proto3" json:"committees,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *BeaconCommittees_CommitteesList) Reset()         { *m = BeaconCommittees_CommitteesList{} }
func (m *BeaconCommittees_CommitteesList) String() string { return proto.CompactTextString(m) }
func (*BeaconCommittees_CommitteesList) ProtoMessage()    {}
func (*BeaconCommittees_CommitteesList) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{10, 1}
}
func (m *BeaconCommittees_CommitteesList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BeaconCommittees_CommitteesList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BeaconCommittees_CommitteesList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BeaconCommittees_CommitteesList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BeaconCommittees_CommitteesList.Merge(m, src)
}
func (m *BeaconCommittees_CommitteesList) XXX_Size() int {
	return m.Size()
}
func (m *BeaconCommittees_CommitteesList) XXX_DiscardUnknown() {
	xxx_messageInfo_BeaconCommittees_CommitteesList.DiscardUnknown(m)
}

var xxx_messageInfo_BeaconCommittees_CommitteesList proto.InternalMessageInfo

func (m *BeaconCommittees_CommitteesList) GetCommittees() []*BeaconCommittees_CommitteeItem {
	if m != nil {
		return m.Committees
	}
	return nil
}

type ListValidatorBalancesRequest struct {
	// Types that are valid to be assigned to QueryFilter:
	//	*ListValidatorBalancesRequest_Epoch
	//	*ListValidatorBalancesRequest_Genesis
	QueryFilter          isListValidatorBalancesRequest_QueryFilter `protobuf_oneof:"query_filter"`
	PublicKeys           [][]byte                                   `protobuf:"bytes,3,rep,name=public_keys,json=publicKeys,proto3" json:"public_keys,omitempty" ssz-size:"?,48"`
	Indices              []uint64                                   `protobuf:"varint,4,rep,packed,name=indices,proto3" json:"indices,omitempty"`
	PageSize             int32                                      `protobuf:"varint,5,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	PageToken            string                                     `protobuf:"bytes,6,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                   `json:"-"`
	XXX_unrecognized     []byte                                     `json:"-"`
	XXX_sizecache        int32                                      `json:"-"`
}

func (m *ListValidatorBalancesRequest) Reset()         { *m = ListValidatorBalancesRequest{} }
func (m *ListValidatorBalancesRequest) String() string { return proto.CompactTextString(m) }
func (*ListValidatorBalancesRequest) ProtoMessage()    {}
func (*ListValidatorBalancesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{11}
}
func (m *ListValidatorBalancesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListValidatorBalancesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListValidatorBalancesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListValidatorBalancesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListValidatorBalancesRequest.Merge(m, src)
}
func (m *ListValidatorBalancesRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListValidatorBalancesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListValidatorBalancesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListValidatorBalancesRequest proto.InternalMessageInfo

type isListValidatorBalancesRequest_QueryFilter interface {
	isListValidatorBalancesRequest_QueryFilter()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ListValidatorBalancesRequest_Epoch struct {
	Epoch uint64 `protobuf:"varint,1,opt,name=epoch,proto3,oneof"`
}
type ListValidatorBalancesRequest_Genesis struct {
	Genesis bool `protobuf:"varint,2,opt,name=genesis,proto3,oneof"`
}

func (*ListValidatorBalancesRequest_Epoch) isListValidatorBalancesRequest_QueryFilter()   {}
func (*ListValidatorBalancesRequest_Genesis) isListValidatorBalancesRequest_QueryFilter() {}

func (m *ListValidatorBalancesRequest) GetQueryFilter() isListValidatorBalancesRequest_QueryFilter {
	if m != nil {
		return m.QueryFilter
	}
	return nil
}

func (m *ListValidatorBalancesRequest) GetEpoch() uint64 {
	if x, ok := m.GetQueryFilter().(*ListValidatorBalancesRequest_Epoch); ok {
		return x.Epoch
	}
	return 0
}

func (m *ListValidatorBalancesRequest) GetGenesis() bool {
	if x, ok := m.GetQueryFilter().(*ListValidatorBalancesRequest_Genesis); ok {
		return x.Genesis
	}
	return false
}

func (m *ListValidatorBalancesRequest) GetPublicKeys() [][]byte {
	if m != nil {
		return m.PublicKeys
	}
	return nil
}

func (m *ListValidatorBalancesRequest) GetIndices() []uint64 {
	if m != nil {
		return m.Indices
	}
	return nil
}

func (m *ListValidatorBalancesRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListValidatorBalancesRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ListValidatorBalancesRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ListValidatorBalancesRequest_OneofMarshaler, _ListValidatorBalancesRequest_OneofUnmarshaler, _ListValidatorBalancesRequest_OneofSizer, []interface{}{
		(*ListValidatorBalancesRequest_Epoch)(nil),
		(*ListValidatorBalancesRequest_Genesis)(nil),
	}
}

func _ListValidatorBalancesRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ListValidatorBalancesRequest)
	// query_filter
	switch x := m.QueryFilter.(type) {
	case *ListValidatorBalancesRequest_Epoch:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Epoch))
	case *ListValidatorBalancesRequest_Genesis:
		t := uint64(0)
		if x.Genesis {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("ListValidatorBalancesRequest.QueryFilter has unexpected type %T", x)
	}
	return nil
}

func _ListValidatorBalancesRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ListValidatorBalancesRequest)
	switch tag {
	case 1: // query_filter.epoch
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.QueryFilter = &ListValidatorBalancesRequest_Epoch{x}
		return true, err
	case 2: // query_filter.genesis
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.QueryFilter = &ListValidatorBalancesRequest_Genesis{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _ListValidatorBalancesRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ListValidatorBalancesRequest)
	// query_filter
	switch x := m.QueryFilter.(type) {
	case *ListValidatorBalancesRequest_Epoch:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Epoch))
	case *ListValidatorBalancesRequest_Genesis:
		n += 1 // tag and wire
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ValidatorBalances struct {
	Epoch                uint64                       `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	Balances             []*ValidatorBalances_Balance `protobuf:"bytes,2,rep,name=balances,proto3" json:"balances,omitempty"`
	NextPageToken        string                       `protobuf:"bytes,3,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	TotalSize            int32                        `protobuf:"varint,4,opt,name=total_size,json=totalSize,proto3" json:"total_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *ValidatorBalances) Reset()         { *m = ValidatorBalances{} }
func (m *ValidatorBalances) String() string { return proto.CompactTextString(m) }
func (*ValidatorBalances) ProtoMessage()    {}
func (*ValidatorBalances) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{12}
}
func (m *ValidatorBalances) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorBalances) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorBalances.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorBalances) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorBalances.Merge(m, src)
}
func (m *ValidatorBalances) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorBalances) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorBalances.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorBalances proto.InternalMessageInfo

func (m *ValidatorBalances) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *ValidatorBalances) GetBalances() []*ValidatorBalances_Balance {
	if m != nil {
		return m.Balances
	}
	return nil
}

func (m *ValidatorBalances) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *ValidatorBalances) GetTotalSize() int32 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

type ValidatorBalances_Balance struct {
	PublicKey            []byte   `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty" ssz-size:"48"`
	Index                uint64   `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	Balance              uint64   `protobuf:"varint,3,opt,name=balance,proto3" json:"balance,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ValidatorBalances_Balance) Reset()         { *m = ValidatorBalances_Balance{} }
func (m *ValidatorBalances_Balance) String() string { return proto.CompactTextString(m) }
func (*ValidatorBalances_Balance) ProtoMessage()    {}
func (*ValidatorBalances_Balance) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{12, 0}
}
func (m *ValidatorBalances_Balance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorBalances_Balance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorBalances_Balance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorBalances_Balance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorBalances_Balance.Merge(m, src)
}
func (m *ValidatorBalances_Balance) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorBalances_Balance) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorBalances_Balance.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorBalances_Balance proto.InternalMessageInfo

func (m *ValidatorBalances_Balance) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *ValidatorBalances_Balance) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *ValidatorBalances_Balance) GetBalance() uint64 {
	if m != nil {
		return m.Balance
	}
	return 0
}

type ListValidatorsRequest struct {
	// Types that are valid to be assigned to QueryFilter:
	//	*ListValidatorsRequest_Epoch
	//	*ListValidatorsRequest_Genesis
	QueryFilter          isListValidatorsRequest_QueryFilter `protobuf_oneof:"query_filter"`
	Active               bool                                `protobuf:"varint,3,opt,name=active,proto3" json:"active,omitempty"`
	PageSize             int32                               `protobuf:"varint,4,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	PageToken            string                              `protobuf:"bytes,5,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	PublicKeys           [][]byte                            `protobuf:"bytes,6,rep,name=public_keys,json=publicKeys,proto3" json:"public_keys,omitempty"`
	Indices              []uint64                            `protobuf:"varint,7,rep,packed,name=indices,proto3" json:"indices,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *ListValidatorsRequest) Reset()         { *m = ListValidatorsRequest{} }
func (m *ListValidatorsRequest) String() string { return proto.CompactTextString(m) }
func (*ListValidatorsRequest) ProtoMessage()    {}
func (*ListValidatorsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{13}
}
func (m *ListValidatorsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListValidatorsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListValidatorsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListValidatorsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListValidatorsRequest.Merge(m, src)
}
func (m *ListValidatorsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListValidatorsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListValidatorsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListValidatorsRequest proto.InternalMessageInfo

type isListValidatorsRequest_QueryFilter interface {
	isListValidatorsRequest_QueryFilter()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ListValidatorsRequest_Epoch struct {
	Epoch uint64 `protobuf:"varint,1,opt,name=epoch,proto3,oneof"`
}
type ListValidatorsRequest_Genesis struct {
	Genesis bool `protobuf:"varint,2,opt,name=genesis,proto3,oneof"`
}

func (*ListValidatorsRequest_Epoch) isListValidatorsRequest_QueryFilter()   {}
func (*ListValidatorsRequest_Genesis) isListValidatorsRequest_QueryFilter() {}

func (m *ListValidatorsRequest) GetQueryFilter() isListValidatorsRequest_QueryFilter {
	if m != nil {
		return m.QueryFilter
	}
	return nil
}

func (m *ListValidatorsRequest) GetEpoch() uint64 {
	if x, ok := m.GetQueryFilter().(*ListValidatorsRequest_Epoch); ok {
		return x.Epoch
	}
	return 0
}

func (m *ListValidatorsRequest) GetGenesis() bool {
	if x, ok := m.GetQueryFilter().(*ListValidatorsRequest_Genesis); ok {
		return x.Genesis
	}
	return false
}

func (m *ListValidatorsRequest) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *ListValidatorsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListValidatorsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *ListValidatorsRequest) GetPublicKeys() [][]byte {
	if m != nil {
		return m.PublicKeys
	}
	return nil
}

func (m *ListValidatorsRequest) GetIndices() []uint64 {
	if m != nil {
		return m.Indices
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ListValidatorsRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ListValidatorsRequest_OneofMarshaler, _ListValidatorsRequest_OneofUnmarshaler, _ListValidatorsRequest_OneofSizer, []interface{}{
		(*ListValidatorsRequest_Epoch)(nil),
		(*ListValidatorsRequest_Genesis)(nil),
	}
}

func _ListValidatorsRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ListValidatorsRequest)
	// query_filter
	switch x := m.QueryFilter.(type) {
	case *ListValidatorsRequest_Epoch:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Epoch))
	case *ListValidatorsRequest_Genesis:
		t := uint64(0)
		if x.Genesis {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("ListValidatorsRequest.QueryFilter has unexpected type %T", x)
	}
	return nil
}

func _ListValidatorsRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ListValidatorsRequest)
	switch tag {
	case 1: // query_filter.epoch
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.QueryFilter = &ListValidatorsRequest_Epoch{x}
		return true, err
	case 2: // query_filter.genesis
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.QueryFilter = &ListValidatorsRequest_Genesis{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _ListValidatorsRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ListValidatorsRequest)
	// query_filter
	switch x := m.QueryFilter.(type) {
	case *ListValidatorsRequest_Epoch:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Epoch))
	case *ListValidatorsRequest_Genesis:
		n += 1 // tag and wire
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type GetValidatorRequest struct {
	// Types that are valid to be assigned to QueryFilter:
	//	*GetValidatorRequest_Index
	//	*GetValidatorRequest_PublicKey
	QueryFilter          isGetValidatorRequest_QueryFilter `protobuf_oneof:"query_filter"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *GetValidatorRequest) Reset()         { *m = GetValidatorRequest{} }
func (m *GetValidatorRequest) String() string { return proto.CompactTextString(m) }
func (*GetValidatorRequest) ProtoMessage()    {}
func (*GetValidatorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{14}
}
func (m *GetValidatorRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetValidatorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetValidatorRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetValidatorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetValidatorRequest.Merge(m, src)
}
func (m *GetValidatorRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetValidatorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetValidatorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetValidatorRequest proto.InternalMessageInfo

type isGetValidatorRequest_QueryFilter interface {
	isGetValidatorRequest_QueryFilter()
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetValidatorRequest_Index struct {
	Index uint64 `protobuf:"varint,1,opt,name=index,proto3,oneof"`
}
type GetValidatorRequest_PublicKey struct {
	PublicKey []byte `protobuf:"bytes,2,opt,name=public_key,json=publicKey,proto3,oneof"`
}

func (*GetValidatorRequest_Index) isGetValidatorRequest_QueryFilter()     {}
func (*GetValidatorRequest_PublicKey) isGetValidatorRequest_QueryFilter() {}

func (m *GetValidatorRequest) GetQueryFilter() isGetValidatorRequest_QueryFilter {
	if m != nil {
		return m.QueryFilter
	}
	return nil
}

func (m *GetValidatorRequest) GetIndex() uint64 {
	if x, ok := m.GetQueryFilter().(*GetValidatorRequest_Index); ok {
		return x.Index
	}
	return 0
}

func (m *GetValidatorRequest) GetPublicKey() []byte {
	if x, ok := m.GetQueryFilter().(*GetValidatorRequest_PublicKey); ok {
		return x.PublicKey
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GetValidatorRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GetValidatorRequest_OneofMarshaler, _GetValidatorRequest_OneofUnmarshaler, _GetValidatorRequest_OneofSizer, []interface{}{
		(*GetValidatorRequest_Index)(nil),
		(*GetValidatorRequest_PublicKey)(nil),
	}
}

func _GetValidatorRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GetValidatorRequest)
	// query_filter
	switch x := m.QueryFilter.(type) {
	case *GetValidatorRequest_Index:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Index))
	case *GetValidatorRequest_PublicKey:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.PublicKey)
	case nil:
	default:
		return fmt.Errorf("GetValidatorRequest.QueryFilter has unexpected type %T", x)
	}
	return nil
}

func _GetValidatorRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GetValidatorRequest)
	switch tag {
	case 1: // query_filter.index
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.QueryFilter = &GetValidatorRequest_Index{x}
		return true, err
	case 2: // query_filter.public_key
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.QueryFilter = &GetValidatorRequest_PublicKey{x}
		return true, err
	default:
		return false, nil
	}
}

func _GetValidatorRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GetValidatorRequest)
	// query_filter
	switch x := m.QueryFilter.(type) {
	case *GetValidatorRequest_Index:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Index))
	case *GetValidatorRequest_PublicKey:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.PublicKey)))
		n += len(x.PublicKey)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Validators struct {
	Epoch                uint64                           `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	ValidatorList        []*Validators_ValidatorContainer `protobuf:"bytes,2,rep,name=validator_list,json=validatorList,proto3" json:"validator_list,omitempty"`
	NextPageToken        string                           `protobuf:"bytes,3,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	TotalSize            int32                            `protobuf:"varint,4,opt,name=total_size,json=totalSize,proto3" json:"total_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *Validators) Reset()         { *m = Validators{} }
func (m *Validators) String() string { return proto.CompactTextString(m) }
func (*Validators) ProtoMessage()    {}
func (*Validators) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{15}
}
func (m *Validators) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Validators) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Validators.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Validators) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Validators.Merge(m, src)
}
func (m *Validators) XXX_Size() int {
	return m.Size()
}
func (m *Validators) XXX_DiscardUnknown() {
	xxx_messageInfo_Validators.DiscardUnknown(m)
}

var xxx_messageInfo_Validators proto.InternalMessageInfo

func (m *Validators) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *Validators) GetValidatorList() []*Validators_ValidatorContainer {
	if m != nil {
		return m.ValidatorList
	}
	return nil
}

func (m *Validators) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *Validators) GetTotalSize() int32 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

type Validators_ValidatorContainer struct {
	Index                uint64     `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Validator            *Validator `protobuf:"bytes,2,opt,name=validator,proto3" json:"validator,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Validators_ValidatorContainer) Reset()         { *m = Validators_ValidatorContainer{} }
func (m *Validators_ValidatorContainer) String() string { return proto.CompactTextString(m) }
func (*Validators_ValidatorContainer) ProtoMessage()    {}
func (*Validators_ValidatorContainer) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{15, 0}
}
func (m *Validators_ValidatorContainer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Validators_ValidatorContainer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Validators_ValidatorContainer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Validators_ValidatorContainer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Validators_ValidatorContainer.Merge(m, src)
}
func (m *Validators_ValidatorContainer) XXX_Size() int {
	return m.Size()
}
func (m *Validators_ValidatorContainer) XXX_DiscardUnknown() {
	xxx_messageInfo_Validators_ValidatorContainer.DiscardUnknown(m)
}

var xxx_messageInfo_Validators_ValidatorContainer proto.InternalMessageInfo

func (m *Validators_ValidatorContainer) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Validators_ValidatorContainer) GetValidator() *Validator {
	if m != nil {
		return m.Validator
	}
	return nil
}

type GetValidatorActiveSetChangesRequest struct {
	// Types that are valid to be assigned to QueryFilter:
	//	*GetValidatorActiveSetChangesRequest_Epoch
	//	*GetValidatorActiveSetChangesRequest_Genesis
	QueryFilter          isGetValidatorActiveSetChangesRequest_QueryFilter `protobuf_oneof:"query_filter"`
	XXX_NoUnkeyedLiteral struct{}                                          `json:"-"`
	XXX_unrecognized     []byte                                            `json:"-"`
	XXX_sizecache        int32                                             `json:"-"`
}

func (m *GetValidatorActiveSetChangesRequest) Reset()         { *m = GetValidatorActiveSetChangesRequest{} }
func (m *GetValidatorActiveSetChangesRequest) String() string { return proto.CompactTextString(m) }
func (*GetValidatorActiveSetChangesRequest) ProtoMessage()    {}
func (*GetValidatorActiveSetChangesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{16}
}
func (m *GetValidatorActiveSetChangesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetValidatorActiveSetChangesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetValidatorActiveSetChangesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetValidatorActiveSetChangesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetValidatorActiveSetChangesRequest.Merge(m, src)
}
func (m *GetValidatorActiveSetChangesRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetValidatorActiveSetChangesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetValidatorActiveSetChangesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetValidatorActiveSetChangesRequest proto.InternalMessageInfo

type isGetValidatorActiveSetChangesRequest_QueryFilter interface {
	isGetValidatorActiveSetChangesRequest_QueryFilter()
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetValidatorActiveSetChangesRequest_Epoch struct {
	Epoch uint64 `protobuf:"varint,1,opt,name=epoch,proto3,oneof"`
}
type GetValidatorActiveSetChangesRequest_Genesis struct {
	Genesis bool `protobuf:"varint,2,opt,name=genesis,proto3,oneof"`
}

func (*GetValidatorActiveSetChangesRequest_Epoch) isGetValidatorActiveSetChangesRequest_QueryFilter() {
}
func (*GetValidatorActiveSetChangesRequest_Genesis) isGetValidatorActiveSetChangesRequest_QueryFilter() {
}

func (m *GetValidatorActiveSetChangesRequest) GetQueryFilter() isGetValidatorActiveSetChangesRequest_QueryFilter {
	if m != nil {
		return m.QueryFilter
	}
	return nil
}

func (m *GetValidatorActiveSetChangesRequest) GetEpoch() uint64 {
	if x, ok := m.GetQueryFilter().(*GetValidatorActiveSetChangesRequest_Epoch); ok {
		return x.Epoch
	}
	return 0
}

func (m *GetValidatorActiveSetChangesRequest) GetGenesis() bool {
	if x, ok := m.GetQueryFilter().(*GetValidatorActiveSetChangesRequest_Genesis); ok {
		return x.Genesis
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GetValidatorActiveSetChangesRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GetValidatorActiveSetChangesRequest_OneofMarshaler, _GetValidatorActiveSetChangesRequest_OneofUnmarshaler, _GetValidatorActiveSetChangesRequest_OneofSizer, []interface{}{
		(*GetValidatorActiveSetChangesRequest_Epoch)(nil),
		(*GetValidatorActiveSetChangesRequest_Genesis)(nil),
	}
}

func _GetValidatorActiveSetChangesRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GetValidatorActiveSetChangesRequest)
	// query_filter
	switch x := m.QueryFilter.(type) {
	case *GetValidatorActiveSetChangesRequest_Epoch:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Epoch))
	case *GetValidatorActiveSetChangesRequest_Genesis:
		t := uint64(0)
		if x.Genesis {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("GetValidatorActiveSetChangesRequest.QueryFilter has unexpected type %T", x)
	}
	return nil
}

func _GetValidatorActiveSetChangesRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GetValidatorActiveSetChangesRequest)
	switch tag {
	case 1: // query_filter.epoch
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.QueryFilter = &GetValidatorActiveSetChangesRequest_Epoch{x}
		return true, err
	case 2: // query_filter.genesis
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.QueryFilter = &GetValidatorActiveSetChangesRequest_Genesis{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _GetValidatorActiveSetChangesRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GetValidatorActiveSetChangesRequest)
	// query_filter
	switch x := m.QueryFilter.(type) {
	case *GetValidatorActiveSetChangesRequest_Epoch:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Epoch))
	case *GetValidatorActiveSetChangesRequest_Genesis:
		n += 1 // tag and wire
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ActiveSetChanges struct {
	Epoch                uint64   `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	ActivatedPublicKeys  [][]byte `protobuf:"bytes,2,rep,name=activated_public_keys,json=activatedPublicKeys,proto3" json:"activated_public_keys,omitempty" ssz-size:"?,48"`
	ActivatedIndices     []uint64 `protobuf:"varint,3,rep,packed,name=activated_indices,json=activatedIndices,proto3" json:"activated_indices,omitempty"`
	ExitedPublicKeys     [][]byte `protobuf:"bytes,4,rep,name=exited_public_keys,json=exitedPublicKeys,proto3" json:"exited_public_keys,omitempty" ssz-size:"?,48"`
	ExitedIndices        []uint64 `protobuf:"varint,5,rep,packed,name=exited_indices,json=exitedIndices,proto3" json:"exited_indices,omitempty"`
	SlashedPublicKeys    [][]byte `protobuf:"bytes,6,rep,name=slashed_public_keys,json=slashedPublicKeys,proto3" json:"slashed_public_keys,omitempty" ssz-size:"?,48"`
	SlashedIndices       []uint64 `protobuf:"varint,7,rep,packed,name=slashed_indices,json=slashedIndices,proto3" json:"slashed_indices,omitempty"`
	EjectedPublicKeys    [][]byte `protobuf:"bytes,8,rep,name=ejected_public_keys,json=ejectedPublicKeys,proto3" json:"ejected_public_keys,omitempty" ssz-size:"?,48"`
	EjectedIndices       []uint64 `protobuf:"varint,9,rep,packed,name=ejected_indices,json=ejectedIndices,proto3" json:"ejected_indices,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ActiveSetChanges) Reset()         { *m = ActiveSetChanges{} }
func (m *ActiveSetChanges) String() string { return proto.CompactTextString(m) }
func (*ActiveSetChanges) ProtoMessage()    {}
func (*ActiveSetChanges) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{17}
}
func (m *ActiveSetChanges) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActiveSetChanges) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActiveSetChanges.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActiveSetChanges) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActiveSetChanges.Merge(m, src)
}
func (m *ActiveSetChanges) XXX_Size() int {
	return m.Size()
}
func (m *ActiveSetChanges) XXX_DiscardUnknown() {
	xxx_messageInfo_ActiveSetChanges.DiscardUnknown(m)
}

var xxx_messageInfo_ActiveSetChanges proto.InternalMessageInfo

func (m *ActiveSetChanges) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *ActiveSetChanges) GetActivatedPublicKeys() [][]byte {
	if m != nil {
		return m.ActivatedPublicKeys
	}
	return nil
}

func (m *ActiveSetChanges) GetActivatedIndices() []uint64 {
	if m != nil {
		return m.ActivatedIndices
	}
	return nil
}

func (m *ActiveSetChanges) GetExitedPublicKeys() [][]byte {
	if m != nil {
		return m.ExitedPublicKeys
	}
	return nil
}

func (m *ActiveSetChanges) GetExitedIndices() []uint64 {
	if m != nil {
		return m.ExitedIndices
	}
	return nil
}

func (m *ActiveSetChanges) GetSlashedPublicKeys() [][]byte {
	if m != nil {
		return m.SlashedPublicKeys
	}
	return nil
}

func (m *ActiveSetChanges) GetSlashedIndices() []uint64 {
	if m != nil {
		return m.SlashedIndices
	}
	return nil
}

func (m *ActiveSetChanges) GetEjectedPublicKeys() [][]byte {
	if m != nil {
		return m.EjectedPublicKeys
	}
	return nil
}

func (m *ActiveSetChanges) GetEjectedIndices() []uint64 {
	if m != nil {
		return m.EjectedIndices
	}
	return nil
}

type ValidatorPerformanceRequest struct {
	PublicKeys           [][]byte `protobuf:"bytes,1,rep,name=public_keys,json=publicKeys,proto3" json:"public_keys,omitempty"`
	Indices              []uint64 `protobuf:"varint,2,rep,packed,name=indices,proto3" json:"indices,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ValidatorPerformanceRequest) Reset()         { *m = ValidatorPerformanceRequest{} }
func (m *ValidatorPerformanceRequest) String() string { return proto.CompactTextString(m) }
func (*ValidatorPerformanceRequest) ProtoMessage()    {}
func (*ValidatorPerformanceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{18}
}
func (m *ValidatorPerformanceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorPerformanceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorPerformanceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorPerformanceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorPerformanceRequest.Merge(m, src)
}
func (m *ValidatorPerformanceRequest) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorPerformanceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorPerformanceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorPerformanceRequest proto.InternalMessageInfo

func (m *ValidatorPerformanceRequest) GetPublicKeys() [][]byte {
	if m != nil {
		return m.PublicKeys
	}
	return nil
}

func (m *ValidatorPerformanceRequest) GetIndices() []uint64 {
	if m != nil {
		return m.Indices
	}
	return nil
}

type ValidatorPerformanceResponse struct {
	CurrentEffectiveBalances      []uint64 `protobuf:"varint,1,rep,packed,name=current_effective_balances,json=currentEffectiveBalances,proto3" json:"current_effective_balances,omitempty"`
	InclusionSlots                []uint64 `protobuf:"varint,2,rep,packed,name=inclusion_slots,json=inclusionSlots,proto3" json:"inclusion_slots,omitempty"`
	InclusionDistances            []uint64 `protobuf:"varint,3,rep,packed,name=inclusion_distances,json=inclusionDistances,proto3" json:"inclusion_distances,omitempty"`
	CorrectlyVotedSource          []bool   `protobuf:"varint,4,rep,packed,name=correctly_voted_source,json=correctlyVotedSource,proto3" json:"correctly_voted_source,omitempty"`
	CorrectlyVotedTarget          []bool   `protobuf:"varint,5,rep,packed,name=correctly_voted_target,json=correctlyVotedTarget,proto3" json:"correctly_voted_target,omitempty"`
	CorrectlyVotedHead            []bool   `protobuf:"varint,6,rep,packed,name=correctly_voted_head,json=correctlyVotedHead,proto3" json:"correctly_voted_head,omitempty"`
	BalancesBeforeEpochTransition []uint64 `protobuf:"varint,7,rep,packed,name=balances_before_epoch_transition,json=balancesBeforeEpochTransition,proto3" json:"balances_before_epoch_transition,omitempty"`
	BalancesAfterEpochTransition  []uint64 `protobuf:"varint,8,rep,packed,name=balances_after_epoch_transition,json=balancesAfterEpochTransition,proto3" json:"balances_after_epoch_transition,omitempty"`
	MissingValidators             [][]byte `protobuf:"bytes,9,rep,name=missing_validators,json=missingValidators,proto3" json:"missing_validators,omitempty"`
	AverageActiveValidatorBalance float32  `protobuf:"fixed32,10,opt,name=average_active_validator_balance,json=averageActiveValidatorBalance,proto3" json:"average_active_validator_balance,omitempty"`
	XXX_NoUnkeyedLiteral          struct{} `json:"-"`
	XXX_unrecognized              []byte   `json:"-"`
	XXX_sizecache                 int32    `json:"-"`
}

func (m *ValidatorPerformanceResponse) Reset()         { *m = ValidatorPerformanceResponse{} }
func (m *ValidatorPerformanceResponse) String() string { return proto.CompactTextString(m) }
func (*ValidatorPerformanceResponse) ProtoMessage()    {}
func (*ValidatorPerformanceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{19}
}
func (m *ValidatorPerformanceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorPerformanceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorPerformanceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorPerformanceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorPerformanceResponse.Merge(m, src)
}
func (m *ValidatorPerformanceResponse) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorPerformanceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorPerformanceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorPerformanceResponse proto.InternalMessageInfo

func (m *ValidatorPerformanceResponse) GetCurrentEffectiveBalances() []uint64 {
	if m != nil {
		return m.CurrentEffectiveBalances
	}
	return nil
}

func (m *ValidatorPerformanceResponse) GetInclusionSlots() []uint64 {
	if m != nil {
		return m.InclusionSlots
	}
	return nil
}

func (m *ValidatorPerformanceResponse) GetInclusionDistances() []uint64 {
	if m != nil {
		return m.InclusionDistances
	}
	return nil
}

func (m *ValidatorPerformanceResponse) GetCorrectlyVotedSource() []bool {
	if m != nil {
		return m.CorrectlyVotedSource
	}
	return nil
}

func (m *ValidatorPerformanceResponse) GetCorrectlyVotedTarget() []bool {
	if m != nil {
		return m.CorrectlyVotedTarget
	}
	return nil
}

func (m *ValidatorPerformanceResponse) GetCorrectlyVotedHead() []bool {
	if m != nil {
		return m.CorrectlyVotedHead
	}
	return nil
}

func (m *ValidatorPerformanceResponse) GetBalancesBeforeEpochTransition() []uint64 {
	if m != nil {
		return m.BalancesBeforeEpochTransition
	}
	return nil
}

func (m *ValidatorPerformanceResponse) GetBalancesAfterEpochTransition() []uint64 {
	if m != nil {
		return m.BalancesAfterEpochTransition
	}
	return nil
}

func (m *ValidatorPerformanceResponse) GetMissingValidators() [][]byte {
	if m != nil {
		return m.MissingValidators
	}
	return nil
}

func (m *ValidatorPerformanceResponse) GetAverageActiveValidatorBalance() float32 {
	if m != nil {
		return m.AverageActiveValidatorBalance
	}
	return 0
}

type ValidatorQueue struct {
	ChurnLimit                 uint64   `protobuf:"varint,1,opt,name=churn_limit,json=churnLimit,proto3" json:"churn_limit,omitempty"`
	ActivationPublicKeys       [][]byte `protobuf:"bytes,2,rep,name=activation_public_keys,json=activationPublicKeys,proto3" json:"activation_public_keys,omitempty" ssz-size:"?,48"` // Deprecated: Do not use.
	ExitPublicKeys             [][]byte `protobuf:"bytes,3,rep,name=exit_public_keys,json=exitPublicKeys,proto3" json:"exit_public_keys,omitempty" ssz-size:"?,48"`                   // Deprecated: Do not use.
	ActivationValidatorIndices []uint64 `protobuf:"varint,4,rep,packed,name=activation_validator_indices,json=activationValidatorIndices,proto3" json:"activation_validator_indices,omitempty"`
	ExitValidatorIndices       []uint64 `protobuf:"varint,5,rep,packed,name=exit_validator_indices,json=exitValidatorIndices,proto3" json:"exit_validator_indices,omitempty"`
	XXX_NoUnkeyedLiteral       struct{} `json:"-"`
	XXX_unrecognized           []byte   `json:"-"`
	XXX_sizecache              int32    `json:"-"`
}

func (m *ValidatorQueue) Reset()         { *m = ValidatorQueue{} }
func (m *ValidatorQueue) String() string { return proto.CompactTextString(m) }
func (*ValidatorQueue) ProtoMessage()    {}
func (*ValidatorQueue) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{20}
}
func (m *ValidatorQueue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorQueue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorQueue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorQueue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorQueue.Merge(m, src)
}
func (m *ValidatorQueue) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorQueue) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorQueue.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorQueue proto.InternalMessageInfo

func (m *ValidatorQueue) GetChurnLimit() uint64 {
	if m != nil {
		return m.ChurnLimit
	}
	return 0
}

// Deprecated: Do not use.
func (m *ValidatorQueue) GetActivationPublicKeys() [][]byte {
	if m != nil {
		return m.ActivationPublicKeys
	}
	return nil
}

// Deprecated: Do not use.
func (m *ValidatorQueue) GetExitPublicKeys() [][]byte {
	if m != nil {
		return m.ExitPublicKeys
	}
	return nil
}

func (m *ValidatorQueue) GetActivationValidatorIndices() []uint64 {
	if m != nil {
		return m.ActivationValidatorIndices
	}
	return nil
}

func (m *ValidatorQueue) GetExitValidatorIndices() []uint64 {
	if m != nil {
		return m.ExitValidatorIndices
	}
	return nil
}

type ListValidatorAssignmentsRequest struct {
	// Types that are valid to be assigned to QueryFilter:
	//	*ListValidatorAssignmentsRequest_Epoch
	//	*ListValidatorAssignmentsRequest_Genesis
	QueryFilter          isListValidatorAssignmentsRequest_QueryFilter `protobuf_oneof:"query_filter"`
	PublicKeys           [][]byte                                      `protobuf:"bytes,3,rep,name=public_keys,json=publicKeys,proto3" json:"public_keys,omitempty" ssz-size:"?,48"`
	Indices              []uint64                                      `protobuf:"varint,4,rep,packed,name=indices,proto3" json:"indices,omitempty"`
	PageSize             int32                                         `protobuf:"varint,5,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	PageToken            string                                        `protobuf:"bytes,6,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                      `json:"-"`
	XXX_unrecognized     []byte                                        `json:"-"`
	XXX_sizecache        int32                                         `json:"-"`
}

func (m *ListValidatorAssignmentsRequest) Reset()         { *m = ListValidatorAssignmentsRequest{} }
func (m *ListValidatorAssignmentsRequest) String() string { return proto.CompactTextString(m) }
func (*ListValidatorAssignmentsRequest) ProtoMessage()    {}
func (*ListValidatorAssignmentsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{21}
}
func (m *ListValidatorAssignmentsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListValidatorAssignmentsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListValidatorAssignmentsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListValidatorAssignmentsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListValidatorAssignmentsRequest.Merge(m, src)
}
func (m *ListValidatorAssignmentsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListValidatorAssignmentsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListValidatorAssignmentsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListValidatorAssignmentsRequest proto.InternalMessageInfo

type isListValidatorAssignmentsRequest_QueryFilter interface {
	isListValidatorAssignmentsRequest_QueryFilter()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ListValidatorAssignmentsRequest_Epoch struct {
	Epoch uint64 `protobuf:"varint,1,opt,name=epoch,proto3,oneof"`
}
type ListValidatorAssignmentsRequest_Genesis struct {
	Genesis bool `protobuf:"varint,2,opt,name=genesis,proto3,oneof"`
}

func (*ListValidatorAssignmentsRequest_Epoch) isListValidatorAssignmentsRequest_QueryFilter()   {}
func (*ListValidatorAssignmentsRequest_Genesis) isListValidatorAssignmentsRequest_QueryFilter() {}

func (m *ListValidatorAssignmentsRequest) GetQueryFilter() isListValidatorAssignmentsRequest_QueryFilter {
	if m != nil {
		return m.QueryFilter
	}
	return nil
}

func (m *ListValidatorAssignmentsRequest) GetEpoch() uint64 {
	if x, ok := m.GetQueryFilter().(*ListValidatorAssignmentsRequest_Epoch); ok {
		return x.Epoch
	}
	return 0
}

func (m *ListValidatorAssignmentsRequest) GetGenesis() bool {
	if x, ok := m.GetQueryFilter().(*ListValidatorAssignmentsRequest_Genesis); ok {
		return x.Genesis
	}
	return false
}

func (m *ListValidatorAssignmentsRequest) GetPublicKeys() [][]byte {
	if m != nil {
		return m.PublicKeys
	}
	return nil
}

func (m *ListValidatorAssignmentsRequest) GetIndices() []uint64 {
	if m != nil {
		return m.Indices
	}
	return nil
}

func (m *ListValidatorAssignmentsRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListValidatorAssignmentsRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ListValidatorAssignmentsRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ListValidatorAssignmentsRequest_OneofMarshaler, _ListValidatorAssignmentsRequest_OneofUnmarshaler, _ListValidatorAssignmentsRequest_OneofSizer, []interface{}{
		(*ListValidatorAssignmentsRequest_Epoch)(nil),
		(*ListValidatorAssignmentsRequest_Genesis)(nil),
	}
}

func _ListValidatorAssignmentsRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ListValidatorAssignmentsRequest)
	// query_filter
	switch x := m.QueryFilter.(type) {
	case *ListValidatorAssignmentsRequest_Epoch:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Epoch))
	case *ListValidatorAssignmentsRequest_Genesis:
		t := uint64(0)
		if x.Genesis {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("ListValidatorAssignmentsRequest.QueryFilter has unexpected type %T", x)
	}
	return nil
}

func _ListValidatorAssignmentsRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ListValidatorAssignmentsRequest)
	switch tag {
	case 1: // query_filter.epoch
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.QueryFilter = &ListValidatorAssignmentsRequest_Epoch{x}
		return true, err
	case 2: // query_filter.genesis
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.QueryFilter = &ListValidatorAssignmentsRequest_Genesis{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _ListValidatorAssignmentsRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ListValidatorAssignmentsRequest)
	// query_filter
	switch x := m.QueryFilter.(type) {
	case *ListValidatorAssignmentsRequest_Epoch:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Epoch))
	case *ListValidatorAssignmentsRequest_Genesis:
		n += 1 // tag and wire
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ValidatorAssignments struct {
	Epoch                uint64                                      `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	Assignments          []*ValidatorAssignments_CommitteeAssignment `protobuf:"bytes,2,rep,name=assignments,proto3" json:"assignments,omitempty"`
	NextPageToken        string                                      `protobuf:"bytes,3,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	TotalSize            int32                                       `protobuf:"varint,4,opt,name=total_size,json=totalSize,proto3" json:"total_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                    `json:"-"`
	XXX_unrecognized     []byte                                      `json:"-"`
	XXX_sizecache        int32                                       `json:"-"`
}

func (m *ValidatorAssignments) Reset()         { *m = ValidatorAssignments{} }
func (m *ValidatorAssignments) String() string { return proto.CompactTextString(m) }
func (*ValidatorAssignments) ProtoMessage()    {}
func (*ValidatorAssignments) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{22}
}
func (m *ValidatorAssignments) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorAssignments) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorAssignments.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorAssignments) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorAssignments.Merge(m, src)
}
func (m *ValidatorAssignments) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorAssignments) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorAssignments.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorAssignments proto.InternalMessageInfo

func (m *ValidatorAssignments) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *ValidatorAssignments) GetAssignments() []*ValidatorAssignments_CommitteeAssignment {
	if m != nil {
		return m.Assignments
	}
	return nil
}

func (m *ValidatorAssignments) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *ValidatorAssignments) GetTotalSize() int32 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

type ValidatorAssignments_CommitteeAssignment struct {
	BeaconCommittees     []uint64 `protobuf:"varint,1,rep,packed,name=beacon_committees,json=beaconCommittees,proto3" json:"beacon_committees,omitempty"`
	CommitteeIndex       uint64   `protobuf:"varint,2,opt,name=committee_index,json=committeeIndex,proto3" json:"committee_index,omitempty"`
	AttesterSlot         uint64   `protobuf:"varint,3,opt,name=attester_slot,json=attesterSlot,proto3" json:"attester_slot,omitempty"`
	ProposerSlots        []uint64 `protobuf:"varint,4,rep,packed,name=proposer_slots,json=proposerSlots,proto3" json:"proposer_slots,omitempty"`
	PublicKey            []byte   `protobuf:"bytes,5,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty" ssz-size:"48"` // Deprecated: Do not use.
	ValidatorIndex       uint64   `protobuf:"varint,6,opt,name=validator_index,json=validatorIndex,proto3" json:"validator_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ValidatorAssignments_CommitteeAssignment) Reset() {
	*m = ValidatorAssignments_CommitteeAssignment{}
}
func (m *ValidatorAssignments_CommitteeAssignment) String() string { return proto.CompactTextString(m) }
func (*ValidatorAssignments_CommitteeAssignment) ProtoMessage()    {}
func (*ValidatorAssignments_CommitteeAssignment) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{22, 0}
}
func (m *ValidatorAssignments_CommitteeAssignment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorAssignments_CommitteeAssignment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorAssignments_CommitteeAssignment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorAssignments_CommitteeAssignment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorAssignments_CommitteeAssignment.Merge(m, src)
}
func (m *ValidatorAssignments_CommitteeAssignment) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorAssignments_CommitteeAssignment) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorAssignments_CommitteeAssignment.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorAssignments_CommitteeAssignment proto.InternalMessageInfo

func (m *ValidatorAssignments_CommitteeAssignment) GetBeaconCommittees() []uint64 {
	if m != nil {
		return m.BeaconCommittees
	}
	return nil
}

func (m *ValidatorAssignments_CommitteeAssignment) GetCommitteeIndex() uint64 {
	if m != nil {
		return m.CommitteeIndex
	}
	return 0
}

func (m *ValidatorAssignments_CommitteeAssignment) GetAttesterSlot() uint64 {
	if m != nil {
		return m.AttesterSlot
	}
	return 0
}

func (m *ValidatorAssignments_CommitteeAssignment) GetProposerSlots() []uint64 {
	if m != nil {
		return m.ProposerSlots
	}
	return nil
}

// Deprecated: Do not use.
func (m *ValidatorAssignments_CommitteeAssignment) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *ValidatorAssignments_CommitteeAssignment) GetValidatorIndex() uint64 {
	if m != nil {
		return m.ValidatorIndex
	}
	return 0
}

type GetValidatorParticipationRequest struct {
	// Types that are valid to be assigned to QueryFilter:
	//	*GetValidatorParticipationRequest_Epoch
	//	*GetValidatorParticipationRequest_Genesis
	QueryFilter          isGetValidatorParticipationRequest_QueryFilter `protobuf_oneof:"query_filter"`
	XXX_NoUnkeyedLiteral struct{}                                       `json:"-"`
	XXX_unrecognized     []byte                                         `json:"-"`
	XXX_sizecache        int32                                          `json:"-"`
}

func (m *GetValidatorParticipationRequest) Reset()         { *m = GetValidatorParticipationRequest{} }
func (m *GetValidatorParticipationRequest) String() string { return proto.CompactTextString(m) }
func (*GetValidatorParticipationRequest) ProtoMessage()    {}
func (*GetValidatorParticipationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{23}
}
func (m *GetValidatorParticipationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetValidatorParticipationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetValidatorParticipationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetValidatorParticipationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetValidatorParticipationRequest.Merge(m, src)
}
func (m *GetValidatorParticipationRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetValidatorParticipationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetValidatorParticipationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetValidatorParticipationRequest proto.InternalMessageInfo

type isGetValidatorParticipationRequest_QueryFilter interface {
	isGetValidatorParticipationRequest_QueryFilter()
	MarshalTo([]byte) (int, error)
	Size() int
}

type GetValidatorParticipationRequest_Epoch struct {
	Epoch uint64 `protobuf:"varint,1,opt,name=epoch,proto3,oneof"`
}
type GetValidatorParticipationRequest_Genesis struct {
	Genesis bool `protobuf:"varint,2,opt,name=genesis,proto3,oneof"`
}

func (*GetValidatorParticipationRequest_Epoch) isGetValidatorParticipationRequest_QueryFilter()   {}
func (*GetValidatorParticipationRequest_Genesis) isGetValidatorParticipationRequest_QueryFilter() {}

func (m *GetValidatorParticipationRequest) GetQueryFilter() isGetValidatorParticipationRequest_QueryFilter {
	if m != nil {
		return m.QueryFilter
	}
	return nil
}

func (m *GetValidatorParticipationRequest) GetEpoch() uint64 {
	if x, ok := m.GetQueryFilter().(*GetValidatorParticipationRequest_Epoch); ok {
		return x.Epoch
	}
	return 0
}

func (m *GetValidatorParticipationRequest) GetGenesis() bool {
	if x, ok := m.GetQueryFilter().(*GetValidatorParticipationRequest_Genesis); ok {
		return x.Genesis
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GetValidatorParticipationRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GetValidatorParticipationRequest_OneofMarshaler, _GetValidatorParticipationRequest_OneofUnmarshaler, _GetValidatorParticipationRequest_OneofSizer, []interface{}{
		(*GetValidatorParticipationRequest_Epoch)(nil),
		(*GetValidatorParticipationRequest_Genesis)(nil),
	}
}

func _GetValidatorParticipationRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GetValidatorParticipationRequest)
	// query_filter
	switch x := m.QueryFilter.(type) {
	case *GetValidatorParticipationRequest_Epoch:
		_ = b.EncodeVarint(1<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Epoch))
	case *GetValidatorParticipationRequest_Genesis:
		t := uint64(0)
		if x.Genesis {
			t = 1
		}
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("GetValidatorParticipationRequest.QueryFilter has unexpected type %T", x)
	}
	return nil
}

func _GetValidatorParticipationRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GetValidatorParticipationRequest)
	switch tag {
	case 1: // query_filter.epoch
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.QueryFilter = &GetValidatorParticipationRequest_Epoch{x}
		return true, err
	case 2: // query_filter.genesis
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.QueryFilter = &GetValidatorParticipationRequest_Genesis{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _GetValidatorParticipationRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GetValidatorParticipationRequest)
	// query_filter
	switch x := m.QueryFilter.(type) {
	case *GetValidatorParticipationRequest_Epoch:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(x.Epoch))
	case *GetValidatorParticipationRequest_Genesis:
		n += 1 // tag and wire
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ValidatorParticipationResponse struct {
	Epoch                uint64                  `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	Finalized            bool                    `protobuf:"varint,2,opt,name=finalized,proto3" json:"finalized,omitempty"`
	Participation        *ValidatorParticipation `protobuf:"bytes,3,opt,name=participation,proto3" json:"participation,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *ValidatorParticipationResponse) Reset()         { *m = ValidatorParticipationResponse{} }
func (m *ValidatorParticipationResponse) String() string { return proto.CompactTextString(m) }
func (*ValidatorParticipationResponse) ProtoMessage()    {}
func (*ValidatorParticipationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{24}
}
func (m *ValidatorParticipationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorParticipationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorParticipationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorParticipationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorParticipationResponse.Merge(m, src)
}
func (m *ValidatorParticipationResponse) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorParticipationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorParticipationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorParticipationResponse proto.InternalMessageInfo

func (m *ValidatorParticipationResponse) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *ValidatorParticipationResponse) GetFinalized() bool {
	if m != nil {
		return m.Finalized
	}
	return false
}

func (m *ValidatorParticipationResponse) GetParticipation() *ValidatorParticipation {
	if m != nil {
		return m.Participation
	}
	return nil
}

type AttestationPoolRequest struct {
	PageSize             int32    `protobuf:"varint,1,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	PageToken            string   `protobuf:"bytes,2,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AttestationPoolRequest) Reset()         { *m = AttestationPoolRequest{} }
func (m *AttestationPoolRequest) String() string { return proto.CompactTextString(m) }
func (*AttestationPoolRequest) ProtoMessage()    {}
func (*AttestationPoolRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{25}
}
func (m *AttestationPoolRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttestationPoolRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttestationPoolRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttestationPoolRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttestationPoolRequest.Merge(m, src)
}
func (m *AttestationPoolRequest) XXX_Size() int {
	return m.Size()
}
func (m *AttestationPoolRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AttestationPoolRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AttestationPoolRequest proto.InternalMessageInfo

func (m *AttestationPoolRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *AttestationPoolRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

type AttestationPoolResponse struct {
	Attestations         []*Attestation `protobuf:"bytes,1,rep,name=attestations,proto3" json:"attestations,omitempty"`
	NextPageToken        string         `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	TotalSize            int32          `protobuf:"varint,3,opt,name=total_size,json=totalSize,proto3" json:"total_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *AttestationPoolResponse) Reset()         { *m = AttestationPoolResponse{} }
func (m *AttestationPoolResponse) String() string { return proto.CompactTextString(m) }
func (*AttestationPoolResponse) ProtoMessage()    {}
func (*AttestationPoolResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{26}
}
func (m *AttestationPoolResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttestationPoolResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttestationPoolResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttestationPoolResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttestationPoolResponse.Merge(m, src)
}
func (m *AttestationPoolResponse) XXX_Size() int {
	return m.Size()
}
func (m *AttestationPoolResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AttestationPoolResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AttestationPoolResponse proto.InternalMessageInfo

func (m *AttestationPoolResponse) GetAttestations() []*Attestation {
	if m != nil {
		return m.Attestations
	}
	return nil
}

func (m *AttestationPoolResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

func (m *AttestationPoolResponse) GetTotalSize() int32 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

type BeaconConfig struct {
	Config               map[string]string `protobuf:"bytes,1,rep,name=config,proto3" json:"config,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *BeaconConfig) Reset()         { *m = BeaconConfig{} }
func (m *BeaconConfig) String() string { return proto.CompactTextString(m) }
func (*BeaconConfig) ProtoMessage()    {}
func (*BeaconConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{27}
}
func (m *BeaconConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BeaconConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BeaconConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BeaconConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BeaconConfig.Merge(m, src)
}
func (m *BeaconConfig) XXX_Size() int {
	return m.Size()
}
func (m *BeaconConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_BeaconConfig.DiscardUnknown(m)
}

var xxx_messageInfo_BeaconConfig proto.InternalMessageInfo

func (m *BeaconConfig) GetConfig() map[string]string {
	if m != nil {
		return m.Config
	}
	return nil
}

type SubmitSlashingResponse struct {
	SlashedIndices       []uint64 `protobuf:"varint,1,rep,packed,name=slashed_indices,json=slashedIndices,proto3" json:"slashed_indices,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubmitSlashingResponse) Reset()         { *m = SubmitSlashingResponse{} }
func (m *SubmitSlashingResponse) String() string { return proto.CompactTextString(m) }
func (*SubmitSlashingResponse) ProtoMessage()    {}
func (*SubmitSlashingResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_e33ad64d6ced77c1, []int{28}
}
func (m *SubmitSlashingResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubmitSlashingResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubmitSlashingResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubmitSlashingResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubmitSlashingResponse.Merge(m, src)
}
func (m *SubmitSlashingResponse) XXX_Size() int {
	return m.Size()
}
func (m *SubmitSlashingResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SubmitSlashingResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SubmitSlashingResponse proto.InternalMessageInfo

func (m *SubmitSlashingResponse) GetSlashedIndices() []uint64 {
	if m != nil {
		return m.SlashedIndices
	}
	return nil
}

func init() {
	proto.RegisterEnum("ethereum.eth.v1alpha1.SetAction", SetAction_name, SetAction_value)
	proto.RegisterType((*ValidatorChangeSet)(nil), "ethereum.eth.v1alpha1.ValidatorChangeSet")
	proto.RegisterType((*ListIndexedAttestationsRequest)(nil), "ethereum.eth.v1alpha1.ListIndexedAttestationsRequest")
	proto.RegisterType((*ListAttestationsRequest)(nil), "ethereum.eth.v1alpha1.ListAttestationsRequest")
	proto.RegisterType((*ListAttestationsResponse)(nil), "ethereum.eth.v1alpha1.ListAttestationsResponse")
	proto.RegisterType((*ListIndexedAttestationsResponse)(nil), "ethereum.eth.v1alpha1.ListIndexedAttestationsResponse")
	proto.RegisterType((*ListBlocksRequest)(nil), "ethereum.eth.v1alpha1.ListBlocksRequest")
	proto.RegisterType((*ListBlocksResponse)(nil), "ethereum.eth.v1alpha1.ListBlocksResponse")
	proto.RegisterType((*BeaconBlockContainer)(nil), "ethereum.eth.v1alpha1.BeaconBlockContainer")
	proto.RegisterType((*ChainHead)(nil), "ethereum.eth.v1alpha1.ChainHead")
	proto.RegisterType((*ListCommitteesRequest)(nil), "ethereum.eth.v1alpha1.ListCommitteesRequest")
	proto.RegisterType((*BeaconCommittees)(nil), "ethereum.eth.v1alpha1.BeaconCommittees")
	proto.RegisterMapType((map[uint64]*BeaconCommittees_CommitteesList)(nil), "ethereum.eth.v1alpha1.BeaconCommittees.CommitteesEntry")
	proto.RegisterType((*BeaconCommittees_CommitteeItem)(nil), "ethereum.eth.v1alpha1.BeaconCommittees.CommitteeItem")
	proto.RegisterType((*BeaconCommittees_CommitteesList)(nil), "ethereum.eth.v1alpha1.BeaconCommittees.CommitteesList")
	proto.RegisterType((*ListValidatorBalancesRequest)(nil), "ethereum.eth.v1alpha1.ListValidatorBalancesRequest")
	proto.RegisterType((*ValidatorBalances)(nil), "ethereum.eth.v1alpha1.ValidatorBalances")
	proto.RegisterType((*ValidatorBalances_Balance)(nil), "ethereum.eth.v1alpha1.ValidatorBalances.Balance")
	proto.RegisterType((*ListValidatorsRequest)(nil), "ethereum.eth.v1alpha1.ListValidatorsRequest")
	proto.RegisterType((*GetValidatorRequest)(nil), "ethereum.eth.v1alpha1.GetValidatorRequest")
	proto.RegisterType((*Validators)(nil), "ethereum.eth.v1alpha1.Validators")
	proto.RegisterType((*Validators_ValidatorContainer)(nil), "ethereum.eth.v1alpha1.Validators.ValidatorContainer")
	proto.RegisterType((*GetValidatorActiveSetChangesRequest)(nil), "ethereum.eth.v1alpha1.GetValidatorActiveSetChangesRequest")
	proto.RegisterType((*ActiveSetChanges)(nil), "ethereum.eth.v1alpha1.ActiveSetChanges")
	proto.RegisterType((*ValidatorPerformanceRequest)(nil), "ethereum.eth.v1alpha1.ValidatorPerformanceRequest")
	proto.RegisterType((*ValidatorPerformanceResponse)(nil), "ethereum.eth.v1alpha1.ValidatorPerformanceResponse")
	proto.RegisterType((*ValidatorQueue)(nil), "ethereum.eth.v1alpha1.ValidatorQueue")
	proto.RegisterType((*ListValidatorAssignmentsRequest)(nil), "ethereum.eth.v1alpha1.ListValidatorAssignmentsRequest")
	proto.RegisterType((*ValidatorAssignments)(nil), "ethereum.eth.v1alpha1.ValidatorAssignments")
	proto.RegisterType((*ValidatorAssignments_CommitteeAssignment)(nil), "ethereum.eth.v1alpha1.ValidatorAssignments.CommitteeAssignment")
	proto.RegisterType((*GetValidatorParticipationRequest)(nil), "ethereum.eth.v1alpha1.GetValidatorParticipationRequest")
	proto.RegisterType((*ValidatorParticipationResponse)(nil), "ethereum.eth.v1alpha1.ValidatorParticipationResponse")
	proto.RegisterType((*AttestationPoolRequest)(nil), "ethereum.eth.v1alpha1.AttestationPoolRequest")
	proto.RegisterType((*AttestationPoolResponse)(nil), "ethereum.eth.v1alpha1.AttestationPoolResponse")
	proto.RegisterType((*BeaconConfig)(nil), "ethereum.eth.v1alpha1.BeaconConfig")
	proto.RegisterMapType((map[string]string)(nil), "ethereum.eth.v1alpha1.BeaconConfig.ConfigEntry")
	proto.RegisterType((*SubmitSlashingResponse)(nil), "ethereum.eth.v1alpha1.SubmitSlashingResponse")
}

func init() { proto.RegisterFile("eth/v1alpha1/beacon_chain.proto", fileDescriptor_e33ad64d6ced77c1) }

var fileDescriptor_e33ad64d6ced77c1 = []byte{
	// 2870 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x5a, 0xcf, 0x6f, 0x1b, 0xc7,
	0xf5, 0xf7, 0x52, 0x94, 0x2c, 0x3e, 0x51, 0xa4, 0x34, 0xa2, 0x64, 0x79, 0x2d, 0x4b, 0xcc, 0x3a,
	0xb6, 0x64, 0x3b, 0x22, 0x15, 0xd9, 0x71, 0x9c, 0x7c, 0x83, 0xe4, 0x2b, 0xd9, 0xaa, 0xec, 0xc6,
	0x45, 0xd4, 0x95, 0xe2, 0xfe, 0x48, 0x00, 0x62, 0x49, 0x0d, 0xc9, 0x8d, 0xc9, 0x5d, 0x7a, 0x77,
	0x28, 0x58, 0x46, 0xdb, 0x43, 0x5b, 0xf4, 0x0f, 0x68, 0x8b, 0x1e, 0x7a, 0x28, 0x5a, 0xb4, 0x87,
	0xa4, 0x41, 0x81, 0x22, 0x87, 0xf6, 0x90, 0x43, 0x6f, 0x45, 0xd1, 0x53, 0x81, 0xa2, 0xb7, 0x22,
	0x28, 0x82, 0x9c, 0x0a, 0xb4, 0x40, 0x83, 0xfe, 0x01, 0xc5, 0xfc, 0xd8, 0xdd, 0xd9, 0x5f, 0x24,
	0x85, 0xa8, 0x40, 0xd0, 0x93, 0xb8, 0x6f, 0xde, 0xbc, 0xf7, 0x99, 0x37, 0x6f, 0xde, 0xbc, 0xf7,
	0x46, 0xb0, 0x82, 0x49, 0xbb, 0x7a, 0xf4, 0xbc, 0xd1, 0xe9, 0xb5, 0x8d, 0xe7, 0xab, 0x75, 0x6c,
	0x34, 0x6c, 0xab, 0xd6, 0x68, 0x1b, 0xa6, 0x55, 0xe9, 0x39, 0x36, 0xb1, 0xd1, 0x3c, 0x26, 0x6d,
	0xec, 0xe0, 0x7e, 0xb7, 0x82, 0x49, 0xbb, 0xe2, 0x71, 0xaa, 0xeb, 0x2d, 0x93, 0xb4, 0xfb, 0xf5,
	0x4a, 0xc3, 0xee, 0x56, 0x5b, 0x76, 0xcb, 0xae, 0x32, 0xee, 0x7a, 0xbf, 0xc9, 0xbe, 0xd8, 0x07,
	0xfb, 0xc5, 0xa5, 0xa8, 0x4b, 0x2d, 0xdb, 0x6e, 0x75, 0x70, 0xd5, 0xe8, 0x99, 0x55, 0xc3, 0xb2,
	0x6c, 0x62, 0x10, 0xd3, 0xb6, 0x5c, 0x31, 0x7a, 0x41, 0x8c, 0xfa, 0x32, 0x70, 0xb7, 0x47, 0x8e,
	0xc5, 0xe0, 0xf9, 0xe8, 0xa0, 0x61, 0x79, 0x43, 0xcb, 0x21, 0xf0, 0x06, 0x21, 0xd8, 0xe5, 0x82,
	0xc5, 0x78, 0xe2, 0xe2, 0xea, 0x1d, 0xbb, 0xf1, 0xc8, 0x83, 0x15, 0x62, 0x38, 0x32, 0x3a, 0xe6,
	0xa1, 0x41, 0x6c, 0x87, 0x8f, 0x6a, 0x36, 0xa0, 0x87, 0x1e, 0xe9, 0x4e, 0xdb, 0xb0, 0x5a, 0x78,
	0x1f, 0x13, 0x74, 0x1b, 0x26, 0x8c, 0x06, 0x55, 0xb2, 0xa8, 0x94, 0x95, 0xb5, 0xc2, 0x66, 0xb9,
	0x92, 0x68, 0xa1, 0xca, 0x3e, 0x26, 0x5b, 0x8c, 0x4f, 0x17, 0xfc, 0x68, 0x05, 0xa6, 0x7a, 0xfd,
	0x7a, 0xc7, 0x6c, 0xd4, 0x1e, 0xe1, 0x63, 0x77, 0x31, 0x53, 0x1e, 0x5b, 0xcb, 0xeb, 0xc0, 0x49,
	0xaf, 0xe3, 0x63, 0x57, 0x7b, 0x5f, 0x81, 0xe5, 0x07, 0xa6, 0x4b, 0xee, 0x5b, 0x87, 0xf8, 0x09,
	0x3e, 0xdc, 0x0a, 0x16, 0xe4, 0xea, 0xf8, 0x71, 0x1f, 0xbb, 0x04, 0x2d, 0xc0, 0x38, 0xee, 0xd9,
	0x8d, 0x36, 0x53, 0x9e, 0xbd, 0x77, 0x46, 0xe7, 0x9f, 0xe8, 0x32, 0x4c, 0xb7, 0xb0, 0x85, 0x5d,
	0xd3, 0xad, 0xf1, 0xf1, 0x4c, 0x59, 0x59, 0x9b, 0xbc, 0x77, 0x46, 0xcf, 0x0b, 0xf2, 0x0e, 0x63,
	0xbb, 0x00, 0xb9, 0x9e, 0xd1, 0xc2, 0x35, 0xd7, 0x7c, 0x8a, 0x17, 0xc7, 0xca, 0xca, 0xda, 0xb8,
	0x3e, 0x49, 0x09, 0xfb, 0xe6, 0x53, 0x8c, 0x2e, 0x02, 0xb0, 0x41, 0x62, 0x3f, 0xc2, 0xd6, 0x62,
	0xb6, 0xac, 0xac, 0xe5, 0x74, 0xc6, 0x7e, 0x40, 0x09, 0xdb, 0x05, 0xc8, 0x3f, 0xee, 0x63, 0xe7,
	0xb8, 0xd6, 0x34, 0x3b, 0x04, 0x3b, 0xda, 0x2f, 0x14, 0x38, 0x47, 0xd1, 0x7e, 0xce, 0x61, 0xbe,
	0xa7, 0xc0, 0x62, 0x1c, 0xa6, 0xdb, 0xb3, 0x2d, 0x17, 0xa3, 0x2f, 0x40, 0x5e, 0x72, 0x1b, 0x77,
	0x51, 0x29, 0x8f, 0xad, 0x4d, 0x6d, 0x6a, 0x29, 0x5b, 0x2a, 0x89, 0xd0, 0x43, 0xf3, 0xd0, 0x15,
	0x28, 0x5a, 0xf8, 0x09, 0xa9, 0x49, 0xc0, 0x32, 0x0c, 0xd8, 0x34, 0x25, 0xef, 0x79, 0xe0, 0x28,
	0x76, 0x62, 0x13, 0xa3, 0x23, 0xaf, 0x2c, 0xc7, 0x28, 0x74, 0x69, 0xda, 0xef, 0x15, 0x58, 0x49,
	0x75, 0x00, 0x01, 0xf9, 0x6d, 0x28, 0x99, 0x7c, 0xb8, 0x96, 0x00, 0xfd, 0x6a, 0x0a, 0xf4, 0xb8,
	0x44, 0x7d, 0xce, 0x8c, 0x6b, 0x39, 0xad, 0x85, 0xfc, 0x4e, 0x81, 0x59, 0xba, 0x90, 0x6d, 0x7a,
	0xd8, 0x7c, 0xaf, 0x28, 0x41, 0xd6, 0xb1, 0x6d, 0xc2, 0x9c, 0x22, 0x7f, 0xef, 0x8c, 0xce, 0xbe,
	0x28, 0xd5, 0xed, 0xd8, 0x84, 0xe9, 0xa1, 0xae, 0xc2, 0xbe, 0x02, 0x0f, 0x1a, 0x0b, 0x7b, 0x90,
	0x0a, 0x67, 0x85, 0xab, 0xb0, 0xad, 0xa7, 0xbe, 0xe3, 0x11, 0xc2, 0x6e, 0x33, 0x3e, 0xd0, 0x6d,
	0x26, 0x86, 0xb9, 0xcd, 0x07, 0x0a, 0x20, 0x79, 0x05, 0xc2, 0xfa, 0x6f, 0x42, 0x91, 0x05, 0x90,
	0x3b, 0xb6, 0x45, 0x0c, 0xd3, 0xc2, 0x8e, 0x67, 0xf8, 0xeb, 0x29, 0x86, 0xdf, 0x66, 0x51, 0x67,
	0x3b, 0x34, 0x47, 0x8f, 0xca, 0x38, 0x2d, 0xb3, 0xf7, 0xa1, 0x94, 0xa4, 0x0f, 0xbd, 0x0a, 0xe3,
	0x4c, 0x23, 0xb3, 0xfc, 0xd4, 0xe6, 0x5a, 0x5a, 0xc8, 0x32, 0x5b, 0x16, 0x3e, 0x94, 0x24, 0xe8,
	0x7c, 0x1a, 0x55, 0xcb, 0x7e, 0xd4, 0xd8, 0xf6, 0x51, 0x64, 0x79, 0x3d, 0xc7, 0x28, 0xba, 0x6d,
	0x13, 0xed, 0xdf, 0x59, 0xc8, 0xdd, 0xa1, 0x77, 0xc6, 0x3d, 0x6c, 0x1c, 0xd2, 0x5d, 0x68, 0x63,
	0xe3, 0xb0, 0xc6, 0x36, 0x95, 0x9d, 0x7f, 0x7d, 0x92, 0x12, 0xf6, 0xe9, 0xb6, 0x5e, 0x04, 0x60,
	0x83, 0xc1, 0xe9, 0xcf, 0xea, 0x8c, 0x9d, 0x1f, 0xfc, 0x97, 0xa0, 0xc8, 0x86, 0x25, 0x6d, 0x74,
	0x91, 0xf9, 0xed, 0xd9, 0x4f, 0x3f, 0x5a, 0x99, 0x76, 0xdd, 0xa7, 0xeb, 0x74, 0xe1, 0x2f, 0x6b,
	0x37, 0x36, 0x35, 0x7d, 0x9a, 0x72, 0x6e, 0x7b, 0x20, 0xd0, 0x65, 0x28, 0x34, 0x4d, 0xcb, 0xe8,
	0x98, 0x4f, 0xb1, 0xd0, 0x9d, 0x65, 0xd2, 0xa7, 0x7d, 0x2a, 0x03, 0xb0, 0x0a, 0xc5, 0x80, 0x8d,
	0xa3, 0x18, 0x67, 0x7c, 0xc1, 0x6c, 0x0e, 0xe5, 0x0e, 0x94, 0x02, 0x46, 0x09, 0xcf, 0x44, 0x1a,
	0x1e, 0xe4, 0xb3, 0x87, 0x40, 0xbd, 0xd3, 0x77, 0x89, 0xd9, 0x34, 0x3d, 0x50, 0x67, 0x39, 0x28,
	0x9f, 0xea, 0x81, 0x0a, 0xd8, 0x38, 0xa8, 0x49, 0x0e, 0xca, 0x27, 0xfb, 0xa0, 0x02, 0x46, 0x09,
	0x54, 0x2e, 0x15, 0x94, 0xcf, 0x1e, 0x80, 0xba, 0x05, 0xe7, 0x7a, 0x0e, 0x3e, 0x32, 0xed, 0xbe,
	0x5b, 0x8b, 0xa0, 0x03, 0xa6, 0x75, 0xde, 0x1b, 0xfe, 0x62, 0x08, 0xe5, 0x6d, 0x58, 0x4c, 0x98,
	0xc7, 0xe1, 0x4e, 0xb1, 0x89, 0x0b, 0xb1, 0x89, 0x1c, 0xf6, 0x01, 0x5c, 0x4c, 0x98, 0x29, 0xe1,
	0xcf, 0xa7, 0xe1, 0x57, 0x63, 0x12, 0xfd, 0x75, 0x68, 0x6f, 0xc1, 0x3c, 0x3d, 0xa1, 0x77, 0xec,
	0x6e, 0xd7, 0x24, 0x04, 0xe3, 0xa1, 0xb7, 0x8f, 0x14, 0x3b, 0x32, 0x91, 0xd8, 0x11, 0x3b, 0xff,
	0x7f, 0x19, 0x83, 0x19, 0x7e, 0x12, 0x02, 0xf9, 0xa8, 0x14, 0x12, 0xec, 0x89, 0xfd, 0x0a, 0x40,
	0xc3, 0xe7, 0x61, 0xd7, 0xfa, 0xd4, 0xe6, 0x8b, 0x03, 0xc3, 0x41, 0x20, 0xb2, 0x12, 0xfc, 0xdc,
	0xb1, 0x88, 0x73, 0xac, 0x4b, 0xa2, 0xd0, 0x4d, 0x58, 0xa0, 0xa9, 0xc3, 0x11, 0xae, 0xf9, 0xa9,
	0x49, 0xad, 0x61, 0xf7, 0x2d, 0x7e, 0x28, 0xb2, 0x7a, 0x89, 0x8f, 0x06, 0x49, 0x0a, 0x1d, 0x53,
	0x5f, 0x81, 0x69, 0x5f, 0xe8, 0x7d, 0x82, 0xbb, 0xe8, 0x3a, 0xcc, 0x06, 0xf3, 0x4d, 0xeb, 0xd0,
	0x6c, 0x60, 0x1e, 0xb5, 0xb2, 0xfa, 0x8c, 0x3f, 0x70, 0x9f, 0xd3, 0xd5, 0x16, 0x14, 0x02, 0x48,
	0xd4, 0xbc, 0xe8, 0xcd, 0xd0, 0xf2, 0x78, 0xb4, 0x7b, 0xe1, 0xc4, 0xcb, 0xa3, 0x48, 0xe4, 0xc5,
	0xa9, 0x7d, 0x28, 0x46, 0xd6, 0x8e, 0x66, 0x60, 0xec, 0x11, 0x3e, 0x16, 0xc6, 0xa5, 0x3f, 0xd1,
	0x03, 0x18, 0x3f, 0x32, 0x3a, 0x7d, 0xcc, 0xf6, 0x6b, 0x6a, 0xf3, 0xd6, 0xc9, 0xad, 0x4a, 0x97,
	0xa0, 0x73, 0x21, 0x2f, 0x67, 0x6e, 0x2b, 0xda, 0x3f, 0x15, 0x58, 0xa2, 0x34, 0xdf, 0x68, 0xdb,
	0x46, 0xc7, 0xb0, 0x1a, 0x9f, 0xc9, 0x79, 0xd0, 0xcd, 0x70, 0x66, 0x37, 0x46, 0x33, 0xbb, 0xed,
	0xb9, 0x4f, 0x3f, 0x5a, 0x29, 0x06, 0xde, 0xfc, 0xda, 0x73, 0x37, 0x6f, 0x6b, 0x72, 0xba, 0x87,
	0x16, 0xe1, 0xac, 0xb7, 0x1b, 0x59, 0xb6, 0x1b, 0xde, 0xe7, 0xa9, 0x5e, 0x64, 0xef, 0x67, 0x60,
	0x36, 0xb6, 0xd8, 0x14, 0x4f, 0x7e, 0x00, 0x93, 0x75, 0xc1, 0x21, 0xfc, 0x78, 0x23, 0xc5, 0xe2,
	0x31, 0x89, 0x15, 0xf1, 0x43, 0xf7, 0x25, 0x24, 0x5d, 0x6a, 0x63, 0xc3, 0x2f, 0xb5, 0x6c, 0xe4,
	0x52, 0x53, 0x1f, 0xc1, 0x59, 0x21, 0x1b, 0x6d, 0x00, 0x04, 0x76, 0xe6, 0x69, 0x44, 0x34, 0x68,
	0x50, 0x23, 0xe7, 0x7c, 0x23, 0xd3, 0x75, 0xb2, 0x34, 0x47, 0x5c, 0x35, 0xfc, 0x83, 0x5a, 0x5e,
	0xa0, 0x14, 0x27, 0xc9, 0xfb, 0xd4, 0xfe, 0xae, 0xf0, 0xa0, 0xe2, 0xaf, 0xef, 0x33, 0xf9, 0xc5,
	0x02, 0xaf, 0x15, 0x8e, 0xb8, 0x9a, 0x49, 0x5d, 0x7c, 0x85, 0xf7, 0x37, 0x3b, 0x70, 0x7f, 0xc7,
	0x23, 0xfb, 0x1b, 0xad, 0x22, 0x26, 0xa2, 0x55, 0x84, 0xec, 0x56, 0x67, 0x43, 0x6e, 0x15, 0x73,
	0x8d, 0xc7, 0x30, 0xb7, 0x8b, 0x83, 0xa5, 0x4a, 0x2b, 0xe5, 0x36, 0xf3, 0x57, 0xca, 0xad, 0xb6,
	0x19, 0xb2, 0x7e, 0x26, 0xc5, 0xfa, 0xf7, 0xce, 0x48, 0xf6, 0x8f, 0xa7, 0x55, 0x19, 0x80, 0xc0,
	0xb6, 0x29, 0x6e, 0xf8, 0x16, 0x14, 0x82, 0x80, 0xd5, 0x31, 0x5d, 0x22, 0x9c, 0xf1, 0xe6, 0x30,
	0x67, 0x74, 0x2b, 0x52, 0x2c, 0xf4, 0x92, 0xad, 0x69, 0x5f, 0x16, 0x0b, 0x67, 0xa7, 0xe4, 0x95,
	0xef, 0xc8, 0xc5, 0xa1, 0x9f, 0x68, 0x95, 0x42, 0xa6, 0xf3, 0x0c, 0xf7, 0x2a, 0xe4, 0x7c, 0x0c,
	0x22, 0x92, 0x95, 0x87, 0x2d, 0x45, 0x0f, 0xa6, 0x68, 0x26, 0x5c, 0x92, 0xf7, 0x69, 0x8b, 0x39,
	0xd1, 0x3e, 0x26, 0xbc, 0x28, 0x3d, 0xd5, 0x6b, 0xef, 0x93, 0x31, 0x98, 0x89, 0xca, 0x4f, 0xd9,
	0xa5, 0x5d, 0x98, 0x67, 0xee, 0x6c, 0x10, 0x7c, 0x58, 0x8b, 0x15, 0xb6, 0xc9, 0xe1, 0x6f, 0xce,
	0x9f, 0xb1, 0x17, 0x38, 0xec, 0x75, 0x98, 0x0d, 0x04, 0x79, 0xae, 0x3b, 0xc6, 0xef, 0x27, 0x7f,
	0x40, 0xdc, 0x4f, 0x68, 0x0b, 0x10, 0x7e, 0x62, 0x46, 0x55, 0x66, 0xd3, 0x55, 0xce, 0x70, 0x76,
	0x49, 0xdf, 0x65, 0x28, 0x08, 0x11, 0x9e, 0xb2, 0x71, 0xa6, 0x6c, 0x9a, 0x53, 0x3d, 0x4d, 0x77,
	0x60, 0xce, 0xed, 0x18, 0x6e, 0x3b, 0xa2, 0x6a, 0x22, 0x5d, 0xd5, 0xac, 0xe0, 0x97, 0x74, 0xad,
	0x42, 0xd1, 0x13, 0x12, 0x3e, 0x94, 0x05, 0x41, 0x96, 0xb4, 0xe1, 0x77, 0x70, 0x23, 0xba, 0xb0,
	0xc9, 0x01, 0xda, 0x04, 0x7f, 0x58, 0x9b, 0x27, 0xc4, 0xd3, 0x96, 0xe3, 0xda, 0x04, 0x59, 0x68,
	0xd3, 0xbe, 0x0a, 0x17, 0x7c, 0x77, 0xda, 0xc3, 0x4e, 0xd3, 0x76, 0xba, 0x2c, 0x78, 0x0b, 0x4f,
	0x8a, 0xc4, 0x18, 0x65, 0x50, 0x8c, 0xc9, 0x84, 0x62, 0x8c, 0xf6, 0xd7, 0x2c, 0x2c, 0x25, 0x8b,
	0x16, 0x15, 0xd4, 0x2b, 0xa0, 0x36, 0xfa, 0x8e, 0x83, 0x2d, 0x52, 0xc3, 0xcd, 0x26, 0xe6, 0xf9,
	0x8d, 0x7f, 0xeb, 0xf0, 0xb4, 0x64, 0x51, 0x70, 0xec, 0x78, 0x0c, 0xfe, 0xbd, 0xb5, 0x0a, 0x45,
	0xd3, 0x6a, 0x74, 0xfa, 0xae, 0x69, 0x5b, 0x2c, 0x65, 0xf5, 0x00, 0x14, 0x7c, 0x32, 0xcd, 0x55,
	0x5d, 0x54, 0x85, 0xb9, 0x80, 0xf1, 0xd0, 0x74, 0x09, 0x97, 0xcf, 0xdd, 0x0a, 0xf9, 0x43, 0x77,
	0xbd, 0x11, 0x9a, 0x6c, 0x35, 0x6c, 0xc7, 0xc1, 0x0d, 0xd2, 0x39, 0xae, 0x1d, 0xd9, 0xd4, 0x86,
	0xae, 0xdd, 0x77, 0x1a, 0x98, 0x39, 0xd7, 0xa4, 0x5e, 0xf2, 0x47, 0x1f, 0xd2, 0xc1, 0x7d, 0x36,
	0x96, 0x34, 0x8b, 0x18, 0x4e, 0x0b, 0x13, 0xe6, 0x53, 0xb1, 0x59, 0x07, 0x6c, 0x0c, 0x6d, 0x40,
	0x29, 0x3a, 0x8b, 0x16, 0x33, 0xcc, 0xb7, 0x26, 0x75, 0x14, 0x9e, 0xc3, 0x8a, 0xaa, 0x5d, 0x28,
	0x7b, 0x36, 0xaa, 0xd5, 0x71, 0xd3, 0x76, 0x30, 0x4f, 0xbc, 0x6b, 0xc4, 0x31, 0x2c, 0xd7, 0x64,
	0xfd, 0x28, 0xee, 0x58, 0x17, 0x3d, 0xbe, 0x6d, 0xc6, 0xc6, 0x12, 0xf0, 0x03, 0x9f, 0x09, 0xed,
	0xc0, 0x8a, 0x2f, 0xc8, 0x68, 0x12, 0xec, 0xc4, 0xe5, 0x4c, 0x32, 0x39, 0x4b, 0x1e, 0xdb, 0x16,
	0xe5, 0x8a, 0x8a, 0x59, 0x07, 0xd4, 0x35, 0x5d, 0xd7, 0xb4, 0x5a, 0x41, 0x6e, 0xca, 0x9d, 0x2d,
	0xaf, 0xcf, 0x8a, 0x11, 0x29, 0xce, 0xef, 0x42, 0xd9, 0x38, 0xc2, 0x0e, 0x0d, 0xb9, 0xb1, 0x8c,
	0xd6, 0xbb, 0x89, 0x69, 0xed, 0x91, 0xd1, 0x2f, 0x0a, 0xbe, 0xad, 0x70, 0x6a, 0x2b, 0x1c, 0x40,
	0xfb, 0x6d, 0x06, 0x0a, 0x3e, 0xf1, 0xcb, 0x7d, 0xdc, 0xc7, 0xd4, 0x59, 0x1b, 0xed, 0xbe, 0x63,
	0xd5, 0x3a, 0x66, 0xd7, 0xf4, 0x2a, 0x4e, 0x60, 0xa4, 0x07, 0x94, 0x82, 0x5e, 0x17, 0x69, 0x34,
	0x6b, 0x71, 0x24, 0x44, 0xaa, 0xf9, 0x84, 0xd3, 0xb5, 0xa8, 0x88, 0xec, 0x9a, 0x4d, 0x92, 0x8e,
	0xd8, 0x6b, 0xc0, 0x02, 0x4a, 0x2d, 0x9e, 0xef, 0xa5, 0x88, 0x61, 0xb1, 0x46, 0x12, 0xf0, 0xff,
	0xb0, 0x24, 0xa1, 0x89, 0x27, 0xe6, 0x3c, 0x15, 0x54, 0x03, 0x9e, 0x87, 0x91, 0x14, 0x9d, 0xfa,
	0x1c, 0x83, 0x10, 0x9f, 0xcb, 0xe3, 0x58, 0x89, 0x8e, 0x46, 0x67, 0x69, 0xff, 0x12, 0xbd, 0xa5,
	0xe0, 0x1a, 0x71, 0x5d, 0xb3, 0x65, 0x75, 0xb1, 0x45, 0xfe, 0x67, 0x73, 0xdf, 0x7f, 0x8c, 0x41,
	0x29, 0x69, 0xbd, 0x29, 0x37, 0x9a, 0x01, 0x53, 0x46, 0xc0, 0x24, 0x92, 0x8e, 0xd7, 0x86, 0xdd,
	0xd4, 0x92, 0xdc, 0xa0, 0xee, 0x08, 0x88, 0xba, 0x2c, 0xf3, 0xb4, 0xb2, 0x8f, 0x1f, 0x66, 0x60,
	0x2e, 0x41, 0x17, 0xbd, 0x4a, 0xbd, 0x1e, 0x7e, 0xb8, 0x64, 0xcb, 0xea, 0x33, 0xf5, 0x68, 0x35,
	0xbb, 0x0a, 0x45, 0x9f, 0xab, 0x26, 0x67, 0xc9, 0x05, 0x9f, 0xcc, 0xda, 0x86, 0xe8, 0x12, 0x4c,
	0xf3, 0x56, 0x23, 0x76, 0x78, 0x9b, 0x80, 0x27, 0xcd, 0x79, 0x8f, 0xc8, 0xba, 0x03, 0x97, 0xa1,
	0xd0, 0x73, 0xec, 0x9e, 0xed, 0x0a, 0x26, 0x6f, 0x63, 0xa7, 0x3d, 0x2a, 0x8f, 0xcb, 0xe1, 0x24,
	0x72, 0x9c, 0x25, 0x91, 0x73, 0xb1, 0x24, 0x72, 0x51, 0x91, 0x93, 0xf8, 0x55, 0x28, 0x86, 0x7c,
	0x1d, 0x3f, 0x61, 0x5b, 0x9f, 0xd5, 0x0b, 0x72, 0xf9, 0x8a, 0x9f, 0x68, 0x4d, 0x28, 0xcb, 0x89,
	0xd2, 0x9e, 0xe1, 0x10, 0xb3, 0x61, 0xf6, 0x78, 0xbf, 0xf3, 0x14, 0xb3, 0xa4, 0xf7, 0x14, 0x58,
	0x4e, 0xd3, 0x22, 0xae, 0xb9, 0x64, 0x0f, 0x5b, 0x82, 0x9c, 0xdf, 0x25, 0xe2, 0x6a, 0xf4, 0x80,
	0x80, 0xf6, 0x61, 0xba, 0x27, 0x0b, 0x63, 0x76, 0x9e, 0xda, 0x5c, 0x1f, 0xe6, 0x81, 0x61, 0x04,
	0x61, 0x19, 0xda, 0x01, 0x2c, 0x48, 0x1d, 0xde, 0x3d, 0xdb, 0xee, 0x78, 0x96, 0x08, 0x9d, 0x34,
	0x65, 0xe0, 0x49, 0xcb, 0x44, 0x4e, 0x9a, 0xf6, 0xae, 0x02, 0xe7, 0x62, 0x62, 0x3f, 0x9f, 0x4d,
	0xf5, 0xef, 0x2b, 0x90, 0xf7, 0x1a, 0x04, 0x56, 0xd3, 0x6c, 0xa1, 0x5d, 0x98, 0x68, 0xb0, 0x5f,
	0x02, 0x59, 0x75, 0x48, 0x57, 0x81, 0xb2, 0x56, 0xf8, 0x1f, 0xde, 0xa3, 0x11, 0xd3, 0xd5, 0x97,
	0x60, 0x4a, 0x22, 0xcb, 0xed, 0x8b, 0x1c, 0x6f, 0x5f, 0x94, 0xe4, 0xf6, 0x45, 0x4e, 0x6e, 0x43,
	0x6c, 0xc1, 0xc2, 0x7e, 0xbf, 0xde, 0x35, 0xc9, 0x3e, 0x4d, 0x03, 0x4d, 0xab, 0xe5, 0x5b, 0x2f,
	0x21, 0x63, 0x54, 0x92, 0x32, 0xc6, 0x6b, 0x0f, 0x21, 0xe7, 0xbf, 0x31, 0xa1, 0x05, 0x40, 0x5b,
	0x77, 0xef, 0xd6, 0x1e, 0x6e, 0x3d, 0xb8, 0x7f, 0x77, 0xeb, 0xe0, 0x0d, 0xbd, 0xf6, 0xfa, 0xce,
	0xd7, 0xf6, 0x67, 0xce, 0xa0, 0xf3, 0x30, 0xaf, 0xef, 0x7c, 0xe9, 0x8d, 0x87, 0x3b, 0xd1, 0x21,
	0x85, 0x4e, 0xd9, 0xdf, 0x39, 0x88, 0xd2, 0x33, 0x9b, 0x1f, 0xa8, 0x30, 0x25, 0x96, 0xde, 0x36,
	0x4c, 0x0b, 0xfd, 0x44, 0x81, 0x99, 0xe8, 0x03, 0x0a, 0xaa, 0xa4, 0xd8, 0x2c, 0xe5, 0x41, 0x48,
	0xad, 0x8e, 0xcc, 0xcf, 0xcd, 0xa0, 0x5d, 0xfd, 0xf6, 0x9f, 0x3f, 0xf9, 0x41, 0xe6, 0x12, 0x7a,
	0xa6, 0x9a, 0xf0, 0x88, 0x57, 0x0d, 0xf9, 0xc9, 0x87, 0xe2, 0x21, 0x2a, 0xe1, 0xd5, 0x04, 0xbd,
	0x30, 0x40, 0x6f, 0xfa, 0x33, 0x9b, 0x7a, 0xeb, 0xa4, 0xd3, 0x04, 0xea, 0xe7, 0x19, 0xea, 0xeb,
	0xe8, 0xea, 0x50, 0xd4, 0x55, 0xf1, 0xfa, 0x82, 0xbe, 0xab, 0x00, 0xda, 0x27, 0x0e, 0x36, 0xba,
	0x21, 0xe0, 0x0b, 0x15, 0xfe, 0xee, 0x59, 0xf1, 0xde, 0x3d, 0x2b, 0x3b, 0xdd, 0x1e, 0x39, 0x56,
	0x47, 0x38, 0x46, 0xda, 0x06, 0x43, 0x71, 0x0d, 0xad, 0x0d, 0x47, 0xe1, 0x32, 0xcd, 0x1b, 0x0a,
	0xfa, 0xb1, 0x02, 0xe7, 0x39, 0x8c, 0x24, 0x33, 0xa6, 0xa1, 0x19, 0xfd, 0xb9, 0x49, 0xbb, 0xcd,
	0x40, 0x6d, 0xa2, 0x8d, 0x91, 0x4d, 0x13, 0x80, 0xfb, 0xa9, 0x02, 0xc5, 0x48, 0xb4, 0x41, 0xeb,
	0xc3, 0x0d, 0x21, 0x05, 0x3b, 0xb5, 0x32, 0x2a, 0xbb, 0xd8, 0xc9, 0x0a, 0x83, 0xbb, 0x86, 0xae,
	0x0c, 0x87, 0xdb, 0xa3, 0x70, 0xbe, 0xa7, 0x00, 0x04, 0xef, 0x45, 0x68, 0x6d, 0x80, 0x03, 0x85,
	0x1e, 0xc5, 0x52, 0x4d, 0x18, 0x7f, 0x7c, 0xd2, 0x2e, 0x31, 0x4c, 0x17, 0xd1, 0x85, 0x44, 0x4c,
	0x75, 0xae, 0xf9, 0x5b, 0x90, 0xe7, 0xfb, 0x28, 0x90, 0xa4, 0x6d, 0xdd, 0xc8, 0x8f, 0x40, 0xda,
	0x35, 0xa6, 0xf6, 0x59, 0xa4, 0x0d, 0x50, 0x1b, 0xec, 0xd5, 0x37, 0xa0, 0xc8, 0xf5, 0x07, 0x2f,
	0x42, 0x69, 0x10, 0xd2, 0x9a, 0x20, 0xfe, 0x4c, 0x6d, 0x9d, 0xa9, 0x5e, 0x45, 0x97, 0x13, 0x55,
	0xb3, 0xff, 0x53, 0xa0, 0x85, 0x53, 0xa0, 0xbd, 0x07, 0xf9, 0x5d, 0xd6, 0xb8, 0xf8, 0xcc, 0xaa,
	0xaf, 0x30, 0xd5, 0x65, 0xb4, 0x3c, 0x58, 0x35, 0xfa, 0x91, 0x02, 0x25, 0xb6, 0x57, 0xd1, 0xf4,
	0xea, 0xb9, 0x01, 0x1b, 0x1b, 0x7b, 0xb3, 0x50, 0x57, 0x47, 0x6c, 0x6d, 0x6b, 0xab, 0x0c, 0xd7,
	0x33, 0x68, 0x25, 0x19, 0x57, 0xa0, 0xff, 0x67, 0xd1, 0x56, 0xa6, 0x5f, 0x44, 0xdf, 0x18, 0x80,
	0x2c, 0xad, 0x2f, 0x9e, 0xea, 0x2f, 0xb1, 0x09, 0x69, 0xa1, 0x3b, 0xa8, 0x13, 0xab, 0x7e, 0x8b,
	0xf8, 0x3b, 0x0a, 0x14, 0xc2, 0xed, 0xd6, 0x81, 0x66, 0x8b, 0x75, 0x65, 0xd5, 0x67, 0x86, 0xb6,
	0x04, 0xb5, 0x32, 0x83, 0xa3, 0xa2, 0xc5, 0x34, 0x38, 0xe8, 0x9b, 0xcc, 0x69, 0xfc, 0x29, 0xe8,
	0x5a, 0x8a, 0xd0, 0x84, 0x66, 0xa9, 0x3a, 0xb4, 0x91, 0xa7, 0xad, 0x30, 0xfd, 0xe7, 0xd1, 0xb9,
	0x14, 0xfd, 0xe8, 0x37, 0x0a, 0x2c, 0x0d, 0xea, 0xef, 0xa1, 0x97, 0x47, 0xc0, 0x93, 0xd2, 0x14,
	0x4c, 0xf5, 0xab, 0x28, 0x7f, 0xda, 0xd5, 0x25, 0xed, 0x1a, 0xaf, 0xdc, 0x5d, 0x4c, 0x1a, 0x02,
	0xd7, 0x53, 0x98, 0x95, 0x21, 0xf0, 0x72, 0x3c, 0xed, 0xc4, 0x5d, 0x1e, 0x66, 0x28, 0x36, 0x3d,
	0xed, 0xd8, 0x49, 0x30, 0x1e, 0x33, 0x35, 0xbf, 0x56, 0xe0, 0x5c, 0x28, 0xd7, 0x0f, 0x5a, 0x4d,
	0x68, 0x73, 0x68, 0xc2, 0x1c, 0x6b, 0x79, 0xa9, 0x37, 0x4e, 0x34, 0x47, 0x04, 0xe4, 0xe7, 0x18,
	0xd8, 0x2b, 0xe8, 0xd9, 0x54, 0xb0, 0x3d, 0x09, 0xd6, 0xaf, 0xc4, 0x7f, 0xa2, 0x24, 0x56, 0xa4,
	0xb7, 0x46, 0x71, 0xfb, 0x78, 0xc9, 0xae, 0x5e, 0x3f, 0x41, 0x79, 0x3a, 0x02, 0x5e, 0xb9, 0x56,
	0xfd, 0x50, 0x81, 0xf3, 0xa9, 0xe5, 0x14, 0x7a, 0x71, 0x04, 0xa7, 0x4c, 0x2a, 0xc0, 0xd4, 0x17,
	0x4e, 0x56, 0xce, 0x0c, 0xb9, 0x90, 0x65, 0x5b, 0x87, 0xf0, 0xb9, 0x50, 0xdc, 0xc5, 0x24, 0x94,
	0xf8, 0xa7, 0xb9, 0xe6, 0xa5, 0x11, 0x0a, 0x80, 0x21, 0x97, 0x2f, 0xaf, 0x08, 0x68, 0xa2, 0x52,
	0xe2, 0xb7, 0x5f, 0x10, 0x80, 0xee, 0x5b, 0x4d, 0x1b, 0x5d, 0x1d, 0xb6, 0x68, 0xff, 0x1f, 0xcc,
	0xd4, 0x67, 0x87, 0xb1, 0x52, 0x81, 0xda, 0x0d, 0x06, 0x67, 0x1d, 0x5d, 0x4f, 0x84, 0x23, 0x59,
	0xc5, 0xb4, 0x9a, 0xb6, 0xb8, 0x1f, 0xd7, 0x94, 0x0d, 0x05, 0xbd, 0xab, 0x78, 0xa5, 0xc7, 0x96,
	0x5f, 0xbe, 0xf3, 0x12, 0x04, 0xad, 0x0e, 0xcc, 0x91, 0x02, 0x46, 0x35, 0x2d, 0xf7, 0x4a, 0x2e,
	0x69, 0xb4, 0x5b, 0x0c, 0xeb, 0x06, 0xaa, 0x24, 0x62, 0x75, 0x05, 0xbb, 0x5b, 0xf5, 0xfa, 0x09,
	0x55, 0x97, 0xc9, 0x91, 0xa0, 0xee, 0xf9, 0x3d, 0x84, 0x21, 0x50, 0xa3, 0x8c, 0xff, 0x2d, 0xa8,
	0x5e, 0x53, 0x43, 0x40, 0xdd, 0xfe, 0xb9, 0xf2, 0x87, 0x8f, 0x97, 0x95, 0x3f, 0x7d, 0xbc, 0xac,
	0xfc, 0xed, 0xe3, 0x65, 0x05, 0xce, 0xdb, 0x4e, 0x2b, 0x59, 0xf1, 0xf6, 0x8c, 0x54, 0x5b, 0xed,
	0x51, 0x3f, 0xdc, 0x53, 0xbe, 0x7e, 0x4b, 0xfa, 0x6f, 0xca, 0x9e, 0x73, 0xec, 0x76, 0x0d, 0x62,
	0x36, 0x3a, 0x46, 0xdd, 0xad, 0x7a, 0x32, 0x8c, 0x9e, 0xe9, 0x86, 0x20, 0xfd, 0x1f, 0x26, 0xed,
	0x5f, 0x66, 0xe6, 0x77, 0x3c, 0x1d, 0x3b, 0x92, 0x8e, 0x3f, 0x06, 0xf4, 0xb7, 0x77, 0x48, 0xfb,
	0x6d, 0x8f, 0x5e, 0x9f, 0x60, 0x8e, 0x7f, 0xe3, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x26, 0x1c,
	0x61, 0x56, 0xf6, 0x29, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BeaconChainClient is the client API for BeaconChain service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BeaconChainClient interface {
	ListAttestations(ctx context.Context, in *ListAttestationsRequest, opts ...grpc.CallOption) (*ListAttestationsResponse, error)
	ListIndexedAttestations(ctx context.Context, in *ListIndexedAttestationsRequest, opts ...grpc.CallOption) (*ListIndexedAttestationsResponse, error)
	StreamAttestations(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (BeaconChain_StreamAttestationsClient, error)
	StreamIndexedAttestations(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (BeaconChain_StreamIndexedAttestationsClient, error)
	AttestationPool(ctx context.Context, in *AttestationPoolRequest, opts ...grpc.CallOption) (*AttestationPoolResponse, error)
	ListBlocks(ctx context.Context, in *ListBlocksRequest, opts ...grpc.CallOption) (*ListBlocksResponse, error)
	StreamBlocks(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (BeaconChain_StreamBlocksClient, error)
	StreamChainHead(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (BeaconChain_StreamChainHeadClient, error)
	GetChainHead(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*ChainHead, error)
	ListBeaconCommittees(ctx context.Context, in *ListCommitteesRequest, opts ...grpc.CallOption) (*BeaconCommittees, error)
	ListValidatorBalances(ctx context.Context, in *ListValidatorBalancesRequest, opts ...grpc.CallOption) (*ValidatorBalances, error)
	ListValidators(ctx context.Context, in *ListValidatorsRequest, opts ...grpc.CallOption) (*Validators, error)
	GetValidator(ctx context.Context, in *GetValidatorRequest, opts ...grpc.CallOption) (*Validator, error)
	GetValidatorActiveSetChanges(ctx context.Context, in *GetValidatorActiveSetChangesRequest, opts ...grpc.CallOption) (*ActiveSetChanges, error)
	GetValidatorQueue(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*ValidatorQueue, error)
	GetValidatorPerformance(ctx context.Context, in *ValidatorPerformanceRequest, opts ...grpc.CallOption) (*ValidatorPerformanceResponse, error)
	ListValidatorAssignments(ctx context.Context, in *ListValidatorAssignmentsRequest, opts ...grpc.CallOption) (*ValidatorAssignments, error)
	GetValidatorParticipation(ctx context.Context, in *GetValidatorParticipationRequest, opts ...grpc.CallOption) (*ValidatorParticipationResponse, error)
	GetBeaconConfig(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*BeaconConfig, error)
	StreamValidatorsInfo(ctx context.Context, opts ...grpc.CallOption) (BeaconChain_StreamValidatorsInfoClient, error)
	SubmitAttesterSlashing(ctx context.Context, in *AttesterSlashing, opts ...grpc.CallOption) (*SubmitSlashingResponse, error)
	SubmitProposerSlashing(ctx context.Context, in *ProposerSlashing, opts ...grpc.CallOption) (*SubmitSlashingResponse, error)
}

type beaconChainClient struct {
	cc *grpc.ClientConn
}

func NewBeaconChainClient(cc *grpc.ClientConn) BeaconChainClient {
	return &beaconChainClient{cc}
}

func (c *beaconChainClient) ListAttestations(ctx context.Context, in *ListAttestationsRequest, opts ...grpc.CallOption) (*ListAttestationsResponse, error) {
	out := new(ListAttestationsResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/ListAttestations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListIndexedAttestations(ctx context.Context, in *ListIndexedAttestationsRequest, opts ...grpc.CallOption) (*ListIndexedAttestationsResponse, error) {
	out := new(ListIndexedAttestationsResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/ListIndexedAttestations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) StreamAttestations(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (BeaconChain_StreamAttestationsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_BeaconChain_serviceDesc.Streams[0], "/ethereum.eth.v1alpha1.BeaconChain/StreamAttestations", opts...)
	if err != nil {
		return nil, err
	}
	x := &beaconChainStreamAttestationsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BeaconChain_StreamAttestationsClient interface {
	Recv() (*Attestation, error)
	grpc.ClientStream
}

type beaconChainStreamAttestationsClient struct {
	grpc.ClientStream
}

func (x *beaconChainStreamAttestationsClient) Recv() (*Attestation, error) {
	m := new(Attestation)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *beaconChainClient) StreamIndexedAttestations(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (BeaconChain_StreamIndexedAttestationsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_BeaconChain_serviceDesc.Streams[1], "/ethereum.eth.v1alpha1.BeaconChain/StreamIndexedAttestations", opts...)
	if err != nil {
		return nil, err
	}
	x := &beaconChainStreamIndexedAttestationsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BeaconChain_StreamIndexedAttestationsClient interface {
	Recv() (*IndexedAttestation, error)
	grpc.ClientStream
}

type beaconChainStreamIndexedAttestationsClient struct {
	grpc.ClientStream
}

func (x *beaconChainStreamIndexedAttestationsClient) Recv() (*IndexedAttestation, error) {
	m := new(IndexedAttestation)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *beaconChainClient) AttestationPool(ctx context.Context, in *AttestationPoolRequest, opts ...grpc.CallOption) (*AttestationPoolResponse, error) {
	out := new(AttestationPoolResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/AttestationPool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListBlocks(ctx context.Context, in *ListBlocksRequest, opts ...grpc.CallOption) (*ListBlocksResponse, error) {
	out := new(ListBlocksResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/ListBlocks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) StreamBlocks(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (BeaconChain_StreamBlocksClient, error) {
	stream, err := c.cc.NewStream(ctx, &_BeaconChain_serviceDesc.Streams[2], "/ethereum.eth.v1alpha1.BeaconChain/StreamBlocks", opts...)
	if err != nil {
		return nil, err
	}
	x := &beaconChainStreamBlocksClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BeaconChain_StreamBlocksClient interface {
	Recv() (*SignedBeaconBlock, error)
	grpc.ClientStream
}

type beaconChainStreamBlocksClient struct {
	grpc.ClientStream
}

func (x *beaconChainStreamBlocksClient) Recv() (*SignedBeaconBlock, error) {
	m := new(SignedBeaconBlock)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *beaconChainClient) StreamChainHead(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (BeaconChain_StreamChainHeadClient, error) {
	stream, err := c.cc.NewStream(ctx, &_BeaconChain_serviceDesc.Streams[3], "/ethereum.eth.v1alpha1.BeaconChain/StreamChainHead", opts...)
	if err != nil {
		return nil, err
	}
	x := &beaconChainStreamChainHeadClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BeaconChain_StreamChainHeadClient interface {
	Recv() (*ChainHead, error)
	grpc.ClientStream
}

type beaconChainStreamChainHeadClient struct {
	grpc.ClientStream
}

func (x *beaconChainStreamChainHeadClient) Recv() (*ChainHead, error) {
	m := new(ChainHead)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *beaconChainClient) GetChainHead(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*ChainHead, error) {
	out := new(ChainHead)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/GetChainHead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListBeaconCommittees(ctx context.Context, in *ListCommitteesRequest, opts ...grpc.CallOption) (*BeaconCommittees, error) {
	out := new(BeaconCommittees)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/ListBeaconCommittees", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListValidatorBalances(ctx context.Context, in *ListValidatorBalancesRequest, opts ...grpc.CallOption) (*ValidatorBalances, error) {
	out := new(ValidatorBalances)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/ListValidatorBalances", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListValidators(ctx context.Context, in *ListValidatorsRequest, opts ...grpc.CallOption) (*Validators, error) {
	out := new(Validators)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/ListValidators", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetValidator(ctx context.Context, in *GetValidatorRequest, opts ...grpc.CallOption) (*Validator, error) {
	out := new(Validator)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/GetValidator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetValidatorActiveSetChanges(ctx context.Context, in *GetValidatorActiveSetChangesRequest, opts ...grpc.CallOption) (*ActiveSetChanges, error) {
	out := new(ActiveSetChanges)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/GetValidatorActiveSetChanges", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetValidatorQueue(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*ValidatorQueue, error) {
	out := new(ValidatorQueue)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/GetValidatorQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetValidatorPerformance(ctx context.Context, in *ValidatorPerformanceRequest, opts ...grpc.CallOption) (*ValidatorPerformanceResponse, error) {
	out := new(ValidatorPerformanceResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/GetValidatorPerformance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListValidatorAssignments(ctx context.Context, in *ListValidatorAssignmentsRequest, opts ...grpc.CallOption) (*ValidatorAssignments, error) {
	out := new(ValidatorAssignments)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/ListValidatorAssignments", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetValidatorParticipation(ctx context.Context, in *GetValidatorParticipationRequest, opts ...grpc.CallOption) (*ValidatorParticipationResponse, error) {
	out := new(ValidatorParticipationResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/GetValidatorParticipation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetBeaconConfig(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*BeaconConfig, error) {
	out := new(BeaconConfig)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/GetBeaconConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) StreamValidatorsInfo(ctx context.Context, opts ...grpc.CallOption) (BeaconChain_StreamValidatorsInfoClient, error) {
	stream, err := c.cc.NewStream(ctx, &_BeaconChain_serviceDesc.Streams[4], "/ethereum.eth.v1alpha1.BeaconChain/StreamValidatorsInfo", opts...)
	if err != nil {
		return nil, err
	}
	x := &beaconChainStreamValidatorsInfoClient{stream}
	return x, nil
}

type BeaconChain_StreamValidatorsInfoClient interface {
	Send(*ValidatorChangeSet) error
	Recv() (*ValidatorInfo, error)
	grpc.ClientStream
}

type beaconChainStreamValidatorsInfoClient struct {
	grpc.ClientStream
}

func (x *beaconChainStreamValidatorsInfoClient) Send(m *ValidatorChangeSet) error {
	return x.ClientStream.SendMsg(m)
}

func (x *beaconChainStreamValidatorsInfoClient) Recv() (*ValidatorInfo, error) {
	m := new(ValidatorInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *beaconChainClient) SubmitAttesterSlashing(ctx context.Context, in *AttesterSlashing, opts ...grpc.CallOption) (*SubmitSlashingResponse, error) {
	out := new(SubmitSlashingResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/SubmitAttesterSlashing", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) SubmitProposerSlashing(ctx context.Context, in *ProposerSlashing, opts ...grpc.CallOption) (*SubmitSlashingResponse, error) {
	out := new(SubmitSlashingResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/SubmitProposerSlashing", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BeaconChainServer is the server API for BeaconChain service.
type BeaconChainServer interface {
	ListAttestations(context.Context, *ListAttestationsRequest) (*ListAttestationsResponse, error)
	ListIndexedAttestations(context.Context, *ListIndexedAttestationsRequest) (*ListIndexedAttestationsResponse, error)
	StreamAttestations(*types.Empty, BeaconChain_StreamAttestationsServer) error
	StreamIndexedAttestations(*types.Empty, BeaconChain_StreamIndexedAttestationsServer) error
	AttestationPool(context.Context, *AttestationPoolRequest) (*AttestationPoolResponse, error)
	ListBlocks(context.Context, *ListBlocksRequest) (*ListBlocksResponse, error)
	StreamBlocks(*types.Empty, BeaconChain_StreamBlocksServer) error
	StreamChainHead(*types.Empty, BeaconChain_StreamChainHeadServer) error
	GetChainHead(context.Context, *types.Empty) (*ChainHead, error)
	ListBeaconCommittees(context.Context, *ListCommitteesRequest) (*BeaconCommittees, error)
	ListValidatorBalances(context.Context, *ListValidatorBalancesRequest) (*ValidatorBalances, error)
	ListValidators(context.Context, *ListValidatorsRequest) (*Validators, error)
	GetValidator(context.Context, *GetValidatorRequest) (*Validator, error)
	GetValidatorActiveSetChanges(context.Context, *GetValidatorActiveSetChangesRequest) (*ActiveSetChanges, error)
	GetValidatorQueue(context.Context, *types.Empty) (*ValidatorQueue, error)
	GetValidatorPerformance(context.Context, *ValidatorPerformanceRequest) (*ValidatorPerformanceResponse, error)
	ListValidatorAssignments(context.Context, *ListValidatorAssignmentsRequest) (*ValidatorAssignments, error)
	GetValidatorParticipation(context.Context, *GetValidatorParticipationRequest) (*ValidatorParticipationResponse, error)
	GetBeaconConfig(context.Context, *types.Empty) (*BeaconConfig, error)
	StreamValidatorsInfo(BeaconChain_StreamValidatorsInfoServer) error
	SubmitAttesterSlashing(context.Context, *AttesterSlashing) (*SubmitSlashingResponse, error)
	SubmitProposerSlashing(context.Context, *ProposerSlashing) (*SubmitSlashingResponse, error)
}

func RegisterBeaconChainServer(s *grpc.Server, srv BeaconChainServer) {
	s.RegisterService(&_BeaconChain_serviceDesc, srv)
}

func _BeaconChain_ListAttestations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAttestationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListAttestations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/ListAttestations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListAttestations(ctx, req.(*ListAttestationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListIndexedAttestations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListIndexedAttestationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListIndexedAttestations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/ListIndexedAttestations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListIndexedAttestations(ctx, req.(*ListIndexedAttestationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_StreamAttestations_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(types.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BeaconChainServer).StreamAttestations(m, &beaconChainStreamAttestationsServer{stream})
}

type BeaconChain_StreamAttestationsServer interface {
	Send(*Attestation) error
	grpc.ServerStream
}

type beaconChainStreamAttestationsServer struct {
	grpc.ServerStream
}

func (x *beaconChainStreamAttestationsServer) Send(m *Attestation) error {
	return x.ServerStream.SendMsg(m)
}

func _BeaconChain_StreamIndexedAttestations_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(types.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BeaconChainServer).StreamIndexedAttestations(m, &beaconChainStreamIndexedAttestationsServer{stream})
}

type BeaconChain_StreamIndexedAttestationsServer interface {
	Send(*IndexedAttestation) error
	grpc.ServerStream
}

type beaconChainStreamIndexedAttestationsServer struct {
	grpc.ServerStream
}

func (x *beaconChainStreamIndexedAttestationsServer) Send(m *IndexedAttestation) error {
	return x.ServerStream.SendMsg(m)
}

func _BeaconChain_AttestationPool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttestationPoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).AttestationPool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/AttestationPool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).AttestationPool(ctx, req.(*AttestationPoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListBlocks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBlocksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListBlocks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/ListBlocks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListBlocks(ctx, req.(*ListBlocksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_StreamBlocks_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(types.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BeaconChainServer).StreamBlocks(m, &beaconChainStreamBlocksServer{stream})
}

type BeaconChain_StreamBlocksServer interface {
	Send(*SignedBeaconBlock) error
	grpc.ServerStream
}

type beaconChainStreamBlocksServer struct {
	grpc.ServerStream
}

func (x *beaconChainStreamBlocksServer) Send(m *SignedBeaconBlock) error {
	return x.ServerStream.SendMsg(m)
}

func _BeaconChain_StreamChainHead_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(types.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BeaconChainServer).StreamChainHead(m, &beaconChainStreamChainHeadServer{stream})
}

type BeaconChain_StreamChainHeadServer interface {
	Send(*ChainHead) error
	grpc.ServerStream
}

type beaconChainStreamChainHeadServer struct {
	grpc.ServerStream
}

func (x *beaconChainStreamChainHeadServer) Send(m *ChainHead) error {
	return x.ServerStream.SendMsg(m)
}

func _BeaconChain_GetChainHead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetChainHead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/GetChainHead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetChainHead(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListBeaconCommittees_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCommitteesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListBeaconCommittees(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/ListBeaconCommittees",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListBeaconCommittees(ctx, req.(*ListCommitteesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListValidatorBalances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListValidatorBalancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListValidatorBalances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/ListValidatorBalances",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListValidatorBalances(ctx, req.(*ListValidatorBalancesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListValidators_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListValidatorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListValidators(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/ListValidators",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListValidators(ctx, req.(*ListValidatorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetValidator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetValidatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetValidator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/GetValidator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetValidator(ctx, req.(*GetValidatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetValidatorActiveSetChanges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetValidatorActiveSetChangesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetValidatorActiveSetChanges(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/GetValidatorActiveSetChanges",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetValidatorActiveSetChanges(ctx, req.(*GetValidatorActiveSetChangesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetValidatorQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetValidatorQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/GetValidatorQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetValidatorQueue(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetValidatorPerformance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidatorPerformanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetValidatorPerformance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/GetValidatorPerformance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetValidatorPerformance(ctx, req.(*ValidatorPerformanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListValidatorAssignments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListValidatorAssignmentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListValidatorAssignments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/ListValidatorAssignments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListValidatorAssignments(ctx, req.(*ListValidatorAssignmentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetValidatorParticipation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetValidatorParticipationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetValidatorParticipation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/GetValidatorParticipation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetValidatorParticipation(ctx, req.(*GetValidatorParticipationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetBeaconConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetBeaconConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/GetBeaconConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetBeaconConfig(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_StreamValidatorsInfo_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BeaconChainServer).StreamValidatorsInfo(&beaconChainStreamValidatorsInfoServer{stream})
}

type BeaconChain_StreamValidatorsInfoServer interface {
	Send(*ValidatorInfo) error
	Recv() (*ValidatorChangeSet, error)
	grpc.ServerStream
}

type beaconChainStreamValidatorsInfoServer struct {
	grpc.ServerStream
}

func (x *beaconChainStreamValidatorsInfoServer) Send(m *ValidatorInfo) error {
	return x.ServerStream.SendMsg(m)
}

func (x *beaconChainStreamValidatorsInfoServer) Recv() (*ValidatorChangeSet, error) {
	m := new(ValidatorChangeSet)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _BeaconChain_SubmitAttesterSlashing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttesterSlashing)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).SubmitAttesterSlashing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/SubmitAttesterSlashing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).SubmitAttesterSlashing(ctx, req.(*AttesterSlashing))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_SubmitProposerSlashing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProposerSlashing)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).SubmitProposerSlashing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/SubmitProposerSlashing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).SubmitProposerSlashing(ctx, req.(*ProposerSlashing))
	}
	return interceptor(ctx, in, info, handler)
}

var _BeaconChain_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ethereum.eth.v1alpha1.BeaconChain",
	HandlerType: (*BeaconChainServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListAttestations",
			Handler:    _BeaconChain_ListAttestations_Handler,
		},
		{
			MethodName: "ListIndexedAttestations",
			Handler:    _BeaconChain_ListIndexedAttestations_Handler,
		},
		{
			MethodName: "AttestationPool",
			Handler:    _BeaconChain_AttestationPool_Handler,
		},
		{
			MethodName: "ListBlocks",
			Handler:    _BeaconChain_ListBlocks_Handler,
		},
		{
			MethodName: "GetChainHead",
			Handler:    _BeaconChain_GetChainHead_Handler,
		},
		{
			MethodName: "ListBeaconCommittees",
			Handler:    _BeaconChain_ListBeaconCommittees_Handler,
		},
		{
			MethodName: "ListValidatorBalances",
			Handler:    _BeaconChain_ListValidatorBalances_Handler,
		},
		{
			MethodName: "ListValidators",
			Handler:    _BeaconChain_ListValidators_Handler,
		},
		{
			MethodName: "GetValidator",
			Handler:    _BeaconChain_GetValidator_Handler,
		},
		{
			MethodName: "GetValidatorActiveSetChanges",
			Handler:    _BeaconChain_GetValidatorActiveSetChanges_Handler,
		},
		{
			MethodName: "GetValidatorQueue",
			Handler:    _BeaconChain_GetValidatorQueue_Handler,
		},
		{
			MethodName: "GetValidatorPerformance",
			Handler:    _BeaconChain_GetValidatorPerformance_Handler,
		},
		{
			MethodName: "ListValidatorAssignments",
			Handler:    _BeaconChain_ListValidatorAssignments_Handler,
		},
		{
			MethodName: "GetValidatorParticipation",
			Handler:    _BeaconChain_GetValidatorParticipation_Handler,
		},
		{
			MethodName: "GetBeaconConfig",
			Handler:    _BeaconChain_GetBeaconConfig_Handler,
		},
		{
			MethodName: "SubmitAttesterSlashing",
			Handler:    _BeaconChain_SubmitAttesterSlashing_Handler,
		},
		{
			MethodName: "SubmitProposerSlashing",
			Handler:    _BeaconChain_SubmitProposerSlashing_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamAttestations",
			Handler:       _BeaconChain_StreamAttestations_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamIndexedAttestations",
			Handler:       _BeaconChain_StreamIndexedAttestations_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamBlocks",
			Handler:       _BeaconChain_StreamBlocks_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamChainHead",
			Handler:       _BeaconChain_StreamChainHead_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamValidatorsInfo",
			Handler:       _BeaconChain_StreamValidatorsInfo_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "eth/v1alpha1/beacon_chain.proto",
}

func (m *ValidatorChangeSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorChangeSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.Action))
	}
	if len(m.PublicKeys) > 0 {
		for _, b := range m.PublicKeys {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListIndexedAttestationsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListIndexedAttestationsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.QueryFilter != nil {
		nn1, err := m.QueryFilter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.PageSize))
	}
	if len(m.PageToken) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListIndexedAttestationsRequest_Epoch) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintBeaconChain(dAtA, i, uint64(m.Epoch))
	return i, nil
}
func (m *ListIndexedAttestationsRequest_GenesisEpoch) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	if m.GenesisEpoch {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *ListAttestationsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAttestationsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.QueryFilter != nil {
		nn2, err := m.QueryFilter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn2
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.PageSize))
	}
	if len(m.PageToken) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListAttestationsRequest_Epoch) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintBeaconChain(dAtA, i, uint64(m.Epoch))
	return i, nil
}
func (m *ListAttestationsRequest_GenesisEpoch) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	if m.GenesisEpoch {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *ListAttestationsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListAttestationsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Attestations) > 0 {
		for _, msg := range m.Attestations {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	if m.TotalSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.TotalSize))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListIndexedAttestationsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListIndexedAttestationsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IndexedAttestations) > 0 {
		for _, msg := range m.IndexedAttestations {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	if m.TotalSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.TotalSize))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListBlocksRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListBlocksRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.QueryFilter != nil {
		nn3, err := m.QueryFilter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn3
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.PageSize))
	}
	if len(m.PageToken) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListBlocksRequest_Root) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Root != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.Root)))
		i += copy(dAtA[i:], m.Root)
	}
	return i, nil
}
func (m *ListBlocksRequest_Slot) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintBeaconChain(dAtA, i, uint64(m.Slot))
	return i, nil
}
func (m *ListBlocksRequest_Epoch) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x18
	i++
	i = encodeVarintBeaconChain(dAtA, i, uint64(m.Epoch))
	return i, nil
}
func (m *ListBlocksRequest_Genesis) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x20
	i++
	if m.Genesis {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *ListBlocksResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListBlocksResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BlockContainers) > 0 {
		for _, msg := range m.BlockContainers {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	if m.TotalSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.TotalSize))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BeaconBlockContainer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BeaconBlockContainer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Block != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.Block.Size()))
		n4, err := m.Block.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.BlockRoot) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.BlockRoot)))
		i += copy(dAtA[i:], m.BlockRoot)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ChainHead) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainHead) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HeadSlot != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.HeadSlot))
	}
	if m.HeadEpoch != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.HeadEpoch))
	}
	if len(m.HeadBlockRoot) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.HeadBlockRoot)))
		i += copy(dAtA[i:], m.HeadBlockRoot)
	}
	if m.FinalizedSlot != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.FinalizedSlot))
	}
	if m.FinalizedEpoch != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.FinalizedEpoch))
	}
	if len(m.FinalizedBlockRoot) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.FinalizedBlockRoot)))
		i += copy(dAtA[i:], m.FinalizedBlockRoot)
	}
	if m.JustifiedSlot != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.JustifiedSlot))
	}
	if m.JustifiedEpoch != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.JustifiedEpoch))
	}
	if len(m.JustifiedBlockRoot) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.JustifiedBlockRoot)))
		i += copy(dAtA[i:], m.JustifiedBlockRoot)
	}
	if m.PreviousJustifiedSlot != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.PreviousJustifiedSlot))
	}
	if m.PreviousJustifiedEpoch != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.PreviousJustifiedEpoch))
	}
	if len(m.PreviousJustifiedBlockRoot) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.PreviousJustifiedBlockRoot)))
		i += copy(dAtA[i:], m.PreviousJustifiedBlockRoot)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListCommitteesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListCommitteesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.QueryFilter != nil {
		nn5, err := m.QueryFilter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListCommitteesRequest_Epoch) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintBeaconChain(dAtA, i, uint64(m.Epoch))
	return i, nil
}
func (m *ListCommitteesRequest_Genesis) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	if m.Genesis {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *BeaconCommittees) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BeaconCommittees) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.Epoch))
	}
	if len(m.Committees) > 0 {
		for k, _ := range m.Committees {
			dAtA[i] = 0x12
			i++
			v := m.Committees[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovBeaconChain(uint64(msgSize))
			}
			mapSize := 1 + sovBeaconChain(uint64(k)) + msgSize
			i = encodeVarintBeaconChain(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintBeaconChain(dAtA, i, uint64(v.Size()))
				n6, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n6
			}
		}
	}
	if m.ActiveValidatorCount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.ActiveValidatorCount))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BeaconCommittees_CommitteeItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BeaconCommittees_CommitteeItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ValidatorIndices) > 0 {
		dAtA8 := make([]byte, len(m.ValidatorIndices)*10)
		var j7 int
		for _, num := range m.ValidatorIndices {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BeaconCommittees_CommitteesList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BeaconCommittees_CommitteesList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Committees) > 0 {
		for _, msg := range m.Committees {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListValidatorBalancesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListValidatorBalancesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.QueryFilter != nil {
		nn9, err := m.QueryFilter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn9
	}
	if len(m.PublicKeys) > 0 {
		for _, b := range m.PublicKeys {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Indices) > 0 {
		dAtA11 := make([]byte, len(m.Indices)*10)
		var j10 int
		for _, num := range m.Indices {
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(j10))
		i += copy(dAtA[i:], dAtA11[:j10])
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.PageSize))
	}
	if len(m.PageToken) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListValidatorBalancesRequest_Epoch) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintBeaconChain(dAtA, i, uint64(m.Epoch))
	return i, nil
}
func (m *ListValidatorBalancesRequest_Genesis) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	if m.Genesis {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *ValidatorBalances) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorBalances) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.Epoch))
	}
	if len(m.Balances) > 0 {
		for _, msg := range m.Balances {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	if m.TotalSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.TotalSize))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValidatorBalances_Balance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorBalances_Balance) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PublicKey) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.PublicKey)))
		i += copy(dAtA[i:], m.PublicKey)
	}
	if m.Index != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.Index))
	}
	if m.Balance != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.Balance))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListValidatorsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListValidatorsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.QueryFilter != nil {
		nn12, err := m.QueryFilter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn12
	}
	if m.Active {
		dAtA[i] = 0x18
		i++
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.PageSize))
	}
	if len(m.PageToken) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	if len(m.PublicKeys) > 0 {
		for _, b := range m.PublicKeys {
			dAtA[i] = 0x32
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Indices) > 0 {
		dAtA14 := make([]byte, len(m.Indices)*10)
		var j13 int
		for _, num := range m.Indices {
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		dAtA[i] = 0x3a
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(j13))
		i += copy(dAtA[i:], dAtA14[:j13])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListValidatorsRequest_Epoch) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintBeaconChain(dAtA, i, uint64(m.Epoch))
	return i, nil
}
func (m *ListValidatorsRequest_Genesis) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	if m.Genesis {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *GetValidatorRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetValidatorRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.QueryFilter != nil {
		nn15, err := m.QueryFilter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn15
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetValidatorRequest_Index) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintBeaconChain(dAtA, i, uint64(m.Index))
	return i, nil
}
func (m *GetValidatorRequest_PublicKey) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PublicKey != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.PublicKey)))
		i += copy(dAtA[i:], m.PublicKey)
	}
	return i, nil
}
func (m *Validators) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Validators) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.Epoch))
	}
	if len(m.ValidatorList) > 0 {
		for _, msg := range m.ValidatorList {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	if m.TotalSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.TotalSize))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Validators_ValidatorContainer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Validators_ValidatorContainer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.Index))
	}
	if m.Validator != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.Validator.Size()))
		n16, err := m.Validator.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetValidatorActiveSetChangesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetValidatorActiveSetChangesRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.QueryFilter != nil {
		nn17, err := m.QueryFilter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn17
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetValidatorActiveSetChangesRequest_Epoch) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintBeaconChain(dAtA, i, uint64(m.Epoch))
	return i, nil
}
func (m *GetValidatorActiveSetChangesRequest_Genesis) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	if m.Genesis {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *ActiveSetChanges) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActiveSetChanges) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.Epoch))
	}
	if len(m.ActivatedPublicKeys) > 0 {
		for _, b := range m.ActivatedPublicKeys {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.ActivatedIndices) > 0 {
		dAtA19 := make([]byte, len(m.ActivatedIndices)*10)
		var j18 int
		for _, num := range m.ActivatedIndices {
			for num >= 1<<7 {
				dAtA19[j18] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j18++
			}
			dAtA19[j18] = uint8(num)
			j18++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(j18))
		i += copy(dAtA[i:], dAtA19[:j18])
	}
	if len(m.ExitedPublicKeys) > 0 {
		for _, b := range m.ExitedPublicKeys {
			dAtA[i] = 0x22
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.ExitedIndices) > 0 {
		dAtA21 := make([]byte, len(m.ExitedIndices)*10)
		var j20 int
		for _, num := range m.ExitedIndices {
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(j20))
		i += copy(dAtA[i:], dAtA21[:j20])
	}
	if len(m.SlashedPublicKeys) > 0 {
		for _, b := range m.SlashedPublicKeys {
			dAtA[i] = 0x32
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.SlashedIndices) > 0 {
		dAtA23 := make([]byte, len(m.SlashedIndices)*10)
		var j22 int
		for _, num := range m.SlashedIndices {
			for num >= 1<<7 {
				dAtA23[j22] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j22++
			}
			dAtA23[j22] = uint8(num)
			j22++
		}
		dAtA[i] = 0x3a
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(j22))
		i += copy(dAtA[i:], dAtA23[:j22])
	}
	if len(m.EjectedPublicKeys) > 0 {
		for _, b := range m.EjectedPublicKeys {
			dAtA[i] = 0x42
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.EjectedIndices) > 0 {
		dAtA25 := make([]byte, len(m.EjectedIndices)*10)
		var j24 int
		for _, num := range m.EjectedIndices {
			for num >= 1<<7 {
				dAtA25[j24] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j24++
			}
			dAtA25[j24] = uint8(num)
			j24++
		}
		dAtA[i] = 0x4a
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(j24))
		i += copy(dAtA[i:], dAtA25[:j24])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValidatorPerformanceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorPerformanceRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PublicKeys) > 0 {
		for _, b := range m.PublicKeys {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Indices) > 0 {
		dAtA27 := make([]byte, len(m.Indices)*10)
		var j26 int
		for _, num := range m.Indices {
			for num >= 1<<7 {
				dAtA27[j26] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j26++
			}
			dAtA27[j26] = uint8(num)
			j26++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(j26))
		i += copy(dAtA[i:], dAtA27[:j26])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValidatorPerformanceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorPerformanceResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CurrentEffectiveBalances) > 0 {
		dAtA29 := make([]byte, len(m.CurrentEffectiveBalances)*10)
		var j28 int
		for _, num := range m.CurrentEffectiveBalances {
			for num >= 1<<7 {
				dAtA29[j28] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j28++
			}
			dAtA29[j28] = uint8(num)
			j28++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(j28))
		i += copy(dAtA[i:], dAtA29[:j28])
	}
	if len(m.InclusionSlots) > 0 {
		dAtA31 := make([]byte, len(m.InclusionSlots)*10)
		var j30 int
		for _, num := range m.InclusionSlots {
			for num >= 1<<7 {
				dAtA31[j30] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j30++
			}
			dAtA31[j30] = uint8(num)
			j30++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(j30))
		i += copy(dAtA[i:], dAtA31[:j30])
	}
	if len(m.InclusionDistances) > 0 {
		dAtA33 := make([]byte, len(m.InclusionDistances)*10)
		var j32 int
		for _, num := range m.InclusionDistances {
			for num >= 1<<7 {
				dAtA33[j32] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j32++
			}
			dAtA33[j32] = uint8(num)
			j32++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(j32))
		i += copy(dAtA[i:], dAtA33[:j32])
	}
	if len(m.CorrectlyVotedSource) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.CorrectlyVotedSource)))
		for _, b := range m.CorrectlyVotedSource {
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.CorrectlyVotedTarget) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.CorrectlyVotedTarget)))
		for _, b := range m.CorrectlyVotedTarget {
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.CorrectlyVotedHead) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.CorrectlyVotedHead)))
		for _, b := range m.CorrectlyVotedHead {
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.BalancesBeforeEpochTransition) > 0 {
		dAtA35 := make([]byte, len(m.BalancesBeforeEpochTransition)*10)
		var j34 int
		for _, num := range m.BalancesBeforeEpochTransition {
			for num >= 1<<7 {
				dAtA35[j34] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j34++
			}
			dAtA35[j34] = uint8(num)
			j34++
		}
		dAtA[i] = 0x3a
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(j34))
		i += copy(dAtA[i:], dAtA35[:j34])
	}
	if len(m.BalancesAfterEpochTransition) > 0 {
		dAtA37 := make([]byte, len(m.BalancesAfterEpochTransition)*10)
		var j36 int
		for _, num := range m.BalancesAfterEpochTransition {
			for num >= 1<<7 {
				dAtA37[j36] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j36++
			}
			dAtA37[j36] = uint8(num)
			j36++
		}
		dAtA[i] = 0x42
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(j36))
		i += copy(dAtA[i:], dAtA37[:j36])
	}
	if len(m.MissingValidators) > 0 {
		for _, b := range m.MissingValidators {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.AverageActiveValidatorBalance != 0 {
		dAtA[i] = 0x55
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.AverageActiveValidatorBalance))))
		i += 4
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValidatorQueue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorQueue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChurnLimit != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.ChurnLimit))
	}
	if len(m.ActivationPublicKeys) > 0 {
		for _, b := range m.ActivationPublicKeys {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.ExitPublicKeys) > 0 {
		for _, b := range m.ExitPublicKeys {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.ActivationValidatorIndices) > 0 {
		dAtA39 := make([]byte, len(m.ActivationValidatorIndices)*10)
		var j38 int
		for _, num := range m.ActivationValidatorIndices {
			for num >= 1<<7 {
				dAtA39[j38] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j38++
			}
			dAtA39[j38] = uint8(num)
			j38++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(j38))
		i += copy(dAtA[i:], dAtA39[:j38])
	}
	if len(m.ExitValidatorIndices) > 0 {
		dAtA41 := make([]byte, len(m.ExitValidatorIndices)*10)
		var j40 int
		for _, num := range m.ExitValidatorIndices {
			for num >= 1<<7 {
				dAtA41[j40] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j40++
			}
			dAtA41[j40] = uint8(num)
			j40++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(j40))
		i += copy(dAtA[i:], dAtA41[:j40])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListValidatorAssignmentsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListValidatorAssignmentsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.QueryFilter != nil {
		nn42, err := m.QueryFilter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn42
	}
	if len(m.PublicKeys) > 0 {
		for _, b := range m.PublicKeys {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Indices) > 0 {
		dAtA44 := make([]byte, len(m.Indices)*10)
		var j43 int
		for _, num := range m.Indices {
			for num >= 1<<7 {
				dAtA44[j43] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j43++
			}
			dAtA44[j43] = uint8(num)
			j43++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(j43))
		i += copy(dAtA[i:], dAtA44[:j43])
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.PageSize))
	}
	if len(m.PageToken) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListValidatorAssignmentsRequest_Epoch) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintBeaconChain(dAtA, i, uint64(m.Epoch))
	return i, nil
}
func (m *ListValidatorAssignmentsRequest_Genesis) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	if m.Genesis {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *ValidatorAssignments) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorAssignments) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.Epoch))
	}
	if len(m.Assignments) > 0 {
		for _, msg := range m.Assignments {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	if m.TotalSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.TotalSize))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ValidatorAssignments_CommitteeAssignment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorAssignments_CommitteeAssignment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BeaconCommittees) > 0 {
		dAtA46 := make([]byte, len(m.BeaconCommittees)*10)
		var j45 int
		for _, num := range m.BeaconCommittees {
			for num >= 1<<7 {
				dAtA46[j45] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j45++
			}
			dAtA46[j45] = uint8(num)
			j45++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(j45))
		i += copy(dAtA[i:], dAtA46[:j45])
	}
	if m.CommitteeIndex != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.CommitteeIndex))
	}
	if m.AttesterSlot != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.AttesterSlot))
	}
	if len(m.ProposerSlots) > 0 {
		dAtA48 := make([]byte, len(m.ProposerSlots)*10)
		var j47 int
		for _, num := range m.ProposerSlots {
			for num >= 1<<7 {
				dAtA48[j47] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j47++
			}
			dAtA48[j47] = uint8(num)
			j47++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(j47))
		i += copy(dAtA[i:], dAtA48[:j47])
	}
	if len(m.PublicKey) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.PublicKey)))
		i += copy(dAtA[i:], m.PublicKey)
	}
	if m.ValidatorIndex != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.ValidatorIndex))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetValidatorParticipationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetValidatorParticipationRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.QueryFilter != nil {
		nn49, err := m.QueryFilter.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn49
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetValidatorParticipationRequest_Epoch) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x8
	i++
	i = encodeVarintBeaconChain(dAtA, i, uint64(m.Epoch))
	return i, nil
}
func (m *GetValidatorParticipationRequest_Genesis) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	if m.Genesis {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *ValidatorParticipationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorParticipationResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.Epoch))
	}
	if m.Finalized {
		dAtA[i] = 0x10
		i++
		if m.Finalized {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Participation != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.Participation.Size()))
		n50, err := m.Participation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AttestationPoolRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttestationPoolRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PageSize != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.PageSize))
	}
	if len(m.PageToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AttestationPoolResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttestationPoolResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Attestations) > 0 {
		for _, msg := range m.Attestations {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NextPageToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(len(m.NextPageToken)))
		i += copy(dAtA[i:], m.NextPageToken)
	}
	if m.TotalSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(m.TotalSize))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BeaconConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BeaconConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Config) > 0 {
		for k, _ := range m.Config {
			dAtA[i] = 0xa
			i++
			v := m.Config[k]
			mapSize := 1 + len(k) + sovBeaconChain(uint64(len(k))) + 1 + len(v) + sovBeaconChain(uint64(len(v)))
			i = encodeVarintBeaconChain(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintBeaconChain(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SubmitSlashingResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubmitSlashingResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SlashedIndices) > 0 {
		dAtA52 := make([]byte, len(m.SlashedIndices)*10)
		var j51 int
		for _, num := range m.SlashedIndices {
			for num >= 1<<7 {
				dAtA52[j51] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j51++
			}
			dAtA52[j51] = uint8(num)
			j51++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintBeaconChain(dAtA, i, uint64(j51))
		i += copy(dAtA[i:], dAtA52[:j51])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintBeaconChain(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ValidatorChangeSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovBeaconChain(uint64(m.Action))
	}
	if len(m.PublicKeys) > 0 {
		for _, b := range m.PublicKeys {
			l = len(b)
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListIndexedAttestationsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryFilter != nil {
		n += m.QueryFilter.Size()
	}
	if m.PageSize != 0 {
		n += 1 + sovBeaconChain(uint64(m.PageSize))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListIndexedAttestationsRequest_Epoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovBeaconChain(uint64(m.Epoch))
	return n
}
func (m *ListIndexedAttestationsRequest_GenesisEpoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *ListAttestationsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryFilter != nil {
		n += m.QueryFilter.Size()
	}
	if m.PageSize != 0 {
		n += 1 + sovBeaconChain(uint64(m.PageSize))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListAttestationsRequest_Epoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovBeaconChain(uint64(m.Epoch))
	return n
}
func (m *ListAttestationsRequest_GenesisEpoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *ListAttestationsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attestations) > 0 {
		for _, e := range m.Attestations {
			l = e.Size()
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.TotalSize != 0 {
		n += 1 + sovBeaconChain(uint64(m.TotalSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListIndexedAttestationsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.IndexedAttestations) > 0 {
		for _, e := range m.IndexedAttestations {
			l = e.Size()
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.TotalSize != 0 {
		n += 1 + sovBeaconChain(uint64(m.TotalSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListBlocksRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryFilter != nil {
		n += m.QueryFilter.Size()
	}
	if m.PageSize != 0 {
		n += 1 + sovBeaconChain(uint64(m.PageSize))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListBlocksRequest_Root) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Root != nil {
		l = len(m.Root)
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	return n
}
func (m *ListBlocksRequest_Slot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovBeaconChain(uint64(m.Slot))
	return n
}
func (m *ListBlocksRequest_Epoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovBeaconChain(uint64(m.Epoch))
	return n
}
func (m *ListBlocksRequest_Genesis) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *ListBlocksResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BlockContainers) > 0 {
		for _, e := range m.BlockContainers {
			l = e.Size()
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.TotalSize != 0 {
		n += 1 + sovBeaconChain(uint64(m.TotalSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BeaconBlockContainer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	l = len(m.BlockRoot)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChainHead) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HeadSlot != 0 {
		n += 1 + sovBeaconChain(uint64(m.HeadSlot))
	}
	if m.HeadEpoch != 0 {
		n += 1 + sovBeaconChain(uint64(m.HeadEpoch))
	}
	l = len(m.HeadBlockRoot)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.FinalizedSlot != 0 {
		n += 1 + sovBeaconChain(uint64(m.FinalizedSlot))
	}
	if m.FinalizedEpoch != 0 {
		n += 1 + sovBeaconChain(uint64(m.FinalizedEpoch))
	}
	l = len(m.FinalizedBlockRoot)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.JustifiedSlot != 0 {
		n += 1 + sovBeaconChain(uint64(m.JustifiedSlot))
	}
	if m.JustifiedEpoch != 0 {
		n += 1 + sovBeaconChain(uint64(m.JustifiedEpoch))
	}
	l = len(m.JustifiedBlockRoot)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.PreviousJustifiedSlot != 0 {
		n += 1 + sovBeaconChain(uint64(m.PreviousJustifiedSlot))
	}
	if m.PreviousJustifiedEpoch != 0 {
		n += 1 + sovBeaconChain(uint64(m.PreviousJustifiedEpoch))
	}
	l = len(m.PreviousJustifiedBlockRoot)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListCommitteesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryFilter != nil {
		n += m.QueryFilter.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListCommitteesRequest_Epoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovBeaconChain(uint64(m.Epoch))
	return n
}
func (m *ListCommitteesRequest_Genesis) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *BeaconCommittees) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovBeaconChain(uint64(m.Epoch))
	}
	if len(m.Committees) > 0 {
		for k, v := range m.Committees {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovBeaconChain(uint64(l))
			}
			mapEntrySize := 1 + sovBeaconChain(uint64(k)) + l
			n += mapEntrySize + 1 + sovBeaconChain(uint64(mapEntrySize))
		}
	}
	if m.ActiveValidatorCount != 0 {
		n += 1 + sovBeaconChain(uint64(m.ActiveValidatorCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BeaconCommittees_CommitteeItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ValidatorIndices) > 0 {
		l = 0
		for _, e := range m.ValidatorIndices {
			l += sovBeaconChain(uint64(e))
		}
		n += 1 + sovBeaconChain(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BeaconCommittees_CommitteesList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Committees) > 0 {
		for _, e := range m.Committees {
			l = e.Size()
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListValidatorBalancesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryFilter != nil {
		n += m.QueryFilter.Size()
	}
	if len(m.PublicKeys) > 0 {
		for _, b := range m.PublicKeys {
			l = len(b)
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	if len(m.Indices) > 0 {
		l = 0
		for _, e := range m.Indices {
			l += sovBeaconChain(uint64(e))
		}
		n += 1 + sovBeaconChain(uint64(l)) + l
	}
	if m.PageSize != 0 {
		n += 1 + sovBeaconChain(uint64(m.PageSize))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListValidatorBalancesRequest_Epoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovBeaconChain(uint64(m.Epoch))
	return n
}
func (m *ListValidatorBalancesRequest_Genesis) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *ValidatorBalances) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovBeaconChain(uint64(m.Epoch))
	}
	if len(m.Balances) > 0 {
		for _, e := range m.Balances {
			l = e.Size()
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.TotalSize != 0 {
		n += 1 + sovBeaconChain(uint64(m.TotalSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidatorBalances_Balance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovBeaconChain(uint64(m.Index))
	}
	if m.Balance != 0 {
		n += 1 + sovBeaconChain(uint64(m.Balance))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListValidatorsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryFilter != nil {
		n += m.QueryFilter.Size()
	}
	if m.Active {
		n += 2
	}
	if m.PageSize != 0 {
		n += 1 + sovBeaconChain(uint64(m.PageSize))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if len(m.PublicKeys) > 0 {
		for _, b := range m.PublicKeys {
			l = len(b)
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	if len(m.Indices) > 0 {
		l = 0
		for _, e := range m.Indices {
			l += sovBeaconChain(uint64(e))
		}
		n += 1 + sovBeaconChain(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListValidatorsRequest_Epoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovBeaconChain(uint64(m.Epoch))
	return n
}
func (m *ListValidatorsRequest_Genesis) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *GetValidatorRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryFilter != nil {
		n += m.QueryFilter.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetValidatorRequest_Index) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovBeaconChain(uint64(m.Index))
	return n
}
func (m *GetValidatorRequest_PublicKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PublicKey != nil {
		l = len(m.PublicKey)
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	return n
}
func (m *Validators) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovBeaconChain(uint64(m.Epoch))
	}
	if len(m.ValidatorList) > 0 {
		for _, e := range m.ValidatorList {
			l = e.Size()
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.TotalSize != 0 {
		n += 1 + sovBeaconChain(uint64(m.TotalSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Validators_ValidatorContainer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovBeaconChain(uint64(m.Index))
	}
	if m.Validator != nil {
		l = m.Validator.Size()
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetValidatorActiveSetChangesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryFilter != nil {
		n += m.QueryFilter.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetValidatorActiveSetChangesRequest_Epoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovBeaconChain(uint64(m.Epoch))
	return n
}
func (m *GetValidatorActiveSetChangesRequest_Genesis) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *ActiveSetChanges) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovBeaconChain(uint64(m.Epoch))
	}
	if len(m.ActivatedPublicKeys) > 0 {
		for _, b := range m.ActivatedPublicKeys {
			l = len(b)
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	if len(m.ActivatedIndices) > 0 {
		l = 0
		for _, e := range m.ActivatedIndices {
			l += sovBeaconChain(uint64(e))
		}
		n += 1 + sovBeaconChain(uint64(l)) + l
	}
	if len(m.ExitedPublicKeys) > 0 {
		for _, b := range m.ExitedPublicKeys {
			l = len(b)
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	if len(m.ExitedIndices) > 0 {
		l = 0
		for _, e := range m.ExitedIndices {
			l += sovBeaconChain(uint64(e))
		}
		n += 1 + sovBeaconChain(uint64(l)) + l
	}
	if len(m.SlashedPublicKeys) > 0 {
		for _, b := range m.SlashedPublicKeys {
			l = len(b)
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	if len(m.SlashedIndices) > 0 {
		l = 0
		for _, e := range m.SlashedIndices {
			l += sovBeaconChain(uint64(e))
		}
		n += 1 + sovBeaconChain(uint64(l)) + l
	}
	if len(m.EjectedPublicKeys) > 0 {
		for _, b := range m.EjectedPublicKeys {
			l = len(b)
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	if len(m.EjectedIndices) > 0 {
		l = 0
		for _, e := range m.EjectedIndices {
			l += sovBeaconChain(uint64(e))
		}
		n += 1 + sovBeaconChain(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidatorPerformanceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PublicKeys) > 0 {
		for _, b := range m.PublicKeys {
			l = len(b)
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	if len(m.Indices) > 0 {
		l = 0
		for _, e := range m.Indices {
			l += sovBeaconChain(uint64(e))
		}
		n += 1 + sovBeaconChain(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidatorPerformanceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CurrentEffectiveBalances) > 0 {
		l = 0
		for _, e := range m.CurrentEffectiveBalances {
			l += sovBeaconChain(uint64(e))
		}
		n += 1 + sovBeaconChain(uint64(l)) + l
	}
	if len(m.InclusionSlots) > 0 {
		l = 0
		for _, e := range m.InclusionSlots {
			l += sovBeaconChain(uint64(e))
		}
		n += 1 + sovBeaconChain(uint64(l)) + l
	}
	if len(m.InclusionDistances) > 0 {
		l = 0
		for _, e := range m.InclusionDistances {
			l += sovBeaconChain(uint64(e))
		}
		n += 1 + sovBeaconChain(uint64(l)) + l
	}
	if len(m.CorrectlyVotedSource) > 0 {
		n += 1 + sovBeaconChain(uint64(len(m.CorrectlyVotedSource))) + len(m.CorrectlyVotedSource)*1
	}
	if len(m.CorrectlyVotedTarget) > 0 {
		n += 1 + sovBeaconChain(uint64(len(m.CorrectlyVotedTarget))) + len(m.CorrectlyVotedTarget)*1
	}
	if len(m.CorrectlyVotedHead) > 0 {
		n += 1 + sovBeaconChain(uint64(len(m.CorrectlyVotedHead))) + len(m.CorrectlyVotedHead)*1
	}
	if len(m.BalancesBeforeEpochTransition) > 0 {
		l = 0
		for _, e := range m.BalancesBeforeEpochTransition {
			l += sovBeaconChain(uint64(e))
		}
		n += 1 + sovBeaconChain(uint64(l)) + l
	}
	if len(m.BalancesAfterEpochTransition) > 0 {
		l = 0
		for _, e := range m.BalancesAfterEpochTransition {
			l += sovBeaconChain(uint64(e))
		}
		n += 1 + sovBeaconChain(uint64(l)) + l
	}
	if len(m.MissingValidators) > 0 {
		for _, b := range m.MissingValidators {
			l = len(b)
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	if m.AverageActiveValidatorBalance != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidatorQueue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChurnLimit != 0 {
		n += 1 + sovBeaconChain(uint64(m.ChurnLimit))
	}
	if len(m.ActivationPublicKeys) > 0 {
		for _, b := range m.ActivationPublicKeys {
			l = len(b)
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	if len(m.ExitPublicKeys) > 0 {
		for _, b := range m.ExitPublicKeys {
			l = len(b)
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	if len(m.ActivationValidatorIndices) > 0 {
		l = 0
		for _, e := range m.ActivationValidatorIndices {
			l += sovBeaconChain(uint64(e))
		}
		n += 1 + sovBeaconChain(uint64(l)) + l
	}
	if len(m.ExitValidatorIndices) > 0 {
		l = 0
		for _, e := range m.ExitValidatorIndices {
			l += sovBeaconChain(uint64(e))
		}
		n += 1 + sovBeaconChain(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListValidatorAssignmentsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryFilter != nil {
		n += m.QueryFilter.Size()
	}
	if len(m.PublicKeys) > 0 {
		for _, b := range m.PublicKeys {
			l = len(b)
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	if len(m.Indices) > 0 {
		l = 0
		for _, e := range m.Indices {
			l += sovBeaconChain(uint64(e))
		}
		n += 1 + sovBeaconChain(uint64(l)) + l
	}
	if m.PageSize != 0 {
		n += 1 + sovBeaconChain(uint64(m.PageSize))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListValidatorAssignmentsRequest_Epoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovBeaconChain(uint64(m.Epoch))
	return n
}
func (m *ListValidatorAssignmentsRequest_Genesis) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *ValidatorAssignments) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovBeaconChain(uint64(m.Epoch))
	}
	if len(m.Assignments) > 0 {
		for _, e := range m.Assignments {
			l = e.Size()
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.TotalSize != 0 {
		n += 1 + sovBeaconChain(uint64(m.TotalSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ValidatorAssignments_CommitteeAssignment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BeaconCommittees) > 0 {
		l = 0
		for _, e := range m.BeaconCommittees {
			l += sovBeaconChain(uint64(e))
		}
		n += 1 + sovBeaconChain(uint64(l)) + l
	}
	if m.CommitteeIndex != 0 {
		n += 1 + sovBeaconChain(uint64(m.CommitteeIndex))
	}
	if m.AttesterSlot != 0 {
		n += 1 + sovBeaconChain(uint64(m.AttesterSlot))
	}
	if len(m.ProposerSlots) > 0 {
		l = 0
		for _, e := range m.ProposerSlots {
			l += sovBeaconChain(uint64(e))
		}
		n += 1 + sovBeaconChain(uint64(l)) + l
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.ValidatorIndex != 0 {
		n += 1 + sovBeaconChain(uint64(m.ValidatorIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetValidatorParticipationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryFilter != nil {
		n += m.QueryFilter.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetValidatorParticipationRequest_Epoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovBeaconChain(uint64(m.Epoch))
	return n
}
func (m *GetValidatorParticipationRequest_Genesis) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *ValidatorParticipationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovBeaconChain(uint64(m.Epoch))
	}
	if m.Finalized {
		n += 2
	}
	if m.Participation != nil {
		l = m.Participation.Size()
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttestationPoolRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PageSize != 0 {
		n += 1 + sovBeaconChain(uint64(m.PageSize))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttestationPoolResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attestations) > 0 {
		for _, e := range m.Attestations {
			l = e.Size()
			n += 1 + l + sovBeaconChain(uint64(l))
		}
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovBeaconChain(uint64(l))
	}
	if m.TotalSize != 0 {
		n += 1 + sovBeaconChain(uint64(m.TotalSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BeaconConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Config) > 0 {
		for k, v := range m.Config {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovBeaconChain(uint64(len(k))) + 1 + len(v) + sovBeaconChain(uint64(len(v)))
			n += mapEntrySize + 1 + sovBeaconChain(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubmitSlashingResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SlashedIndices) > 0 {
		l = 0
		for _, e := range m.SlashedIndices {
			l += sovBeaconChain(uint64(e))
		}
		n += 1 + sovBeaconChain(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBeaconChain(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozBeaconChain(x uint64) (n int) {
	return sovBeaconChain(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ValidatorChangeSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorChangeSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorChangeSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= SetAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKeys = append(m.PublicKeys, make([]byte, postIndex-iNdEx))
			copy(m.PublicKeys[len(m.PublicKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListIndexedAttestationsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListIndexedAttestationsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListIndexedAttestationsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QueryFilter = &ListIndexedAttestationsRequest_Epoch{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenesisEpoch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.QueryFilter = &ListIndexedAttestationsRequest_GenesisEpoch{b}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAttestationsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAttestationsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAttestationsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QueryFilter = &ListAttestationsRequest_Epoch{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenesisEpoch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.QueryFilter = &ListAttestationsRequest_GenesisEpoch{b}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAttestationsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAttestationsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAttestationsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attestations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attestations = append(m.Attestations, &Attestation{})
			if err := m.Attestations[len(m.Attestations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListIndexedAttestationsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListIndexedAttestationsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListIndexedAttestationsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexedAttestations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexedAttestations = append(m.IndexedAttestations, &IndexedAttestation{})
			if err := m.IndexedAttestations[len(m.IndexedAttestations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListBlocksRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListBlocksRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListBlocksRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.QueryFilter = &ListBlocksRequest_Root{v}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slot", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QueryFilter = &ListBlocksRequest_Slot{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QueryFilter = &ListBlocksRequest_Epoch{v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Genesis", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.QueryFilter = &ListBlocksRequest_Genesis{b}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListBlocksResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListBlocksResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListBlocksResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockContainers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockContainers = append(m.BlockContainers, &BeaconBlockContainer{})
			if err := m.BlockContainers[len(m.BlockContainers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BeaconBlockContainer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BeaconBlockContainer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BeaconBlockContainer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &SignedBeaconBlock{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockRoot = append(m.BlockRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockRoot == nil {
				m.BlockRoot = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChainHead) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainHead: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainHead: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadSlot", wireType)
			}
			m.HeadSlot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeadSlot |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadEpoch", wireType)
			}
			m.HeadEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeadEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadBlockRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeadBlockRoot = append(m.HeadBlockRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.HeadBlockRoot == nil {
				m.HeadBlockRoot = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalizedSlot", wireType)
			}
			m.FinalizedSlot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinalizedSlot |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalizedEpoch", wireType)
			}
			m.FinalizedEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinalizedEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalizedBlockRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FinalizedBlockRoot = append(m.FinalizedBlockRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.FinalizedBlockRoot == nil {
				m.FinalizedBlockRoot = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JustifiedSlot", wireType)
			}
			m.JustifiedSlot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JustifiedSlot |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JustifiedEpoch", wireType)
			}
			m.JustifiedEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JustifiedEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JustifiedBlockRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JustifiedBlockRoot = append(m.JustifiedBlockRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.JustifiedBlockRoot == nil {
				m.JustifiedBlockRoot = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousJustifiedSlot", wireType)
			}
			m.PreviousJustifiedSlot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreviousJustifiedSlot |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousJustifiedEpoch", wireType)
			}
			m.PreviousJustifiedEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreviousJustifiedEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousJustifiedBlockRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousJustifiedBlockRoot = append(m.PreviousJustifiedBlockRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.PreviousJustifiedBlockRoot == nil {
				m.PreviousJustifiedBlockRoot = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListCommitteesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListCommitteesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListCommitteesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QueryFilter = &ListCommitteesRequest_Epoch{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Genesis", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.QueryFilter = &ListCommitteesRequest_Genesis{b}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BeaconCommittees) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BeaconCommittees: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BeaconCommittees: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Committees", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Committees == nil {
				m.Committees = make(map[uint64]*BeaconCommittees_CommitteesList)
			}
			var mapkey uint64
			var mapvalue *BeaconCommittees_CommitteesList
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthBeaconChain
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthBeaconChain
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &BeaconCommittees_CommitteesList{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBeaconChain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthBeaconChain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Committees[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveValidatorCount", wireType)
			}
			m.ActiveValidatorCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveValidatorCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BeaconCommittees_CommitteeItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitteeItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitteeItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ValidatorIndices = append(m.ValidatorIndices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBeaconChain
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBeaconChain
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ValidatorIndices) == 0 {
					m.ValidatorIndices = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ValidatorIndices = append(m.ValidatorIndices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorIndices", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BeaconCommittees_CommitteesList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitteesList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitteesList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Committees", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Committees = append(m.Committees, &BeaconCommittees_CommitteeItem{})
			if err := m.Committees[len(m.Committees)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListValidatorBalancesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListValidatorBalancesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListValidatorBalancesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QueryFilter = &ListValidatorBalancesRequest_Epoch{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Genesis", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.QueryFilter = &ListValidatorBalancesRequest_Genesis{b}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKeys = append(m.PublicKeys, make([]byte, postIndex-iNdEx))
			copy(m.PublicKeys[len(m.PublicKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Indices = append(m.Indices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBeaconChain
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBeaconChain
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Indices) == 0 {
					m.Indices = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Indices = append(m.Indices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Indices", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorBalances) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorBalances: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorBalances: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balances = append(m.Balances, &ValidatorBalances_Balance{})
			if err := m.Balances[len(m.Balances)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorBalances_Balance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Balance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Balance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			m.Balance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Balance |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListValidatorsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListValidatorsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListValidatorsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QueryFilter = &ListValidatorsRequest_Epoch{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Genesis", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.QueryFilter = &ListValidatorsRequest_Genesis{b}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKeys = append(m.PublicKeys, make([]byte, postIndex-iNdEx))
			copy(m.PublicKeys[len(m.PublicKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Indices = append(m.Indices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBeaconChain
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBeaconChain
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Indices) == 0 {
					m.Indices = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Indices = append(m.Indices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Indices", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetValidatorRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetValidatorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetValidatorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QueryFilter = &GetValidatorRequest_Index{v}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.QueryFilter = &GetValidatorRequest_PublicKey{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Validators) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Validators: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Validators: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorList = append(m.ValidatorList, &Validators_ValidatorContainer{})
			if err := m.ValidatorList[len(m.ValidatorList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Validators_ValidatorContainer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorContainer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorContainer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Validator == nil {
				m.Validator = &Validator{}
			}
			if err := m.Validator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetValidatorActiveSetChangesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetValidatorActiveSetChangesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetValidatorActiveSetChangesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QueryFilter = &GetValidatorActiveSetChangesRequest_Epoch{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Genesis", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.QueryFilter = &GetValidatorActiveSetChangesRequest_Genesis{b}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActiveSetChanges) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActiveSetChanges: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActiveSetChanges: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivatedPublicKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActivatedPublicKeys = append(m.ActivatedPublicKeys, make([]byte, postIndex-iNdEx))
			copy(m.ActivatedPublicKeys[len(m.ActivatedPublicKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ActivatedIndices = append(m.ActivatedIndices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBeaconChain
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBeaconChain
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ActivatedIndices) == 0 {
					m.ActivatedIndices = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ActivatedIndices = append(m.ActivatedIndices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivatedIndices", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitedPublicKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExitedPublicKeys = append(m.ExitedPublicKeys, make([]byte, postIndex-iNdEx))
			copy(m.ExitedPublicKeys[len(m.ExitedPublicKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ExitedIndices = append(m.ExitedIndices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBeaconChain
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBeaconChain
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ExitedIndices) == 0 {
					m.ExitedIndices = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ExitedIndices = append(m.ExitedIndices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitedIndices", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashedPublicKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlashedPublicKeys = append(m.SlashedPublicKeys, make([]byte, postIndex-iNdEx))
			copy(m.SlashedPublicKeys[len(m.SlashedPublicKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SlashedIndices = append(m.SlashedIndices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBeaconChain
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBeaconChain
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SlashedIndices) == 0 {
					m.SlashedIndices = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SlashedIndices = append(m.SlashedIndices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashedIndices", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EjectedPublicKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EjectedPublicKeys = append(m.EjectedPublicKeys, make([]byte, postIndex-iNdEx))
			copy(m.EjectedPublicKeys[len(m.EjectedPublicKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EjectedIndices = append(m.EjectedIndices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBeaconChain
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBeaconChain
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.EjectedIndices) == 0 {
					m.EjectedIndices = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EjectedIndices = append(m.EjectedIndices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EjectedIndices", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorPerformanceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorPerformanceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorPerformanceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKeys = append(m.PublicKeys, make([]byte, postIndex-iNdEx))
			copy(m.PublicKeys[len(m.PublicKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Indices = append(m.Indices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBeaconChain
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBeaconChain
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Indices) == 0 {
					m.Indices = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Indices = append(m.Indices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Indices", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorPerformanceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorPerformanceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorPerformanceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CurrentEffectiveBalances = append(m.CurrentEffectiveBalances, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBeaconChain
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBeaconChain
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CurrentEffectiveBalances) == 0 {
					m.CurrentEffectiveBalances = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CurrentEffectiveBalances = append(m.CurrentEffectiveBalances, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentEffectiveBalances", wireType)
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.InclusionSlots = append(m.InclusionSlots, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBeaconChain
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBeaconChain
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.InclusionSlots) == 0 {
					m.InclusionSlots = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.InclusionSlots = append(m.InclusionSlots, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field InclusionSlots", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.InclusionDistances = append(m.InclusionDistances, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBeaconChain
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBeaconChain
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.InclusionDistances) == 0 {
					m.InclusionDistances = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.InclusionDistances = append(m.InclusionDistances, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field InclusionDistances", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CorrectlyVotedSource = append(m.CorrectlyVotedSource, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBeaconChain
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBeaconChain
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.CorrectlyVotedSource) == 0 {
					m.CorrectlyVotedSource = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CorrectlyVotedSource = append(m.CorrectlyVotedSource, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CorrectlyVotedSource", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CorrectlyVotedTarget = append(m.CorrectlyVotedTarget, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBeaconChain
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBeaconChain
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.CorrectlyVotedTarget) == 0 {
					m.CorrectlyVotedTarget = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CorrectlyVotedTarget = append(m.CorrectlyVotedTarget, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CorrectlyVotedTarget", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CorrectlyVotedHead = append(m.CorrectlyVotedHead, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBeaconChain
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBeaconChain
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.CorrectlyVotedHead) == 0 {
					m.CorrectlyVotedHead = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CorrectlyVotedHead = append(m.CorrectlyVotedHead, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CorrectlyVotedHead", wireType)
			}
		case 7:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BalancesBeforeEpochTransition = append(m.BalancesBeforeEpochTransition, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBeaconChain
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBeaconChain
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BalancesBeforeEpochTransition) == 0 {
					m.BalancesBeforeEpochTransition = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BalancesBeforeEpochTransition = append(m.BalancesBeforeEpochTransition, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BalancesBeforeEpochTransition", wireType)
			}
		case 8:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BalancesAfterEpochTransition = append(m.BalancesAfterEpochTransition, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBeaconChain
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBeaconChain
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BalancesAfterEpochTransition) == 0 {
					m.BalancesAfterEpochTransition = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BalancesAfterEpochTransition = append(m.BalancesAfterEpochTransition, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BalancesAfterEpochTransition", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissingValidators", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MissingValidators = append(m.MissingValidators, make([]byte, postIndex-iNdEx))
			copy(m.MissingValidators[len(m.MissingValidators)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AverageActiveValidatorBalance", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.AverageActiveValidatorBalance = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorQueue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorQueue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorQueue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChurnLimit", wireType)
			}
			m.ChurnLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChurnLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivationPublicKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActivationPublicKeys = append(m.ActivationPublicKeys, make([]byte, postIndex-iNdEx))
			copy(m.ActivationPublicKeys[len(m.ActivationPublicKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitPublicKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExitPublicKeys = append(m.ExitPublicKeys, make([]byte, postIndex-iNdEx))
			copy(m.ExitPublicKeys[len(m.ExitPublicKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ActivationValidatorIndices = append(m.ActivationValidatorIndices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBeaconChain
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBeaconChain
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ActivationValidatorIndices) == 0 {
					m.ActivationValidatorIndices = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ActivationValidatorIndices = append(m.ActivationValidatorIndices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivationValidatorIndices", wireType)
			}
		case 5:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ExitValidatorIndices = append(m.ExitValidatorIndices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBeaconChain
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBeaconChain
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ExitValidatorIndices) == 0 {
					m.ExitValidatorIndices = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ExitValidatorIndices = append(m.ExitValidatorIndices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitValidatorIndices", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListValidatorAssignmentsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListValidatorAssignmentsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListValidatorAssignmentsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QueryFilter = &ListValidatorAssignmentsRequest_Epoch{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Genesis", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.QueryFilter = &ListValidatorAssignmentsRequest_Genesis{b}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKeys = append(m.PublicKeys, make([]byte, postIndex-iNdEx))
			copy(m.PublicKeys[len(m.PublicKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Indices = append(m.Indices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBeaconChain
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBeaconChain
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Indices) == 0 {
					m.Indices = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Indices = append(m.Indices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Indices", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorAssignments) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorAssignments: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorAssignments: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assignments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assignments = append(m.Assignments, &ValidatorAssignments_CommitteeAssignment{})
			if err := m.Assignments[len(m.Assignments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorAssignments_CommitteeAssignment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitteeAssignment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitteeAssignment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BeaconCommittees = append(m.BeaconCommittees, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBeaconChain
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBeaconChain
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.BeaconCommittees) == 0 {
					m.BeaconCommittees = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BeaconCommittees = append(m.BeaconCommittees, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BeaconCommittees", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitteeIndex", wireType)
			}
			m.CommitteeIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitteeIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttesterSlot", wireType)
			}
			m.AttesterSlot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttesterSlot |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ProposerSlots = append(m.ProposerSlots, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBeaconChain
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBeaconChain
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ProposerSlots) == 0 {
					m.ProposerSlots = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ProposerSlots = append(m.ProposerSlots, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposerSlots", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorIndex", wireType)
			}
			m.ValidatorIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidatorIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetValidatorParticipationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetValidatorParticipationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetValidatorParticipationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.QueryFilter = &GetValidatorParticipationRequest_Epoch{v}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Genesis", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.QueryFilter = &GetValidatorParticipationRequest_Genesis{b}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorParticipationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorParticipationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorParticipationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finalized", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Finalized = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Participation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Participation == nil {
				m.Participation = &ValidatorParticipation{}
			}
			if err := m.Participation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttestationPoolRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttestationPoolRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttestationPoolRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttestationPoolResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttestationPoolResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttestationPoolResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attestations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attestations = append(m.Attestations, &Attestation{})
			if err := m.Attestations[len(m.Attestations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BeaconConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BeaconConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BeaconConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChain
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBeaconChain
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBeaconChain
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthBeaconChain
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthBeaconChain
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBeaconChain(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthBeaconChain
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Config[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubmitSlashingResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubmitSlashingResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubmitSlashingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SlashedIndices = append(m.SlashedIndices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBeaconChain
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthBeaconChain
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.SlashedIndices) == 0 {
					m.SlashedIndices = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChain
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SlashedIndices = append(m.SlashedIndices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashedIndices", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChain(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChain
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBeaconChain(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBeaconChain
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBeaconChain
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBeaconChain
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthBeaconChain
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowBeaconChain
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipBeaconChain(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthBeaconChain
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthBeaconChain = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBeaconChain   = fmt.Errorf("proto: integer overflow")
)
