// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package eth

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// BeaconChainClient is the client API for BeaconChain service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BeaconChainClient interface {
	// Retrieve attestations by block root, slot, or epoch.
	//
	// The server may return an empty list when no attestations match the given
	// filter criteria. This RPC should not return NOT_FOUND. Only one filter
	// criteria should be used. This endpoint allows for retrieval of genesis
	// information via a boolean query filter.
	ListAttestations(ctx context.Context, in *ListAttestationsRequest, opts ...grpc.CallOption) (*ListAttestationsResponse, error)
	// Retrieve indexed attestations by block root, slot, or epoch.
	//
	// The server may return an empty list when no indexed attestations match the given
	// filter criteria. This RPC should not return NOT_FOUND. Only one filter
	// criteria should be used. This endpoint allows for retrieval of genesis
	// information via a boolean query filter.
	ListIndexedAttestations(ctx context.Context, in *ListIndexedAttestationsRequest, opts ...grpc.CallOption) (*ListIndexedAttestationsResponse, error)
	// Server-side stream of attestations as they are received by
	// the beacon chain node.
	StreamAttestations(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (BeaconChain_StreamAttestationsClient, error)
	// Server-side stream of indexed attestations as they are received by
	// the beacon chain node.
	StreamIndexedAttestations(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (BeaconChain_StreamIndexedAttestationsClient, error)
	// Retrieve attestations from pool.
	//
	// The server returns a list of attestations that have been seen but not
	// yet processed. Pool attestations eventually expire as the slot
	// advances, so an attestation missing from this request does not imply
	// that it was included in a block. The attestation may have expired.
	// Refer to the ethereum 2.0 specification for more details on how
	// attestations are processed and when they are no longer valid.
	// https://github.com/ethereum/eth2.0-specs/blob/dev/specs/core/0_beacon-chain.md#attestations
	AttestationPool(ctx context.Context, in *AttestationPoolRequest, opts ...grpc.CallOption) (*AttestationPoolResponse, error)
	// Retrieve blocks by root, slot, or epoch.
	//
	// The server may return multiple blocks in the case that a slot or epoch is
	// provided as the filter criteria. The server may return an empty list when
	// no blocks in their database match the filter criteria. This RPC should
	// not return NOT_FOUND. Only one filter criteria should be used. This endpoint
	// allows for retrieval of genesis information via a boolean query filter.
	ListBlocks(ctx context.Context, in *ListBlocksRequest, opts ...grpc.CallOption) (*ListBlocksResponse, error)
	// Server-side stream of all signed blocks as they are received by
	// the beacon chain node.
	StreamBlocks(ctx context.Context, in *StreamBlocksRequest, opts ...grpc.CallOption) (BeaconChain_StreamBlocksClient, error)
	// Server-side stream of information about the head of the beacon chain
	// from the view of the beacon chain node.
	//
	// This includes the head block slot and root as well as information about
	// the most recent finalized and justified slots.
	StreamChainHead(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (BeaconChain_StreamChainHeadClient, error)
	// Retrieve information about the head of the beacon chain from the view of
	// the beacon chain node.
	//
	// This includes the head block slot and root as well as information about
	// the most recent finalized and justified slots.
	GetChainHead(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ChainHead, error)
	// Retrieve information about the weak subjectivity of the beacon chain from the view of
	// the beacon chain node.
	//
	// This includes the weak subjectivity block root, state root and epoch number.
	GetWeakSubjectivityCheckpoint(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*WeakSubjectivityCheckpoint, error)
	// Retrieve the beacon chain committees for a given epoch.
	//
	// If no filter criteria is specified, the response returns
	// all beacon committees for the current epoch. The results are paginated by default.
	// This endpoint allows for retrieval of genesis information via a boolean query filter.
	ListBeaconCommittees(ctx context.Context, in *ListCommitteesRequest, opts ...grpc.CallOption) (*BeaconCommittees, error)
	// Retrieve validator balances for a given set of public keys at a specific
	// epoch in time. This endpoint allows for retrieval of genesis information
	// via a boolean query filter.
	ListValidatorBalances(ctx context.Context, in *ListValidatorBalancesRequest, opts ...grpc.CallOption) (*ValidatorBalances, error)
	// Retrieve the current validator registry.
	//
	// The request may include an optional historical epoch to retrieve a
	// specific validator set in time. This endpoint allows for retrieval of genesis
	// information via a boolean query filter.
	ListValidators(ctx context.Context, in *ListValidatorsRequest, opts ...grpc.CallOption) (*Validators, error)
	// Retrieve information about a specific validator in the registry.
	//
	// This request may query by validator index or public key.
	GetValidator(ctx context.Context, in *GetValidatorRequest, opts ...grpc.CallOption) (*Validator, error)
	// Retrieve the active set changes for a given epoch.
	//
	// This data includes any activations, voluntary exits, and involuntary
	// ejections. This endpoint allows for retrieval of genesis
	// information via a boolean query filter.
	GetValidatorActiveSetChanges(ctx context.Context, in *GetValidatorActiveSetChangesRequest, opts ...grpc.CallOption) (*ActiveSetChanges, error)
	// Retrieve the current validator queue information.
	GetValidatorQueue(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ValidatorQueue, error)
	// GetValidatorPerformance reports a validator's latest balance along with other important
	// metrics on rewards and penalties throughout its lifecycle in the beacon chain.
	// The request takes in a list of validator public keys and returns a performance report
	// for all of them respectively.
	GetValidatorPerformance(ctx context.Context, in *ValidatorPerformanceRequest, opts ...grpc.CallOption) (*ValidatorPerformanceResponse, error)
	// Retrieve the validator assignments for a given epoch.
	//
	// This request may specify optional validator indices or public keys to
	// filter validator assignments. This endpoint allows for retrieval of genesis
	// information via a boolean query filter.
	ListValidatorAssignments(ctx context.Context, in *ListValidatorAssignmentsRequest, opts ...grpc.CallOption) (*ValidatorAssignments, error)
	// Retrieve the validator participation information for a given epoch.
	//
	// This method returns information about the global participation of
	// validator attestations. This endpoint allows for retrieval of genesis
	// information via a boolean query filter.
	GetValidatorParticipation(ctx context.Context, in *GetValidatorParticipationRequest, opts ...grpc.CallOption) (*ValidatorParticipationResponse, error)
	// Retrieve the current configuration parameters of the beacon chain.
	GetBeaconConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*BeaconConfig, error)
	// Server-side stream of validator information at each epoch.
	StreamValidatorsInfo(ctx context.Context, opts ...grpc.CallOption) (BeaconChain_StreamValidatorsInfoClient, error)
	// Submit an attester slashing object to the beacon node.
	SubmitAttesterSlashing(ctx context.Context, in *AttesterSlashing, opts ...grpc.CallOption) (*SubmitSlashingResponse, error)
	// Submit a proposer slashing object to the beacon node.
	SubmitProposerSlashing(ctx context.Context, in *ProposerSlashing, opts ...grpc.CallOption) (*SubmitSlashingResponse, error)
	// Returns a list of validators individual vote status of a given epoch.
	GetIndividualVotes(ctx context.Context, in *IndividualVotesRequest, opts ...grpc.CallOption) (*IndividualVotesRespond, error)
}

type beaconChainClient struct {
	cc grpc.ClientConnInterface
}

func NewBeaconChainClient(cc grpc.ClientConnInterface) BeaconChainClient {
	return &beaconChainClient{cc}
}

func (c *beaconChainClient) ListAttestations(ctx context.Context, in *ListAttestationsRequest, opts ...grpc.CallOption) (*ListAttestationsResponse, error) {
	out := new(ListAttestationsResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/ListAttestations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListIndexedAttestations(ctx context.Context, in *ListIndexedAttestationsRequest, opts ...grpc.CallOption) (*ListIndexedAttestationsResponse, error) {
	out := new(ListIndexedAttestationsResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/ListIndexedAttestations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) StreamAttestations(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (BeaconChain_StreamAttestationsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_BeaconChain_serviceDesc.Streams[0], "/ethereum.eth.v1alpha1.BeaconChain/StreamAttestations", opts...)
	if err != nil {
		return nil, err
	}
	x := &beaconChainStreamAttestationsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BeaconChain_StreamAttestationsClient interface {
	Recv() (*Attestation, error)
	grpc.ClientStream
}

type beaconChainStreamAttestationsClient struct {
	grpc.ClientStream
}

func (x *beaconChainStreamAttestationsClient) Recv() (*Attestation, error) {
	m := new(Attestation)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *beaconChainClient) StreamIndexedAttestations(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (BeaconChain_StreamIndexedAttestationsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_BeaconChain_serviceDesc.Streams[1], "/ethereum.eth.v1alpha1.BeaconChain/StreamIndexedAttestations", opts...)
	if err != nil {
		return nil, err
	}
	x := &beaconChainStreamIndexedAttestationsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BeaconChain_StreamIndexedAttestationsClient interface {
	Recv() (*IndexedAttestation, error)
	grpc.ClientStream
}

type beaconChainStreamIndexedAttestationsClient struct {
	grpc.ClientStream
}

func (x *beaconChainStreamIndexedAttestationsClient) Recv() (*IndexedAttestation, error) {
	m := new(IndexedAttestation)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *beaconChainClient) AttestationPool(ctx context.Context, in *AttestationPoolRequest, opts ...grpc.CallOption) (*AttestationPoolResponse, error) {
	out := new(AttestationPoolResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/AttestationPool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListBlocks(ctx context.Context, in *ListBlocksRequest, opts ...grpc.CallOption) (*ListBlocksResponse, error) {
	out := new(ListBlocksResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/ListBlocks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) StreamBlocks(ctx context.Context, in *StreamBlocksRequest, opts ...grpc.CallOption) (BeaconChain_StreamBlocksClient, error) {
	stream, err := c.cc.NewStream(ctx, &_BeaconChain_serviceDesc.Streams[2], "/ethereum.eth.v1alpha1.BeaconChain/StreamBlocks", opts...)
	if err != nil {
		return nil, err
	}
	x := &beaconChainStreamBlocksClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BeaconChain_StreamBlocksClient interface {
	Recv() (*SignedBeaconBlock, error)
	grpc.ClientStream
}

type beaconChainStreamBlocksClient struct {
	grpc.ClientStream
}

func (x *beaconChainStreamBlocksClient) Recv() (*SignedBeaconBlock, error) {
	m := new(SignedBeaconBlock)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *beaconChainClient) StreamChainHead(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (BeaconChain_StreamChainHeadClient, error) {
	stream, err := c.cc.NewStream(ctx, &_BeaconChain_serviceDesc.Streams[3], "/ethereum.eth.v1alpha1.BeaconChain/StreamChainHead", opts...)
	if err != nil {
		return nil, err
	}
	x := &beaconChainStreamChainHeadClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BeaconChain_StreamChainHeadClient interface {
	Recv() (*ChainHead, error)
	grpc.ClientStream
}

type beaconChainStreamChainHeadClient struct {
	grpc.ClientStream
}

func (x *beaconChainStreamChainHeadClient) Recv() (*ChainHead, error) {
	m := new(ChainHead)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *beaconChainClient) GetChainHead(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ChainHead, error) {
	out := new(ChainHead)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/GetChainHead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetWeakSubjectivityCheckpoint(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*WeakSubjectivityCheckpoint, error) {
	out := new(WeakSubjectivityCheckpoint)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/GetWeakSubjectivityCheckpoint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListBeaconCommittees(ctx context.Context, in *ListCommitteesRequest, opts ...grpc.CallOption) (*BeaconCommittees, error) {
	out := new(BeaconCommittees)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/ListBeaconCommittees", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListValidatorBalances(ctx context.Context, in *ListValidatorBalancesRequest, opts ...grpc.CallOption) (*ValidatorBalances, error) {
	out := new(ValidatorBalances)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/ListValidatorBalances", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListValidators(ctx context.Context, in *ListValidatorsRequest, opts ...grpc.CallOption) (*Validators, error) {
	out := new(Validators)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/ListValidators", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetValidator(ctx context.Context, in *GetValidatorRequest, opts ...grpc.CallOption) (*Validator, error) {
	out := new(Validator)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/GetValidator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetValidatorActiveSetChanges(ctx context.Context, in *GetValidatorActiveSetChangesRequest, opts ...grpc.CallOption) (*ActiveSetChanges, error) {
	out := new(ActiveSetChanges)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/GetValidatorActiveSetChanges", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetValidatorQueue(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ValidatorQueue, error) {
	out := new(ValidatorQueue)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/GetValidatorQueue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetValidatorPerformance(ctx context.Context, in *ValidatorPerformanceRequest, opts ...grpc.CallOption) (*ValidatorPerformanceResponse, error) {
	out := new(ValidatorPerformanceResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/GetValidatorPerformance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListValidatorAssignments(ctx context.Context, in *ListValidatorAssignmentsRequest, opts ...grpc.CallOption) (*ValidatorAssignments, error) {
	out := new(ValidatorAssignments)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/ListValidatorAssignments", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetValidatorParticipation(ctx context.Context, in *GetValidatorParticipationRequest, opts ...grpc.CallOption) (*ValidatorParticipationResponse, error) {
	out := new(ValidatorParticipationResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/GetValidatorParticipation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetBeaconConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*BeaconConfig, error) {
	out := new(BeaconConfig)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/GetBeaconConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) StreamValidatorsInfo(ctx context.Context, opts ...grpc.CallOption) (BeaconChain_StreamValidatorsInfoClient, error) {
	stream, err := c.cc.NewStream(ctx, &_BeaconChain_serviceDesc.Streams[4], "/ethereum.eth.v1alpha1.BeaconChain/StreamValidatorsInfo", opts...)
	if err != nil {
		return nil, err
	}
	x := &beaconChainStreamValidatorsInfoClient{stream}
	return x, nil
}

type BeaconChain_StreamValidatorsInfoClient interface {
	Send(*ValidatorChangeSet) error
	Recv() (*ValidatorInfo, error)
	grpc.ClientStream
}

type beaconChainStreamValidatorsInfoClient struct {
	grpc.ClientStream
}

func (x *beaconChainStreamValidatorsInfoClient) Send(m *ValidatorChangeSet) error {
	return x.ClientStream.SendMsg(m)
}

func (x *beaconChainStreamValidatorsInfoClient) Recv() (*ValidatorInfo, error) {
	m := new(ValidatorInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *beaconChainClient) SubmitAttesterSlashing(ctx context.Context, in *AttesterSlashing, opts ...grpc.CallOption) (*SubmitSlashingResponse, error) {
	out := new(SubmitSlashingResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/SubmitAttesterSlashing", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) SubmitProposerSlashing(ctx context.Context, in *ProposerSlashing, opts ...grpc.CallOption) (*SubmitSlashingResponse, error) {
	out := new(SubmitSlashingResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/SubmitProposerSlashing", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetIndividualVotes(ctx context.Context, in *IndividualVotesRequest, opts ...grpc.CallOption) (*IndividualVotesRespond, error) {
	out := new(IndividualVotesRespond)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconChain/GetIndividualVotes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BeaconChainServer is the server API for BeaconChain service.
// All implementations must embed UnimplementedBeaconChainServer
// for forward compatibility
type BeaconChainServer interface {
	// Retrieve attestations by block root, slot, or epoch.
	//
	// The server may return an empty list when no attestations match the given
	// filter criteria. This RPC should not return NOT_FOUND. Only one filter
	// criteria should be used. This endpoint allows for retrieval of genesis
	// information via a boolean query filter.
	ListAttestations(context.Context, *ListAttestationsRequest) (*ListAttestationsResponse, error)
	// Retrieve indexed attestations by block root, slot, or epoch.
	//
	// The server may return an empty list when no indexed attestations match the given
	// filter criteria. This RPC should not return NOT_FOUND. Only one filter
	// criteria should be used. This endpoint allows for retrieval of genesis
	// information via a boolean query filter.
	ListIndexedAttestations(context.Context, *ListIndexedAttestationsRequest) (*ListIndexedAttestationsResponse, error)
	// Server-side stream of attestations as they are received by
	// the beacon chain node.
	StreamAttestations(*emptypb.Empty, BeaconChain_StreamAttestationsServer) error
	// Server-side stream of indexed attestations as they are received by
	// the beacon chain node.
	StreamIndexedAttestations(*emptypb.Empty, BeaconChain_StreamIndexedAttestationsServer) error
	// Retrieve attestations from pool.
	//
	// The server returns a list of attestations that have been seen but not
	// yet processed. Pool attestations eventually expire as the slot
	// advances, so an attestation missing from this request does not imply
	// that it was included in a block. The attestation may have expired.
	// Refer to the ethereum 2.0 specification for more details on how
	// attestations are processed and when they are no longer valid.
	// https://github.com/ethereum/eth2.0-specs/blob/dev/specs/core/0_beacon-chain.md#attestations
	AttestationPool(context.Context, *AttestationPoolRequest) (*AttestationPoolResponse, error)
	// Retrieve blocks by root, slot, or epoch.
	//
	// The server may return multiple blocks in the case that a slot or epoch is
	// provided as the filter criteria. The server may return an empty list when
	// no blocks in their database match the filter criteria. This RPC should
	// not return NOT_FOUND. Only one filter criteria should be used. This endpoint
	// allows for retrieval of genesis information via a boolean query filter.
	ListBlocks(context.Context, *ListBlocksRequest) (*ListBlocksResponse, error)
	// Server-side stream of all signed blocks as they are received by
	// the beacon chain node.
	StreamBlocks(*StreamBlocksRequest, BeaconChain_StreamBlocksServer) error
	// Server-side stream of information about the head of the beacon chain
	// from the view of the beacon chain node.
	//
	// This includes the head block slot and root as well as information about
	// the most recent finalized and justified slots.
	StreamChainHead(*emptypb.Empty, BeaconChain_StreamChainHeadServer) error
	// Retrieve information about the head of the beacon chain from the view of
	// the beacon chain node.
	//
	// This includes the head block slot and root as well as information about
	// the most recent finalized and justified slots.
	GetChainHead(context.Context, *emptypb.Empty) (*ChainHead, error)
	// Retrieve information about the weak subjectivity of the beacon chain from the view of
	// the beacon chain node.
	//
	// This includes the weak subjectivity block root, state root and epoch number.
	GetWeakSubjectivityCheckpoint(context.Context, *emptypb.Empty) (*WeakSubjectivityCheckpoint, error)
	// Retrieve the beacon chain committees for a given epoch.
	//
	// If no filter criteria is specified, the response returns
	// all beacon committees for the current epoch. The results are paginated by default.
	// This endpoint allows for retrieval of genesis information via a boolean query filter.
	ListBeaconCommittees(context.Context, *ListCommitteesRequest) (*BeaconCommittees, error)
	// Retrieve validator balances for a given set of public keys at a specific
	// epoch in time. This endpoint allows for retrieval of genesis information
	// via a boolean query filter.
	ListValidatorBalances(context.Context, *ListValidatorBalancesRequest) (*ValidatorBalances, error)
	// Retrieve the current validator registry.
	//
	// The request may include an optional historical epoch to retrieve a
	// specific validator set in time. This endpoint allows for retrieval of genesis
	// information via a boolean query filter.
	ListValidators(context.Context, *ListValidatorsRequest) (*Validators, error)
	// Retrieve information about a specific validator in the registry.
	//
	// This request may query by validator index or public key.
	GetValidator(context.Context, *GetValidatorRequest) (*Validator, error)
	// Retrieve the active set changes for a given epoch.
	//
	// This data includes any activations, voluntary exits, and involuntary
	// ejections. This endpoint allows for retrieval of genesis
	// information via a boolean query filter.
	GetValidatorActiveSetChanges(context.Context, *GetValidatorActiveSetChangesRequest) (*ActiveSetChanges, error)
	// Retrieve the current validator queue information.
	GetValidatorQueue(context.Context, *emptypb.Empty) (*ValidatorQueue, error)
	// GetValidatorPerformance reports a validator's latest balance along with other important
	// metrics on rewards and penalties throughout its lifecycle in the beacon chain.
	// The request takes in a list of validator public keys and returns a performance report
	// for all of them respectively.
	GetValidatorPerformance(context.Context, *ValidatorPerformanceRequest) (*ValidatorPerformanceResponse, error)
	// Retrieve the validator assignments for a given epoch.
	//
	// This request may specify optional validator indices or public keys to
	// filter validator assignments. This endpoint allows for retrieval of genesis
	// information via a boolean query filter.
	ListValidatorAssignments(context.Context, *ListValidatorAssignmentsRequest) (*ValidatorAssignments, error)
	// Retrieve the validator participation information for a given epoch.
	//
	// This method returns information about the global participation of
	// validator attestations. This endpoint allows for retrieval of genesis
	// information via a boolean query filter.
	GetValidatorParticipation(context.Context, *GetValidatorParticipationRequest) (*ValidatorParticipationResponse, error)
	// Retrieve the current configuration parameters of the beacon chain.
	GetBeaconConfig(context.Context, *emptypb.Empty) (*BeaconConfig, error)
	// Server-side stream of validator information at each epoch.
	StreamValidatorsInfo(BeaconChain_StreamValidatorsInfoServer) error
	// Submit an attester slashing object to the beacon node.
	SubmitAttesterSlashing(context.Context, *AttesterSlashing) (*SubmitSlashingResponse, error)
	// Submit a proposer slashing object to the beacon node.
	SubmitProposerSlashing(context.Context, *ProposerSlashing) (*SubmitSlashingResponse, error)
	// Returns a list of validators individual vote status of a given epoch.
	GetIndividualVotes(context.Context, *IndividualVotesRequest) (*IndividualVotesRespond, error)
	mustEmbedUnimplementedBeaconChainServer()
}

// UnimplementedBeaconChainServer must be embedded to have forward compatible implementations.
type UnimplementedBeaconChainServer struct {
}

func (UnimplementedBeaconChainServer) ListAttestations(context.Context, *ListAttestationsRequest) (*ListAttestationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAttestations not implemented")
}
func (UnimplementedBeaconChainServer) ListIndexedAttestations(context.Context, *ListIndexedAttestationsRequest) (*ListIndexedAttestationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListIndexedAttestations not implemented")
}
func (UnimplementedBeaconChainServer) StreamAttestations(*emptypb.Empty, BeaconChain_StreamAttestationsServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamAttestations not implemented")
}
func (UnimplementedBeaconChainServer) StreamIndexedAttestations(*emptypb.Empty, BeaconChain_StreamIndexedAttestationsServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamIndexedAttestations not implemented")
}
func (UnimplementedBeaconChainServer) AttestationPool(context.Context, *AttestationPoolRequest) (*AttestationPoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AttestationPool not implemented")
}
func (UnimplementedBeaconChainServer) ListBlocks(context.Context, *ListBlocksRequest) (*ListBlocksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBlocks not implemented")
}
func (UnimplementedBeaconChainServer) StreamBlocks(*StreamBlocksRequest, BeaconChain_StreamBlocksServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamBlocks not implemented")
}
func (UnimplementedBeaconChainServer) StreamChainHead(*emptypb.Empty, BeaconChain_StreamChainHeadServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamChainHead not implemented")
}
func (UnimplementedBeaconChainServer) GetChainHead(context.Context, *emptypb.Empty) (*ChainHead, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetChainHead not implemented")
}
func (UnimplementedBeaconChainServer) GetWeakSubjectivityCheckpoint(context.Context, *emptypb.Empty) (*WeakSubjectivityCheckpoint, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWeakSubjectivityCheckpoint not implemented")
}
func (UnimplementedBeaconChainServer) ListBeaconCommittees(context.Context, *ListCommitteesRequest) (*BeaconCommittees, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBeaconCommittees not implemented")
}
func (UnimplementedBeaconChainServer) ListValidatorBalances(context.Context, *ListValidatorBalancesRequest) (*ValidatorBalances, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListValidatorBalances not implemented")
}
func (UnimplementedBeaconChainServer) ListValidators(context.Context, *ListValidatorsRequest) (*Validators, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListValidators not implemented")
}
func (UnimplementedBeaconChainServer) GetValidator(context.Context, *GetValidatorRequest) (*Validator, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetValidator not implemented")
}
func (UnimplementedBeaconChainServer) GetValidatorActiveSetChanges(context.Context, *GetValidatorActiveSetChangesRequest) (*ActiveSetChanges, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetValidatorActiveSetChanges not implemented")
}
func (UnimplementedBeaconChainServer) GetValidatorQueue(context.Context, *emptypb.Empty) (*ValidatorQueue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetValidatorQueue not implemented")
}
func (UnimplementedBeaconChainServer) GetValidatorPerformance(context.Context, *ValidatorPerformanceRequest) (*ValidatorPerformanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetValidatorPerformance not implemented")
}
func (UnimplementedBeaconChainServer) ListValidatorAssignments(context.Context, *ListValidatorAssignmentsRequest) (*ValidatorAssignments, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListValidatorAssignments not implemented")
}
func (UnimplementedBeaconChainServer) GetValidatorParticipation(context.Context, *GetValidatorParticipationRequest) (*ValidatorParticipationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetValidatorParticipation not implemented")
}
func (UnimplementedBeaconChainServer) GetBeaconConfig(context.Context, *emptypb.Empty) (*BeaconConfig, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBeaconConfig not implemented")
}
func (UnimplementedBeaconChainServer) StreamValidatorsInfo(BeaconChain_StreamValidatorsInfoServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamValidatorsInfo not implemented")
}
func (UnimplementedBeaconChainServer) SubmitAttesterSlashing(context.Context, *AttesterSlashing) (*SubmitSlashingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitAttesterSlashing not implemented")
}
func (UnimplementedBeaconChainServer) SubmitProposerSlashing(context.Context, *ProposerSlashing) (*SubmitSlashingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitProposerSlashing not implemented")
}
func (UnimplementedBeaconChainServer) GetIndividualVotes(context.Context, *IndividualVotesRequest) (*IndividualVotesRespond, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIndividualVotes not implemented")
}
func (UnimplementedBeaconChainServer) mustEmbedUnimplementedBeaconChainServer() {}

// UnsafeBeaconChainServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BeaconChainServer will
// result in compilation errors.
type UnsafeBeaconChainServer interface {
	mustEmbedUnimplementedBeaconChainServer()
}

func RegisterBeaconChainServer(s *grpc.Server, srv BeaconChainServer) {
	s.RegisterService(&_BeaconChain_serviceDesc, srv)
}

func _BeaconChain_ListAttestations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAttestationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListAttestations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/ListAttestations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListAttestations(ctx, req.(*ListAttestationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListIndexedAttestations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListIndexedAttestationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListIndexedAttestations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/ListIndexedAttestations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListIndexedAttestations(ctx, req.(*ListIndexedAttestationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_StreamAttestations_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BeaconChainServer).StreamAttestations(m, &beaconChainStreamAttestationsServer{stream})
}

type BeaconChain_StreamAttestationsServer interface {
	Send(*Attestation) error
	grpc.ServerStream
}

type beaconChainStreamAttestationsServer struct {
	grpc.ServerStream
}

func (x *beaconChainStreamAttestationsServer) Send(m *Attestation) error {
	return x.ServerStream.SendMsg(m)
}

func _BeaconChain_StreamIndexedAttestations_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BeaconChainServer).StreamIndexedAttestations(m, &beaconChainStreamIndexedAttestationsServer{stream})
}

type BeaconChain_StreamIndexedAttestationsServer interface {
	Send(*IndexedAttestation) error
	grpc.ServerStream
}

type beaconChainStreamIndexedAttestationsServer struct {
	grpc.ServerStream
}

func (x *beaconChainStreamIndexedAttestationsServer) Send(m *IndexedAttestation) error {
	return x.ServerStream.SendMsg(m)
}

func _BeaconChain_AttestationPool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttestationPoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).AttestationPool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/AttestationPool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).AttestationPool(ctx, req.(*AttestationPoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListBlocks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBlocksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListBlocks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/ListBlocks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListBlocks(ctx, req.(*ListBlocksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_StreamBlocks_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamBlocksRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BeaconChainServer).StreamBlocks(m, &beaconChainStreamBlocksServer{stream})
}

type BeaconChain_StreamBlocksServer interface {
	Send(*SignedBeaconBlock) error
	grpc.ServerStream
}

type beaconChainStreamBlocksServer struct {
	grpc.ServerStream
}

func (x *beaconChainStreamBlocksServer) Send(m *SignedBeaconBlock) error {
	return x.ServerStream.SendMsg(m)
}

func _BeaconChain_StreamChainHead_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BeaconChainServer).StreamChainHead(m, &beaconChainStreamChainHeadServer{stream})
}

type BeaconChain_StreamChainHeadServer interface {
	Send(*ChainHead) error
	grpc.ServerStream
}

type beaconChainStreamChainHeadServer struct {
	grpc.ServerStream
}

func (x *beaconChainStreamChainHeadServer) Send(m *ChainHead) error {
	return x.ServerStream.SendMsg(m)
}

func _BeaconChain_GetChainHead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetChainHead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/GetChainHead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetChainHead(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetWeakSubjectivityCheckpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetWeakSubjectivityCheckpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/GetWeakSubjectivityCheckpoint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetWeakSubjectivityCheckpoint(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListBeaconCommittees_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCommitteesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListBeaconCommittees(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/ListBeaconCommittees",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListBeaconCommittees(ctx, req.(*ListCommitteesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListValidatorBalances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListValidatorBalancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListValidatorBalances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/ListValidatorBalances",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListValidatorBalances(ctx, req.(*ListValidatorBalancesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListValidators_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListValidatorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListValidators(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/ListValidators",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListValidators(ctx, req.(*ListValidatorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetValidator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetValidatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetValidator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/GetValidator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetValidator(ctx, req.(*GetValidatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetValidatorActiveSetChanges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetValidatorActiveSetChangesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetValidatorActiveSetChanges(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/GetValidatorActiveSetChanges",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetValidatorActiveSetChanges(ctx, req.(*GetValidatorActiveSetChangesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetValidatorQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetValidatorQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/GetValidatorQueue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetValidatorQueue(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetValidatorPerformance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidatorPerformanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetValidatorPerformance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/GetValidatorPerformance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetValidatorPerformance(ctx, req.(*ValidatorPerformanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListValidatorAssignments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListValidatorAssignmentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListValidatorAssignments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/ListValidatorAssignments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListValidatorAssignments(ctx, req.(*ListValidatorAssignmentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetValidatorParticipation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetValidatorParticipationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetValidatorParticipation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/GetValidatorParticipation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetValidatorParticipation(ctx, req.(*GetValidatorParticipationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetBeaconConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetBeaconConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/GetBeaconConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetBeaconConfig(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_StreamValidatorsInfo_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BeaconChainServer).StreamValidatorsInfo(&beaconChainStreamValidatorsInfoServer{stream})
}

type BeaconChain_StreamValidatorsInfoServer interface {
	Send(*ValidatorInfo) error
	Recv() (*ValidatorChangeSet, error)
	grpc.ServerStream
}

type beaconChainStreamValidatorsInfoServer struct {
	grpc.ServerStream
}

func (x *beaconChainStreamValidatorsInfoServer) Send(m *ValidatorInfo) error {
	return x.ServerStream.SendMsg(m)
}

func (x *beaconChainStreamValidatorsInfoServer) Recv() (*ValidatorChangeSet, error) {
	m := new(ValidatorChangeSet)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _BeaconChain_SubmitAttesterSlashing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttesterSlashing)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).SubmitAttesterSlashing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/SubmitAttesterSlashing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).SubmitAttesterSlashing(ctx, req.(*AttesterSlashing))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_SubmitProposerSlashing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProposerSlashing)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).SubmitProposerSlashing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/SubmitProposerSlashing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).SubmitProposerSlashing(ctx, req.(*ProposerSlashing))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetIndividualVotes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndividualVotesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetIndividualVotes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconChain/GetIndividualVotes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetIndividualVotes(ctx, req.(*IndividualVotesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _BeaconChain_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ethereum.eth.v1alpha1.BeaconChain",
	HandlerType: (*BeaconChainServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListAttestations",
			Handler:    _BeaconChain_ListAttestations_Handler,
		},
		{
			MethodName: "ListIndexedAttestations",
			Handler:    _BeaconChain_ListIndexedAttestations_Handler,
		},
		{
			MethodName: "AttestationPool",
			Handler:    _BeaconChain_AttestationPool_Handler,
		},
		{
			MethodName: "ListBlocks",
			Handler:    _BeaconChain_ListBlocks_Handler,
		},
		{
			MethodName: "GetChainHead",
			Handler:    _BeaconChain_GetChainHead_Handler,
		},
		{
			MethodName: "GetWeakSubjectivityCheckpoint",
			Handler:    _BeaconChain_GetWeakSubjectivityCheckpoint_Handler,
		},
		{
			MethodName: "ListBeaconCommittees",
			Handler:    _BeaconChain_ListBeaconCommittees_Handler,
		},
		{
			MethodName: "ListValidatorBalances",
			Handler:    _BeaconChain_ListValidatorBalances_Handler,
		},
		{
			MethodName: "ListValidators",
			Handler:    _BeaconChain_ListValidators_Handler,
		},
		{
			MethodName: "GetValidator",
			Handler:    _BeaconChain_GetValidator_Handler,
		},
		{
			MethodName: "GetValidatorActiveSetChanges",
			Handler:    _BeaconChain_GetValidatorActiveSetChanges_Handler,
		},
		{
			MethodName: "GetValidatorQueue",
			Handler:    _BeaconChain_GetValidatorQueue_Handler,
		},
		{
			MethodName: "GetValidatorPerformance",
			Handler:    _BeaconChain_GetValidatorPerformance_Handler,
		},
		{
			MethodName: "ListValidatorAssignments",
			Handler:    _BeaconChain_ListValidatorAssignments_Handler,
		},
		{
			MethodName: "GetValidatorParticipation",
			Handler:    _BeaconChain_GetValidatorParticipation_Handler,
		},
		{
			MethodName: "GetBeaconConfig",
			Handler:    _BeaconChain_GetBeaconConfig_Handler,
		},
		{
			MethodName: "SubmitAttesterSlashing",
			Handler:    _BeaconChain_SubmitAttesterSlashing_Handler,
		},
		{
			MethodName: "SubmitProposerSlashing",
			Handler:    _BeaconChain_SubmitProposerSlashing_Handler,
		},
		{
			MethodName: "GetIndividualVotes",
			Handler:    _BeaconChain_GetIndividualVotes_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamAttestations",
			Handler:       _BeaconChain_StreamAttestations_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamIndexedAttestations",
			Handler:       _BeaconChain_StreamIndexedAttestations_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamBlocks",
			Handler:       _BeaconChain_StreamBlocks_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamChainHead",
			Handler:       _BeaconChain_StreamChainHead_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamValidatorsInfo",
			Handler:       _BeaconChain_StreamValidatorsInfo_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "eth/v1alpha1/beacon_chain.proto",
}
