// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package eth

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// BeaconNodeValidatorClient is the client API for BeaconNodeValidator service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BeaconNodeValidatorClient interface {
	// Retrieves validator duties for the requested validators.
	//
	// The duties consist of:
	//   Proposer - the validator that creates a beacon chain block.
	//   Attester — a validator that is part of a committee that needs to sign off on a beacon chain
	//    block while simultaneously creating a cross link to a recent shard block on a particular shard chain.
	// The server returns a list of duties which are the actions should be performed by validators for a given epoch.
	// Validator duties should be polled every epoch, but due to chain reorg of >MIN_SEED_LOOKAHEAD could occur,
	// the validator duties could chain. For complete safety, it is recommended to poll at every slot to ensure
	// validator is fully aware of any sudden chain reorg.
	GetDuties(ctx context.Context, in *DutiesRequest, opts ...grpc.CallOption) (*DutiesResponse, error)
	// Stream validator duties for the requested validators.
	//
	// The duties consist of:
	//   Proposer - the validator that creates a beacon chain block.
	//   Attester — a validator that is part of a committee that needs to sign off on a beacon chain
	StreamDuties(ctx context.Context, in *DutiesRequest, opts ...grpc.CallOption) (BeaconNodeValidator_StreamDutiesClient, error)
	// DomainData fetches the current BLS signature domain version information from the
	// running beacon node's state. This information is used when validators sign
	// blocks and attestations appropriately based on their duty.
	DomainData(ctx context.Context, in *DomainRequest, opts ...grpc.CallOption) (*DomainResponse, error)
	// Deprecated: Do not use.
	// WaitForChainStart queries the logs of the Validator Deposit Contract on the Ethereum
	// proof-of-work chain to verify the beacon chain has started its runtime and
	// validators are ready to begin their responsibilities.
	//
	// If the chain has not yet started, this endpoint starts a server-side stream which updates
	// the client when the beacon chain is ready.
	WaitForChainStart(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (BeaconNodeValidator_WaitForChainStartClient, error)
	// WaitForActivation checks if a validator public key exists in the active validator
	// registry of the current beacon state. If the validator is NOT yet active, it starts a
	// server-side stream which updates the client whenever the validator becomes active in
	// the beacon node's state.
	//
	// The input to this endpoint is a list of validator public keys, and the corresponding
	// stream will respond until at least a single corresponding validator to those
	// keys is activated.
	WaitForActivation(ctx context.Context, in *ValidatorActivationRequest, opts ...grpc.CallOption) (BeaconNodeValidator_WaitForActivationClient, error)
	// ValidatorIndex retrieves a validator's index location in the beacon state's
	// validator registry looking up whether the validator exists based on its
	// public key. This method returns NOT_FOUND if no index is found for the public key
	// specified in the request.
	ValidatorIndex(ctx context.Context, in *ValidatorIndexRequest, opts ...grpc.CallOption) (*ValidatorIndexResponse, error)
	// ValidatorStatus returns a validator's status based on the current epoch.
	// The request can specify either a validator's public key or validator index.
	//
	// The status response can be one of the following:
	//	DEPOSITED - validator's deposit has been recognized by Ethereum 1, not yet recognized by Ethereum 2.
	//	PENDING - validator is in Ethereum 2's activation queue.
	//	ACTIVE - validator is active.
	//	EXITING - validator has initiated an an exit request, or has dropped below the ejection balance and is being kicked out.
	//	EXITED - validator is no longer validating.
	//	SLASHING - validator has been kicked out due to meeting a slashing condition.
	//	UNKNOWN_STATUS - validator does not have a known status in the network.
	ValidatorStatus(ctx context.Context, in *ValidatorStatusRequest, opts ...grpc.CallOption) (*ValidatorStatusResponse, error)
	// MultipleValidatorStatus returns a list of validator statuses on the current epoch.
	// The request can specify a list of validator public keys.
	//
	// Returns a list of ValidatorStatusResponses.
	MultipleValidatorStatus(ctx context.Context, in *MultipleValidatorStatusRequest, opts ...grpc.CallOption) (*MultipleValidatorStatusResponse, error)
	// Retrieves the latest valid beacon block to be proposed on the beacon chain.
	//
	// The server returns a new beacon block, without proposer signature, that can be
	// proposed on the beacon chain. The block should be filled with all the necessary
	// data for proposer to sign.
	GetBlock(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BeaconBlock, error)
	// Sends the newly signed beacon block to beacon node.
	//
	// The validator sends the newly signed beacon block to the beacon node so the beacon block can
	// be included in the beacon chain. The beacon node is expected to validate and process the
	// beacon block into its state.
	ProposeBlock(ctx context.Context, in *SignedBeaconBlock, opts ...grpc.CallOption) (*ProposeResponse, error)
	// Retrieves the latest valid attestation data to be attested on the beacon chain.
	//
	// The server returns the latest valid data which represents the correct vote
	// for the head of the beacon chain,
	GetAttestationData(ctx context.Context, in *AttestationDataRequest, opts ...grpc.CallOption) (*AttestationData, error)
	// Sends the newly signed attestation to beacon node.
	//
	// The validator sends the newly signed attestation to the beacon node for the attestation to
	// be included in the beacon chain. The beacon node is expected to validate and publish attestation on
	// appropriate committee subnet.
	ProposeAttestation(ctx context.Context, in *Attestation, opts ...grpc.CallOption) (*AttestResponse, error)
	// Submit selection proof to the beacon node to aggregate all matching wire attestations with the same data root.
	// the beacon node responses with an aggregate and proof object back to validator to sign over.
	SubmitAggregateSelectionProof(ctx context.Context, in *AggregateSelectionRequest, opts ...grpc.CallOption) (*AggregateSelectionResponse, error)
	// Submit a signed aggregate and proof object, the beacon node will broadcast the
	// signed aggregated attestation and proof object.
	SubmitSignedAggregateSelectionProof(ctx context.Context, in *SignedAggregateSubmitRequest, opts ...grpc.CallOption) (*SignedAggregateSubmitResponse, error)
	// Propose to leave the list of active validators.
	//
	// The beacon node is expected to validate the request and make it available for inclusion in
	// the next proposed block.
	ProposeExit(ctx context.Context, in *SignedVoluntaryExit, opts ...grpc.CallOption) (*ProposeExitResponse, error)
	// Subscribe to particular committee ID subnets given validator's duty.
	//
	// The beacon node is expected to subscribe to the committee ID subnet given by the request. With this,
	// beacon node serving attesters can find persistent peers on the subnet to publish attestation,
	// and beacon node serving aggregator can join the subnet.
	SubscribeCommitteeSubnets(ctx context.Context, in *CommitteeSubnetsSubscribeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type beaconNodeValidatorClient struct {
	cc grpc.ClientConnInterface
}

func NewBeaconNodeValidatorClient(cc grpc.ClientConnInterface) BeaconNodeValidatorClient {
	return &beaconNodeValidatorClient{cc}
}

func (c *beaconNodeValidatorClient) GetDuties(ctx context.Context, in *DutiesRequest, opts ...grpc.CallOption) (*DutiesResponse, error) {
	out := new(DutiesResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconNodeValidator/GetDuties", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconNodeValidatorClient) StreamDuties(ctx context.Context, in *DutiesRequest, opts ...grpc.CallOption) (BeaconNodeValidator_StreamDutiesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_BeaconNodeValidator_serviceDesc.Streams[0], "/ethereum.eth.v1alpha1.BeaconNodeValidator/StreamDuties", opts...)
	if err != nil {
		return nil, err
	}
	x := &beaconNodeValidatorStreamDutiesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BeaconNodeValidator_StreamDutiesClient interface {
	Recv() (*DutiesResponse, error)
	grpc.ClientStream
}

type beaconNodeValidatorStreamDutiesClient struct {
	grpc.ClientStream
}

func (x *beaconNodeValidatorStreamDutiesClient) Recv() (*DutiesResponse, error) {
	m := new(DutiesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *beaconNodeValidatorClient) DomainData(ctx context.Context, in *DomainRequest, opts ...grpc.CallOption) (*DomainResponse, error) {
	out := new(DomainResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconNodeValidator/DomainData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Deprecated: Do not use.
func (c *beaconNodeValidatorClient) WaitForChainStart(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (BeaconNodeValidator_WaitForChainStartClient, error) {
	stream, err := c.cc.NewStream(ctx, &_BeaconNodeValidator_serviceDesc.Streams[1], "/ethereum.eth.v1alpha1.BeaconNodeValidator/WaitForChainStart", opts...)
	if err != nil {
		return nil, err
	}
	x := &beaconNodeValidatorWaitForChainStartClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BeaconNodeValidator_WaitForChainStartClient interface {
	Recv() (*ChainStartResponse, error)
	grpc.ClientStream
}

type beaconNodeValidatorWaitForChainStartClient struct {
	grpc.ClientStream
}

func (x *beaconNodeValidatorWaitForChainStartClient) Recv() (*ChainStartResponse, error) {
	m := new(ChainStartResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *beaconNodeValidatorClient) WaitForActivation(ctx context.Context, in *ValidatorActivationRequest, opts ...grpc.CallOption) (BeaconNodeValidator_WaitForActivationClient, error) {
	stream, err := c.cc.NewStream(ctx, &_BeaconNodeValidator_serviceDesc.Streams[2], "/ethereum.eth.v1alpha1.BeaconNodeValidator/WaitForActivation", opts...)
	if err != nil {
		return nil, err
	}
	x := &beaconNodeValidatorWaitForActivationClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BeaconNodeValidator_WaitForActivationClient interface {
	Recv() (*ValidatorActivationResponse, error)
	grpc.ClientStream
}

type beaconNodeValidatorWaitForActivationClient struct {
	grpc.ClientStream
}

func (x *beaconNodeValidatorWaitForActivationClient) Recv() (*ValidatorActivationResponse, error) {
	m := new(ValidatorActivationResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *beaconNodeValidatorClient) ValidatorIndex(ctx context.Context, in *ValidatorIndexRequest, opts ...grpc.CallOption) (*ValidatorIndexResponse, error) {
	out := new(ValidatorIndexResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconNodeValidator/ValidatorIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconNodeValidatorClient) ValidatorStatus(ctx context.Context, in *ValidatorStatusRequest, opts ...grpc.CallOption) (*ValidatorStatusResponse, error) {
	out := new(ValidatorStatusResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconNodeValidator/ValidatorStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconNodeValidatorClient) MultipleValidatorStatus(ctx context.Context, in *MultipleValidatorStatusRequest, opts ...grpc.CallOption) (*MultipleValidatorStatusResponse, error) {
	out := new(MultipleValidatorStatusResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconNodeValidator/MultipleValidatorStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconNodeValidatorClient) GetBlock(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BeaconBlock, error) {
	out := new(BeaconBlock)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconNodeValidator/GetBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconNodeValidatorClient) ProposeBlock(ctx context.Context, in *SignedBeaconBlock, opts ...grpc.CallOption) (*ProposeResponse, error) {
	out := new(ProposeResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconNodeValidator/ProposeBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconNodeValidatorClient) GetAttestationData(ctx context.Context, in *AttestationDataRequest, opts ...grpc.CallOption) (*AttestationData, error) {
	out := new(AttestationData)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconNodeValidator/GetAttestationData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconNodeValidatorClient) ProposeAttestation(ctx context.Context, in *Attestation, opts ...grpc.CallOption) (*AttestResponse, error) {
	out := new(AttestResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconNodeValidator/ProposeAttestation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconNodeValidatorClient) SubmitAggregateSelectionProof(ctx context.Context, in *AggregateSelectionRequest, opts ...grpc.CallOption) (*AggregateSelectionResponse, error) {
	out := new(AggregateSelectionResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconNodeValidator/SubmitAggregateSelectionProof", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconNodeValidatorClient) SubmitSignedAggregateSelectionProof(ctx context.Context, in *SignedAggregateSubmitRequest, opts ...grpc.CallOption) (*SignedAggregateSubmitResponse, error) {
	out := new(SignedAggregateSubmitResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconNodeValidator/SubmitSignedAggregateSelectionProof", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconNodeValidatorClient) ProposeExit(ctx context.Context, in *SignedVoluntaryExit, opts ...grpc.CallOption) (*ProposeExitResponse, error) {
	out := new(ProposeExitResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconNodeValidator/ProposeExit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconNodeValidatorClient) SubscribeCommitteeSubnets(ctx context.Context, in *CommitteeSubnetsSubscribeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1alpha1.BeaconNodeValidator/SubscribeCommitteeSubnets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BeaconNodeValidatorServer is the server API for BeaconNodeValidator service.
// All implementations must embed UnimplementedBeaconNodeValidatorServer
// for forward compatibility
type BeaconNodeValidatorServer interface {
	// Retrieves validator duties for the requested validators.
	//
	// The duties consist of:
	//   Proposer - the validator that creates a beacon chain block.
	//   Attester — a validator that is part of a committee that needs to sign off on a beacon chain
	//    block while simultaneously creating a cross link to a recent shard block on a particular shard chain.
	// The server returns a list of duties which are the actions should be performed by validators for a given epoch.
	// Validator duties should be polled every epoch, but due to chain reorg of >MIN_SEED_LOOKAHEAD could occur,
	// the validator duties could chain. For complete safety, it is recommended to poll at every slot to ensure
	// validator is fully aware of any sudden chain reorg.
	GetDuties(context.Context, *DutiesRequest) (*DutiesResponse, error)
	// Stream validator duties for the requested validators.
	//
	// The duties consist of:
	//   Proposer - the validator that creates a beacon chain block.
	//   Attester — a validator that is part of a committee that needs to sign off on a beacon chain
	StreamDuties(*DutiesRequest, BeaconNodeValidator_StreamDutiesServer) error
	// DomainData fetches the current BLS signature domain version information from the
	// running beacon node's state. This information is used when validators sign
	// blocks and attestations appropriately based on their duty.
	DomainData(context.Context, *DomainRequest) (*DomainResponse, error)
	// Deprecated: Do not use.
	// WaitForChainStart queries the logs of the Validator Deposit Contract on the Ethereum
	// proof-of-work chain to verify the beacon chain has started its runtime and
	// validators are ready to begin their responsibilities.
	//
	// If the chain has not yet started, this endpoint starts a server-side stream which updates
	// the client when the beacon chain is ready.
	WaitForChainStart(*emptypb.Empty, BeaconNodeValidator_WaitForChainStartServer) error
	// WaitForActivation checks if a validator public key exists in the active validator
	// registry of the current beacon state. If the validator is NOT yet active, it starts a
	// server-side stream which updates the client whenever the validator becomes active in
	// the beacon node's state.
	//
	// The input to this endpoint is a list of validator public keys, and the corresponding
	// stream will respond until at least a single corresponding validator to those
	// keys is activated.
	WaitForActivation(*ValidatorActivationRequest, BeaconNodeValidator_WaitForActivationServer) error
	// ValidatorIndex retrieves a validator's index location in the beacon state's
	// validator registry looking up whether the validator exists based on its
	// public key. This method returns NOT_FOUND if no index is found for the public key
	// specified in the request.
	ValidatorIndex(context.Context, *ValidatorIndexRequest) (*ValidatorIndexResponse, error)
	// ValidatorStatus returns a validator's status based on the current epoch.
	// The request can specify either a validator's public key or validator index.
	//
	// The status response can be one of the following:
	//	DEPOSITED - validator's deposit has been recognized by Ethereum 1, not yet recognized by Ethereum 2.
	//	PENDING - validator is in Ethereum 2's activation queue.
	//	ACTIVE - validator is active.
	//	EXITING - validator has initiated an an exit request, or has dropped below the ejection balance and is being kicked out.
	//	EXITED - validator is no longer validating.
	//	SLASHING - validator has been kicked out due to meeting a slashing condition.
	//	UNKNOWN_STATUS - validator does not have a known status in the network.
	ValidatorStatus(context.Context, *ValidatorStatusRequest) (*ValidatorStatusResponse, error)
	// MultipleValidatorStatus returns a list of validator statuses on the current epoch.
	// The request can specify a list of validator public keys.
	//
	// Returns a list of ValidatorStatusResponses.
	MultipleValidatorStatus(context.Context, *MultipleValidatorStatusRequest) (*MultipleValidatorStatusResponse, error)
	// Retrieves the latest valid beacon block to be proposed on the beacon chain.
	//
	// The server returns a new beacon block, without proposer signature, that can be
	// proposed on the beacon chain. The block should be filled with all the necessary
	// data for proposer to sign.
	GetBlock(context.Context, *BlockRequest) (*BeaconBlock, error)
	// Sends the newly signed beacon block to beacon node.
	//
	// The validator sends the newly signed beacon block to the beacon node so the beacon block can
	// be included in the beacon chain. The beacon node is expected to validate and process the
	// beacon block into its state.
	ProposeBlock(context.Context, *SignedBeaconBlock) (*ProposeResponse, error)
	// Retrieves the latest valid attestation data to be attested on the beacon chain.
	//
	// The server returns the latest valid data which represents the correct vote
	// for the head of the beacon chain,
	GetAttestationData(context.Context, *AttestationDataRequest) (*AttestationData, error)
	// Sends the newly signed attestation to beacon node.
	//
	// The validator sends the newly signed attestation to the beacon node for the attestation to
	// be included in the beacon chain. The beacon node is expected to validate and publish attestation on
	// appropriate committee subnet.
	ProposeAttestation(context.Context, *Attestation) (*AttestResponse, error)
	// Submit selection proof to the beacon node to aggregate all matching wire attestations with the same data root.
	// the beacon node responses with an aggregate and proof object back to validator to sign over.
	SubmitAggregateSelectionProof(context.Context, *AggregateSelectionRequest) (*AggregateSelectionResponse, error)
	// Submit a signed aggregate and proof object, the beacon node will broadcast the
	// signed aggregated attestation and proof object.
	SubmitSignedAggregateSelectionProof(context.Context, *SignedAggregateSubmitRequest) (*SignedAggregateSubmitResponse, error)
	// Propose to leave the list of active validators.
	//
	// The beacon node is expected to validate the request and make it available for inclusion in
	// the next proposed block.
	ProposeExit(context.Context, *SignedVoluntaryExit) (*ProposeExitResponse, error)
	// Subscribe to particular committee ID subnets given validator's duty.
	//
	// The beacon node is expected to subscribe to the committee ID subnet given by the request. With this,
	// beacon node serving attesters can find persistent peers on the subnet to publish attestation,
	// and beacon node serving aggregator can join the subnet.
	SubscribeCommitteeSubnets(context.Context, *CommitteeSubnetsSubscribeRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedBeaconNodeValidatorServer()
}

// UnimplementedBeaconNodeValidatorServer must be embedded to have forward compatible implementations.
type UnimplementedBeaconNodeValidatorServer struct {
}

func (UnimplementedBeaconNodeValidatorServer) GetDuties(context.Context, *DutiesRequest) (*DutiesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDuties not implemented")
}
func (UnimplementedBeaconNodeValidatorServer) StreamDuties(*DutiesRequest, BeaconNodeValidator_StreamDutiesServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamDuties not implemented")
}
func (UnimplementedBeaconNodeValidatorServer) DomainData(context.Context, *DomainRequest) (*DomainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DomainData not implemented")
}
func (UnimplementedBeaconNodeValidatorServer) WaitForChainStart(*emptypb.Empty, BeaconNodeValidator_WaitForChainStartServer) error {
	return status.Errorf(codes.Unimplemented, "method WaitForChainStart not implemented")
}
func (UnimplementedBeaconNodeValidatorServer) WaitForActivation(*ValidatorActivationRequest, BeaconNodeValidator_WaitForActivationServer) error {
	return status.Errorf(codes.Unimplemented, "method WaitForActivation not implemented")
}
func (UnimplementedBeaconNodeValidatorServer) ValidatorIndex(context.Context, *ValidatorIndexRequest) (*ValidatorIndexResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidatorIndex not implemented")
}
func (UnimplementedBeaconNodeValidatorServer) ValidatorStatus(context.Context, *ValidatorStatusRequest) (*ValidatorStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidatorStatus not implemented")
}
func (UnimplementedBeaconNodeValidatorServer) MultipleValidatorStatus(context.Context, *MultipleValidatorStatusRequest) (*MultipleValidatorStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MultipleValidatorStatus not implemented")
}
func (UnimplementedBeaconNodeValidatorServer) GetBlock(context.Context, *BlockRequest) (*BeaconBlock, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlock not implemented")
}
func (UnimplementedBeaconNodeValidatorServer) ProposeBlock(context.Context, *SignedBeaconBlock) (*ProposeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProposeBlock not implemented")
}
func (UnimplementedBeaconNodeValidatorServer) GetAttestationData(context.Context, *AttestationDataRequest) (*AttestationData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAttestationData not implemented")
}
func (UnimplementedBeaconNodeValidatorServer) ProposeAttestation(context.Context, *Attestation) (*AttestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProposeAttestation not implemented")
}
func (UnimplementedBeaconNodeValidatorServer) SubmitAggregateSelectionProof(context.Context, *AggregateSelectionRequest) (*AggregateSelectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitAggregateSelectionProof not implemented")
}
func (UnimplementedBeaconNodeValidatorServer) SubmitSignedAggregateSelectionProof(context.Context, *SignedAggregateSubmitRequest) (*SignedAggregateSubmitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitSignedAggregateSelectionProof not implemented")
}
func (UnimplementedBeaconNodeValidatorServer) ProposeExit(context.Context, *SignedVoluntaryExit) (*ProposeExitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProposeExit not implemented")
}
func (UnimplementedBeaconNodeValidatorServer) SubscribeCommitteeSubnets(context.Context, *CommitteeSubnetsSubscribeRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubscribeCommitteeSubnets not implemented")
}
func (UnimplementedBeaconNodeValidatorServer) mustEmbedUnimplementedBeaconNodeValidatorServer() {}

// UnsafeBeaconNodeValidatorServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BeaconNodeValidatorServer will
// result in compilation errors.
type UnsafeBeaconNodeValidatorServer interface {
	mustEmbedUnimplementedBeaconNodeValidatorServer()
}

func RegisterBeaconNodeValidatorServer(s *grpc.Server, srv BeaconNodeValidatorServer) {
	s.RegisterService(&_BeaconNodeValidator_serviceDesc, srv)
}

func _BeaconNodeValidator_GetDuties_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DutiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconNodeValidatorServer).GetDuties(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconNodeValidator/GetDuties",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconNodeValidatorServer).GetDuties(ctx, req.(*DutiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconNodeValidator_StreamDuties_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DutiesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BeaconNodeValidatorServer).StreamDuties(m, &beaconNodeValidatorStreamDutiesServer{stream})
}

type BeaconNodeValidator_StreamDutiesServer interface {
	Send(*DutiesResponse) error
	grpc.ServerStream
}

type beaconNodeValidatorStreamDutiesServer struct {
	grpc.ServerStream
}

func (x *beaconNodeValidatorStreamDutiesServer) Send(m *DutiesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _BeaconNodeValidator_DomainData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DomainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconNodeValidatorServer).DomainData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconNodeValidator/DomainData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconNodeValidatorServer).DomainData(ctx, req.(*DomainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconNodeValidator_WaitForChainStart_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BeaconNodeValidatorServer).WaitForChainStart(m, &beaconNodeValidatorWaitForChainStartServer{stream})
}

type BeaconNodeValidator_WaitForChainStartServer interface {
	Send(*ChainStartResponse) error
	grpc.ServerStream
}

type beaconNodeValidatorWaitForChainStartServer struct {
	grpc.ServerStream
}

func (x *beaconNodeValidatorWaitForChainStartServer) Send(m *ChainStartResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _BeaconNodeValidator_WaitForActivation_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ValidatorActivationRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BeaconNodeValidatorServer).WaitForActivation(m, &beaconNodeValidatorWaitForActivationServer{stream})
}

type BeaconNodeValidator_WaitForActivationServer interface {
	Send(*ValidatorActivationResponse) error
	grpc.ServerStream
}

type beaconNodeValidatorWaitForActivationServer struct {
	grpc.ServerStream
}

func (x *beaconNodeValidatorWaitForActivationServer) Send(m *ValidatorActivationResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _BeaconNodeValidator_ValidatorIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidatorIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconNodeValidatorServer).ValidatorIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconNodeValidator/ValidatorIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconNodeValidatorServer).ValidatorIndex(ctx, req.(*ValidatorIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconNodeValidator_ValidatorStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidatorStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconNodeValidatorServer).ValidatorStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconNodeValidator/ValidatorStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconNodeValidatorServer).ValidatorStatus(ctx, req.(*ValidatorStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconNodeValidator_MultipleValidatorStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MultipleValidatorStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconNodeValidatorServer).MultipleValidatorStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconNodeValidator/MultipleValidatorStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconNodeValidatorServer).MultipleValidatorStatus(ctx, req.(*MultipleValidatorStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconNodeValidator_GetBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconNodeValidatorServer).GetBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconNodeValidator/GetBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconNodeValidatorServer).GetBlock(ctx, req.(*BlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconNodeValidator_ProposeBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignedBeaconBlock)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconNodeValidatorServer).ProposeBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconNodeValidator/ProposeBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconNodeValidatorServer).ProposeBlock(ctx, req.(*SignedBeaconBlock))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconNodeValidator_GetAttestationData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttestationDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconNodeValidatorServer).GetAttestationData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconNodeValidator/GetAttestationData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconNodeValidatorServer).GetAttestationData(ctx, req.(*AttestationDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconNodeValidator_ProposeAttestation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Attestation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconNodeValidatorServer).ProposeAttestation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconNodeValidator/ProposeAttestation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconNodeValidatorServer).ProposeAttestation(ctx, req.(*Attestation))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconNodeValidator_SubmitAggregateSelectionProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregateSelectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconNodeValidatorServer).SubmitAggregateSelectionProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconNodeValidator/SubmitAggregateSelectionProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconNodeValidatorServer).SubmitAggregateSelectionProof(ctx, req.(*AggregateSelectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconNodeValidator_SubmitSignedAggregateSelectionProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignedAggregateSubmitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconNodeValidatorServer).SubmitSignedAggregateSelectionProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconNodeValidator/SubmitSignedAggregateSelectionProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconNodeValidatorServer).SubmitSignedAggregateSelectionProof(ctx, req.(*SignedAggregateSubmitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconNodeValidator_ProposeExit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignedVoluntaryExit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconNodeValidatorServer).ProposeExit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconNodeValidator/ProposeExit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconNodeValidatorServer).ProposeExit(ctx, req.(*SignedVoluntaryExit))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconNodeValidator_SubscribeCommitteeSubnets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommitteeSubnetsSubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconNodeValidatorServer).SubscribeCommitteeSubnets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1alpha1.BeaconNodeValidator/SubscribeCommitteeSubnets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconNodeValidatorServer).SubscribeCommitteeSubnets(ctx, req.(*CommitteeSubnetsSubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _BeaconNodeValidator_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ethereum.eth.v1alpha1.BeaconNodeValidator",
	HandlerType: (*BeaconNodeValidatorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetDuties",
			Handler:    _BeaconNodeValidator_GetDuties_Handler,
		},
		{
			MethodName: "DomainData",
			Handler:    _BeaconNodeValidator_DomainData_Handler,
		},
		{
			MethodName: "ValidatorIndex",
			Handler:    _BeaconNodeValidator_ValidatorIndex_Handler,
		},
		{
			MethodName: "ValidatorStatus",
			Handler:    _BeaconNodeValidator_ValidatorStatus_Handler,
		},
		{
			MethodName: "MultipleValidatorStatus",
			Handler:    _BeaconNodeValidator_MultipleValidatorStatus_Handler,
		},
		{
			MethodName: "GetBlock",
			Handler:    _BeaconNodeValidator_GetBlock_Handler,
		},
		{
			MethodName: "ProposeBlock",
			Handler:    _BeaconNodeValidator_ProposeBlock_Handler,
		},
		{
			MethodName: "GetAttestationData",
			Handler:    _BeaconNodeValidator_GetAttestationData_Handler,
		},
		{
			MethodName: "ProposeAttestation",
			Handler:    _BeaconNodeValidator_ProposeAttestation_Handler,
		},
		{
			MethodName: "SubmitAggregateSelectionProof",
			Handler:    _BeaconNodeValidator_SubmitAggregateSelectionProof_Handler,
		},
		{
			MethodName: "SubmitSignedAggregateSelectionProof",
			Handler:    _BeaconNodeValidator_SubmitSignedAggregateSelectionProof_Handler,
		},
		{
			MethodName: "ProposeExit",
			Handler:    _BeaconNodeValidator_ProposeExit_Handler,
		},
		{
			MethodName: "SubscribeCommitteeSubnets",
			Handler:    _BeaconNodeValidator_SubscribeCommitteeSubnets_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamDuties",
			Handler:       _BeaconNodeValidator_StreamDuties_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WaitForChainStart",
			Handler:       _BeaconNodeValidator_WaitForChainStart_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WaitForActivation",
			Handler:       _BeaconNodeValidator_WaitForActivation_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "eth/v1alpha1/validator.proto",
}
