// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: eth/v1/beacon_chain_service.proto

package v1

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type GenesisResponse struct {
	GenesisTime           uint64   `protobuf:"varint,1,opt,name=genesis_time,json=genesisTime,proto3" json:"genesis_time,omitempty"`
	GenesisValidatorsRoot []byte   `protobuf:"bytes,2,opt,name=genesis_validators_root,json=genesisValidatorsRoot,proto3" json:"genesis_validators_root,omitempty" ssz-size:"32"`
	GenesisForkVersion    []byte   `protobuf:"bytes,3,opt,name=genesis_fork_version,json=genesisForkVersion,proto3" json:"genesis_fork_version,omitempty" ssz-size:"4"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *GenesisResponse) Reset()         { *m = GenesisResponse{} }
func (m *GenesisResponse) String() string { return proto.CompactTextString(m) }
func (*GenesisResponse) ProtoMessage()    {}
func (*GenesisResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{0}
}
func (m *GenesisResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenesisResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisResponse.Merge(m, src)
}
func (m *GenesisResponse) XXX_Size() int {
	return m.Size()
}
func (m *GenesisResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisResponse proto.InternalMessageInfo

func (m *GenesisResponse) GetGenesisTime() uint64 {
	if m != nil {
		return m.GenesisTime
	}
	return 0
}

func (m *GenesisResponse) GetGenesisValidatorsRoot() []byte {
	if m != nil {
		return m.GenesisValidatorsRoot
	}
	return nil
}

func (m *GenesisResponse) GetGenesisForkVersion() []byte {
	if m != nil {
		return m.GenesisForkVersion
	}
	return nil
}

type StateRequest struct {
	StateId              string   `protobuf:"bytes,1,opt,name=state_id,json=stateId,proto3" json:"state_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StateRequest) Reset()         { *m = StateRequest{} }
func (m *StateRequest) String() string { return proto.CompactTextString(m) }
func (*StateRequest) ProtoMessage()    {}
func (*StateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{1}
}
func (m *StateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateRequest.Merge(m, src)
}
func (m *StateRequest) XXX_Size() int {
	return m.Size()
}
func (m *StateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StateRequest proto.InternalMessageInfo

func (m *StateRequest) GetStateId() string {
	if m != nil {
		return m.StateId
	}
	return ""
}

type StateRootResponse struct {
	StateRoot            []byte   `protobuf:"bytes,1,opt,name=state_root,json=stateRoot,proto3" json:"state_root,omitempty" ssz-size:"32"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StateRootResponse) Reset()         { *m = StateRootResponse{} }
func (m *StateRootResponse) String() string { return proto.CompactTextString(m) }
func (*StateRootResponse) ProtoMessage()    {}
func (*StateRootResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{2}
}
func (m *StateRootResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateRootResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateRootResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateRootResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateRootResponse.Merge(m, src)
}
func (m *StateRootResponse) XXX_Size() int {
	return m.Size()
}
func (m *StateRootResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StateRootResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StateRootResponse proto.InternalMessageInfo

func (m *StateRootResponse) GetStateRoot() []byte {
	if m != nil {
		return m.StateRoot
	}
	return nil
}

type StateForkResponse struct {
	Fork                 *Fork    `protobuf:"bytes,1,opt,name=fork,proto3" json:"fork,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StateForkResponse) Reset()         { *m = StateForkResponse{} }
func (m *StateForkResponse) String() string { return proto.CompactTextString(m) }
func (*StateForkResponse) ProtoMessage()    {}
func (*StateForkResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{3}
}
func (m *StateForkResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateForkResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateForkResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateForkResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateForkResponse.Merge(m, src)
}
func (m *StateForkResponse) XXX_Size() int {
	return m.Size()
}
func (m *StateForkResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StateForkResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StateForkResponse proto.InternalMessageInfo

func (m *StateForkResponse) GetFork() *Fork {
	if m != nil {
		return m.Fork
	}
	return nil
}

type StateFinalityCheckpointResponse struct {
	PreviousJustified    *Checkpoint `protobuf:"bytes,1,opt,name=previous_justified,json=previousJustified,proto3" json:"previous_justified,omitempty"`
	CurrentJustified     *Checkpoint `protobuf:"bytes,2,opt,name=current_justified,json=currentJustified,proto3" json:"current_justified,omitempty"`
	Finalized            *Checkpoint `protobuf:"bytes,3,opt,name=finalized,proto3" json:"finalized,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *StateFinalityCheckpointResponse) Reset()         { *m = StateFinalityCheckpointResponse{} }
func (m *StateFinalityCheckpointResponse) String() string { return proto.CompactTextString(m) }
func (*StateFinalityCheckpointResponse) ProtoMessage()    {}
func (*StateFinalityCheckpointResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{4}
}
func (m *StateFinalityCheckpointResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateFinalityCheckpointResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateFinalityCheckpointResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateFinalityCheckpointResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateFinalityCheckpointResponse.Merge(m, src)
}
func (m *StateFinalityCheckpointResponse) XXX_Size() int {
	return m.Size()
}
func (m *StateFinalityCheckpointResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StateFinalityCheckpointResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StateFinalityCheckpointResponse proto.InternalMessageInfo

func (m *StateFinalityCheckpointResponse) GetPreviousJustified() *Checkpoint {
	if m != nil {
		return m.PreviousJustified
	}
	return nil
}

func (m *StateFinalityCheckpointResponse) GetCurrentJustified() *Checkpoint {
	if m != nil {
		return m.CurrentJustified
	}
	return nil
}

func (m *StateFinalityCheckpointResponse) GetFinalized() *Checkpoint {
	if m != nil {
		return m.Finalized
	}
	return nil
}

type StateValidatorsRequest struct {
	StateId              string   `protobuf:"bytes,1,opt,name=state_id,json=stateId,proto3" json:"state_id,omitempty"`
	Id                   []string `protobuf:"bytes,2,rep,name=id,proto3" json:"id,omitempty"`
	Status               string   `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StateValidatorsRequest) Reset()         { *m = StateValidatorsRequest{} }
func (m *StateValidatorsRequest) String() string { return proto.CompactTextString(m) }
func (*StateValidatorsRequest) ProtoMessage()    {}
func (*StateValidatorsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{5}
}
func (m *StateValidatorsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateValidatorsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateValidatorsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateValidatorsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateValidatorsRequest.Merge(m, src)
}
func (m *StateValidatorsRequest) XXX_Size() int {
	return m.Size()
}
func (m *StateValidatorsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StateValidatorsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StateValidatorsRequest proto.InternalMessageInfo

func (m *StateValidatorsRequest) GetStateId() string {
	if m != nil {
		return m.StateId
	}
	return ""
}

func (m *StateValidatorsRequest) GetId() []string {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *StateValidatorsRequest) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

type StateValidatorsResponse struct {
	Data                 []*ValidatorContainer `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *StateValidatorsResponse) Reset()         { *m = StateValidatorsResponse{} }
func (m *StateValidatorsResponse) String() string { return proto.CompactTextString(m) }
func (*StateValidatorsResponse) ProtoMessage()    {}
func (*StateValidatorsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{6}
}
func (m *StateValidatorsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateValidatorsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateValidatorsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateValidatorsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateValidatorsResponse.Merge(m, src)
}
func (m *StateValidatorsResponse) XXX_Size() int {
	return m.Size()
}
func (m *StateValidatorsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StateValidatorsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StateValidatorsResponse proto.InternalMessageInfo

func (m *StateValidatorsResponse) GetData() []*ValidatorContainer {
	if m != nil {
		return m.Data
	}
	return nil
}

type StateValidatorRequest struct {
	StateId              string   `protobuf:"bytes,1,opt,name=state_id,json=stateId,proto3" json:"state_id,omitempty"`
	ValidatorId          string   `protobuf:"bytes,2,opt,name=validator_id,json=validatorId,proto3" json:"validator_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StateValidatorRequest) Reset()         { *m = StateValidatorRequest{} }
func (m *StateValidatorRequest) String() string { return proto.CompactTextString(m) }
func (*StateValidatorRequest) ProtoMessage()    {}
func (*StateValidatorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{7}
}
func (m *StateValidatorRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateValidatorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateValidatorRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateValidatorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateValidatorRequest.Merge(m, src)
}
func (m *StateValidatorRequest) XXX_Size() int {
	return m.Size()
}
func (m *StateValidatorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StateValidatorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StateValidatorRequest proto.InternalMessageInfo

func (m *StateValidatorRequest) GetStateId() string {
	if m != nil {
		return m.StateId
	}
	return ""
}

func (m *StateValidatorRequest) GetValidatorId() string {
	if m != nil {
		return m.ValidatorId
	}
	return ""
}

type StateValidatorResponse struct {
	Data                 *ValidatorContainer `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *StateValidatorResponse) Reset()         { *m = StateValidatorResponse{} }
func (m *StateValidatorResponse) String() string { return proto.CompactTextString(m) }
func (*StateValidatorResponse) ProtoMessage()    {}
func (*StateValidatorResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{8}
}
func (m *StateValidatorResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateValidatorResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateValidatorResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateValidatorResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateValidatorResponse.Merge(m, src)
}
func (m *StateValidatorResponse) XXX_Size() int {
	return m.Size()
}
func (m *StateValidatorResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StateValidatorResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StateValidatorResponse proto.InternalMessageInfo

func (m *StateValidatorResponse) GetData() *ValidatorContainer {
	if m != nil {
		return m.Data
	}
	return nil
}

type StateCommitteesRequest struct {
	StateId              string   `protobuf:"bytes,1,opt,name=state_id,json=stateId,proto3" json:"state_id,omitempty"`
	Epoch                uint64   `protobuf:"varint,2,opt,name=epoch,proto3" json:"epoch,omitempty"`
	Index                uint64   `protobuf:"varint,3,opt,name=index,proto3" json:"index,omitempty"`
	Slot                 uint64   `protobuf:"varint,4,opt,name=slot,proto3" json:"slot,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StateCommitteesRequest) Reset()         { *m = StateCommitteesRequest{} }
func (m *StateCommitteesRequest) String() string { return proto.CompactTextString(m) }
func (*StateCommitteesRequest) ProtoMessage()    {}
func (*StateCommitteesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{9}
}
func (m *StateCommitteesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateCommitteesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateCommitteesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateCommitteesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateCommitteesRequest.Merge(m, src)
}
func (m *StateCommitteesRequest) XXX_Size() int {
	return m.Size()
}
func (m *StateCommitteesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StateCommitteesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StateCommitteesRequest proto.InternalMessageInfo

func (m *StateCommitteesRequest) GetStateId() string {
	if m != nil {
		return m.StateId
	}
	return ""
}

func (m *StateCommitteesRequest) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *StateCommitteesRequest) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *StateCommitteesRequest) GetSlot() uint64 {
	if m != nil {
		return m.Slot
	}
	return 0
}

type StateCommitteesResponse struct {
	Data                 []*Committee `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *StateCommitteesResponse) Reset()         { *m = StateCommitteesResponse{} }
func (m *StateCommitteesResponse) String() string { return proto.CompactTextString(m) }
func (*StateCommitteesResponse) ProtoMessage()    {}
func (*StateCommitteesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{10}
}
func (m *StateCommitteesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateCommitteesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateCommitteesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateCommitteesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateCommitteesResponse.Merge(m, src)
}
func (m *StateCommitteesResponse) XXX_Size() int {
	return m.Size()
}
func (m *StateCommitteesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StateCommitteesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StateCommitteesResponse proto.InternalMessageInfo

func (m *StateCommitteesResponse) GetData() []*Committee {
	if m != nil {
		return m.Data
	}
	return nil
}

type BlockAttestationsResponse struct {
	Data                 []*Attestation `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *BlockAttestationsResponse) Reset()         { *m = BlockAttestationsResponse{} }
func (m *BlockAttestationsResponse) String() string { return proto.CompactTextString(m) }
func (*BlockAttestationsResponse) ProtoMessage()    {}
func (*BlockAttestationsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{11}
}
func (m *BlockAttestationsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockAttestationsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockAttestationsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockAttestationsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockAttestationsResponse.Merge(m, src)
}
func (m *BlockAttestationsResponse) XXX_Size() int {
	return m.Size()
}
func (m *BlockAttestationsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockAttestationsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BlockAttestationsResponse proto.InternalMessageInfo

func (m *BlockAttestationsResponse) GetData() []*Attestation {
	if m != nil {
		return m.Data
	}
	return nil
}

type BlockRootContainer struct {
	Root                 []byte   `protobuf:"bytes,1,opt,name=root,proto3" json:"root,omitempty" ssz-size:"32"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockRootContainer) Reset()         { *m = BlockRootContainer{} }
func (m *BlockRootContainer) String() string { return proto.CompactTextString(m) }
func (*BlockRootContainer) ProtoMessage()    {}
func (*BlockRootContainer) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{12}
}
func (m *BlockRootContainer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockRootContainer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockRootContainer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockRootContainer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockRootContainer.Merge(m, src)
}
func (m *BlockRootContainer) XXX_Size() int {
	return m.Size()
}
func (m *BlockRootContainer) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockRootContainer.DiscardUnknown(m)
}

var xxx_messageInfo_BlockRootContainer proto.InternalMessageInfo

func (m *BlockRootContainer) GetRoot() []byte {
	if m != nil {
		return m.Root
	}
	return nil
}

type BlockRootResponse struct {
	Data                 *BlockRootContainer `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *BlockRootResponse) Reset()         { *m = BlockRootResponse{} }
func (m *BlockRootResponse) String() string { return proto.CompactTextString(m) }
func (*BlockRootResponse) ProtoMessage()    {}
func (*BlockRootResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{13}
}
func (m *BlockRootResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockRootResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockRootResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockRootResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockRootResponse.Merge(m, src)
}
func (m *BlockRootResponse) XXX_Size() int {
	return m.Size()
}
func (m *BlockRootResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockRootResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BlockRootResponse proto.InternalMessageInfo

func (m *BlockRootResponse) GetData() *BlockRootContainer {
	if m != nil {
		return m.Data
	}
	return nil
}

type BlockHeadersRequest struct {
	Slot                 uint64   `protobuf:"varint,1,opt,name=slot,proto3" json:"slot,omitempty"`
	ParentRoot           []byte   `protobuf:"bytes,2,opt,name=parent_root,json=parentRoot,proto3" json:"parent_root,omitempty" ssz-size:"32"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockHeadersRequest) Reset()         { *m = BlockHeadersRequest{} }
func (m *BlockHeadersRequest) String() string { return proto.CompactTextString(m) }
func (*BlockHeadersRequest) ProtoMessage()    {}
func (*BlockHeadersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{14}
}
func (m *BlockHeadersRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockHeadersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockHeadersRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockHeadersRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockHeadersRequest.Merge(m, src)
}
func (m *BlockHeadersRequest) XXX_Size() int {
	return m.Size()
}
func (m *BlockHeadersRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockHeadersRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BlockHeadersRequest proto.InternalMessageInfo

func (m *BlockHeadersRequest) GetSlot() uint64 {
	if m != nil {
		return m.Slot
	}
	return 0
}

func (m *BlockHeadersRequest) GetParentRoot() []byte {
	if m != nil {
		return m.ParentRoot
	}
	return nil
}

type BlockHeadersResponse struct {
	Data                 []*BlockHeaderContainer `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *BlockHeadersResponse) Reset()         { *m = BlockHeadersResponse{} }
func (m *BlockHeadersResponse) String() string { return proto.CompactTextString(m) }
func (*BlockHeadersResponse) ProtoMessage()    {}
func (*BlockHeadersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{15}
}
func (m *BlockHeadersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockHeadersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockHeadersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockHeadersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockHeadersResponse.Merge(m, src)
}
func (m *BlockHeadersResponse) XXX_Size() int {
	return m.Size()
}
func (m *BlockHeadersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockHeadersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BlockHeadersResponse proto.InternalMessageInfo

func (m *BlockHeadersResponse) GetData() []*BlockHeaderContainer {
	if m != nil {
		return m.Data
	}
	return nil
}

type BlockRequest struct {
	BlockId              []byte   `protobuf:"bytes,1,opt,name=block_id,json=blockId,proto3" json:"block_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockRequest) Reset()         { *m = BlockRequest{} }
func (m *BlockRequest) String() string { return proto.CompactTextString(m) }
func (*BlockRequest) ProtoMessage()    {}
func (*BlockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{16}
}
func (m *BlockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockRequest.Merge(m, src)
}
func (m *BlockRequest) XXX_Size() int {
	return m.Size()
}
func (m *BlockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BlockRequest proto.InternalMessageInfo

func (m *BlockRequest) GetBlockId() []byte {
	if m != nil {
		return m.BlockId
	}
	return nil
}

type BlockHeaderResponse struct {
	Data                 *BlockHeaderContainer `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *BlockHeaderResponse) Reset()         { *m = BlockHeaderResponse{} }
func (m *BlockHeaderResponse) String() string { return proto.CompactTextString(m) }
func (*BlockHeaderResponse) ProtoMessage()    {}
func (*BlockHeaderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{17}
}
func (m *BlockHeaderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockHeaderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockHeaderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockHeaderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockHeaderResponse.Merge(m, src)
}
func (m *BlockHeaderResponse) XXX_Size() int {
	return m.Size()
}
func (m *BlockHeaderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockHeaderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BlockHeaderResponse proto.InternalMessageInfo

func (m *BlockHeaderResponse) GetData() *BlockHeaderContainer {
	if m != nil {
		return m.Data
	}
	return nil
}

type BlockHeaderContainer struct {
	Root                 []byte                      `protobuf:"bytes,1,opt,name=root,proto3" json:"root,omitempty" ssz-size:"32"`
	Canonical            bool                        `protobuf:"varint,2,opt,name=canonical,proto3" json:"canonical,omitempty"`
	Header               *BeaconBlockHeaderContainer `protobuf:"bytes,3,opt,name=header,proto3" json:"header,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *BlockHeaderContainer) Reset()         { *m = BlockHeaderContainer{} }
func (m *BlockHeaderContainer) String() string { return proto.CompactTextString(m) }
func (*BlockHeaderContainer) ProtoMessage()    {}
func (*BlockHeaderContainer) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{18}
}
func (m *BlockHeaderContainer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockHeaderContainer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockHeaderContainer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockHeaderContainer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockHeaderContainer.Merge(m, src)
}
func (m *BlockHeaderContainer) XXX_Size() int {
	return m.Size()
}
func (m *BlockHeaderContainer) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockHeaderContainer.DiscardUnknown(m)
}

var xxx_messageInfo_BlockHeaderContainer proto.InternalMessageInfo

func (m *BlockHeaderContainer) GetRoot() []byte {
	if m != nil {
		return m.Root
	}
	return nil
}

func (m *BlockHeaderContainer) GetCanonical() bool {
	if m != nil {
		return m.Canonical
	}
	return false
}

func (m *BlockHeaderContainer) GetHeader() *BeaconBlockHeaderContainer {
	if m != nil {
		return m.Header
	}
	return nil
}

type BeaconBlockHeaderContainer struct {
	Message              *BeaconBlockHeader `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	Signature            []byte             `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty" ssz-size:"96"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *BeaconBlockHeaderContainer) Reset()         { *m = BeaconBlockHeaderContainer{} }
func (m *BeaconBlockHeaderContainer) String() string { return proto.CompactTextString(m) }
func (*BeaconBlockHeaderContainer) ProtoMessage()    {}
func (*BeaconBlockHeaderContainer) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{19}
}
func (m *BeaconBlockHeaderContainer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BeaconBlockHeaderContainer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BeaconBlockHeaderContainer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BeaconBlockHeaderContainer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BeaconBlockHeaderContainer.Merge(m, src)
}
func (m *BeaconBlockHeaderContainer) XXX_Size() int {
	return m.Size()
}
func (m *BeaconBlockHeaderContainer) XXX_DiscardUnknown() {
	xxx_messageInfo_BeaconBlockHeaderContainer.DiscardUnknown(m)
}

var xxx_messageInfo_BeaconBlockHeaderContainer proto.InternalMessageInfo

func (m *BeaconBlockHeaderContainer) GetMessage() *BeaconBlockHeader {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *BeaconBlockHeaderContainer) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type BlockResponse struct {
	Data                 *BeaconBlockContainer `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *BlockResponse) Reset()         { *m = BlockResponse{} }
func (m *BlockResponse) String() string { return proto.CompactTextString(m) }
func (*BlockResponse) ProtoMessage()    {}
func (*BlockResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{20}
}
func (m *BlockResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockResponse.Merge(m, src)
}
func (m *BlockResponse) XXX_Size() int {
	return m.Size()
}
func (m *BlockResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BlockResponse proto.InternalMessageInfo

func (m *BlockResponse) GetData() *BeaconBlockContainer {
	if m != nil {
		return m.Data
	}
	return nil
}

type BeaconBlockContainer struct {
	Message              *BeaconBlock `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	Signature            []byte       `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty" ssz-size:"96"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *BeaconBlockContainer) Reset()         { *m = BeaconBlockContainer{} }
func (m *BeaconBlockContainer) String() string { return proto.CompactTextString(m) }
func (*BeaconBlockContainer) ProtoMessage()    {}
func (*BeaconBlockContainer) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{21}
}
func (m *BeaconBlockContainer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BeaconBlockContainer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BeaconBlockContainer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BeaconBlockContainer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BeaconBlockContainer.Merge(m, src)
}
func (m *BeaconBlockContainer) XXX_Size() int {
	return m.Size()
}
func (m *BeaconBlockContainer) XXX_DiscardUnknown() {
	xxx_messageInfo_BeaconBlockContainer.DiscardUnknown(m)
}

var xxx_messageInfo_BeaconBlockContainer proto.InternalMessageInfo

func (m *BeaconBlockContainer) GetMessage() *BeaconBlock {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *BeaconBlockContainer) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

type AttestationsPoolRequest struct {
	Slot                 uint64   `protobuf:"varint,1,opt,name=slot,proto3" json:"slot,omitempty"`
	CommitteeIndex       uint64   `protobuf:"varint,2,opt,name=committee_index,json=committeeIndex,proto3" json:"committee_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AttestationsPoolRequest) Reset()         { *m = AttestationsPoolRequest{} }
func (m *AttestationsPoolRequest) String() string { return proto.CompactTextString(m) }
func (*AttestationsPoolRequest) ProtoMessage()    {}
func (*AttestationsPoolRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{22}
}
func (m *AttestationsPoolRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttestationsPoolRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttestationsPoolRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttestationsPoolRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttestationsPoolRequest.Merge(m, src)
}
func (m *AttestationsPoolRequest) XXX_Size() int {
	return m.Size()
}
func (m *AttestationsPoolRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AttestationsPoolRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AttestationsPoolRequest proto.InternalMessageInfo

func (m *AttestationsPoolRequest) GetSlot() uint64 {
	if m != nil {
		return m.Slot
	}
	return 0
}

func (m *AttestationsPoolRequest) GetCommitteeIndex() uint64 {
	if m != nil {
		return m.CommitteeIndex
	}
	return 0
}

type AttestationsPoolResponse struct {
	Data                 []*Attestation `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *AttestationsPoolResponse) Reset()         { *m = AttestationsPoolResponse{} }
func (m *AttestationsPoolResponse) String() string { return proto.CompactTextString(m) }
func (*AttestationsPoolResponse) ProtoMessage()    {}
func (*AttestationsPoolResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{23}
}
func (m *AttestationsPoolResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttestationsPoolResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttestationsPoolResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttestationsPoolResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttestationsPoolResponse.Merge(m, src)
}
func (m *AttestationsPoolResponse) XXX_Size() int {
	return m.Size()
}
func (m *AttestationsPoolResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AttestationsPoolResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AttestationsPoolResponse proto.InternalMessageInfo

func (m *AttestationsPoolResponse) GetData() []*Attestation {
	if m != nil {
		return m.Data
	}
	return nil
}

type AttesterSlashingsPoolResponse struct {
	Data                 []*AttesterSlashing `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *AttesterSlashingsPoolResponse) Reset()         { *m = AttesterSlashingsPoolResponse{} }
func (m *AttesterSlashingsPoolResponse) String() string { return proto.CompactTextString(m) }
func (*AttesterSlashingsPoolResponse) ProtoMessage()    {}
func (*AttesterSlashingsPoolResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{24}
}
func (m *AttesterSlashingsPoolResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttesterSlashingsPoolResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttesterSlashingsPoolResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttesterSlashingsPoolResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttesterSlashingsPoolResponse.Merge(m, src)
}
func (m *AttesterSlashingsPoolResponse) XXX_Size() int {
	return m.Size()
}
func (m *AttesterSlashingsPoolResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AttesterSlashingsPoolResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AttesterSlashingsPoolResponse proto.InternalMessageInfo

func (m *AttesterSlashingsPoolResponse) GetData() []*AttesterSlashing {
	if m != nil {
		return m.Data
	}
	return nil
}

type ProposerSlashingPoolResponse struct {
	Data                 []*ProposerSlashing `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ProposerSlashingPoolResponse) Reset()         { *m = ProposerSlashingPoolResponse{} }
func (m *ProposerSlashingPoolResponse) String() string { return proto.CompactTextString(m) }
func (*ProposerSlashingPoolResponse) ProtoMessage()    {}
func (*ProposerSlashingPoolResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{25}
}
func (m *ProposerSlashingPoolResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposerSlashingPoolResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposerSlashingPoolResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposerSlashingPoolResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposerSlashingPoolResponse.Merge(m, src)
}
func (m *ProposerSlashingPoolResponse) XXX_Size() int {
	return m.Size()
}
func (m *ProposerSlashingPoolResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposerSlashingPoolResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ProposerSlashingPoolResponse proto.InternalMessageInfo

func (m *ProposerSlashingPoolResponse) GetData() []*ProposerSlashing {
	if m != nil {
		return m.Data
	}
	return nil
}

type VoluntaryExitsPoolResponse struct {
	Data                 []*SignedVoluntaryExit `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *VoluntaryExitsPoolResponse) Reset()         { *m = VoluntaryExitsPoolResponse{} }
func (m *VoluntaryExitsPoolResponse) String() string { return proto.CompactTextString(m) }
func (*VoluntaryExitsPoolResponse) ProtoMessage()    {}
func (*VoluntaryExitsPoolResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{26}
}
func (m *VoluntaryExitsPoolResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VoluntaryExitsPoolResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VoluntaryExitsPoolResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VoluntaryExitsPoolResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VoluntaryExitsPoolResponse.Merge(m, src)
}
func (m *VoluntaryExitsPoolResponse) XXX_Size() int {
	return m.Size()
}
func (m *VoluntaryExitsPoolResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VoluntaryExitsPoolResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VoluntaryExitsPoolResponse proto.InternalMessageInfo

func (m *VoluntaryExitsPoolResponse) GetData() []*SignedVoluntaryExit {
	if m != nil {
		return m.Data
	}
	return nil
}

type ForkScheduleResponse struct {
	Data                 *Fork    `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ForkScheduleResponse) Reset()         { *m = ForkScheduleResponse{} }
func (m *ForkScheduleResponse) String() string { return proto.CompactTextString(m) }
func (*ForkScheduleResponse) ProtoMessage()    {}
func (*ForkScheduleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{27}
}
func (m *ForkScheduleResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ForkScheduleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ForkScheduleResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ForkScheduleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ForkScheduleResponse.Merge(m, src)
}
func (m *ForkScheduleResponse) XXX_Size() int {
	return m.Size()
}
func (m *ForkScheduleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ForkScheduleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ForkScheduleResponse proto.InternalMessageInfo

func (m *ForkScheduleResponse) GetData() *Fork {
	if m != nil {
		return m.Data
	}
	return nil
}

type SpecResponse struct {
	Data                 map[string]string `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *SpecResponse) Reset()         { *m = SpecResponse{} }
func (m *SpecResponse) String() string { return proto.CompactTextString(m) }
func (*SpecResponse) ProtoMessage()    {}
func (*SpecResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{28}
}
func (m *SpecResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpecResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpecResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpecResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpecResponse.Merge(m, src)
}
func (m *SpecResponse) XXX_Size() int {
	return m.Size()
}
func (m *SpecResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SpecResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SpecResponse proto.InternalMessageInfo

func (m *SpecResponse) GetData() map[string]string {
	if m != nil {
		return m.Data
	}
	return nil
}

type DepositContractResponse struct {
	Data                 *DepositContract `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *DepositContractResponse) Reset()         { *m = DepositContractResponse{} }
func (m *DepositContractResponse) String() string { return proto.CompactTextString(m) }
func (*DepositContractResponse) ProtoMessage()    {}
func (*DepositContractResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{29}
}
func (m *DepositContractResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DepositContractResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DepositContractResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DepositContractResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DepositContractResponse.Merge(m, src)
}
func (m *DepositContractResponse) XXX_Size() int {
	return m.Size()
}
func (m *DepositContractResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DepositContractResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DepositContractResponse proto.InternalMessageInfo

func (m *DepositContractResponse) GetData() *DepositContract {
	if m != nil {
		return m.Data
	}
	return nil
}

type DepositContract struct {
	ChainId              uint64   `protobuf:"varint,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	Address              string   `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DepositContract) Reset()         { *m = DepositContract{} }
func (m *DepositContract) String() string { return proto.CompactTextString(m) }
func (*DepositContract) ProtoMessage()    {}
func (*DepositContract) Descriptor() ([]byte, []int) {
	return fileDescriptor_33987dc4bca2a2e7, []int{30}
}
func (m *DepositContract) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DepositContract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DepositContract.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DepositContract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DepositContract.Merge(m, src)
}
func (m *DepositContract) XXX_Size() int {
	return m.Size()
}
func (m *DepositContract) XXX_DiscardUnknown() {
	xxx_messageInfo_DepositContract.DiscardUnknown(m)
}

var xxx_messageInfo_DepositContract proto.InternalMessageInfo

func (m *DepositContract) GetChainId() uint64 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

func (m *DepositContract) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func init() {
	proto.RegisterType((*GenesisResponse)(nil), "ethereum.eth.v1.GenesisResponse")
	proto.RegisterType((*StateRequest)(nil), "ethereum.eth.v1.StateRequest")
	proto.RegisterType((*StateRootResponse)(nil), "ethereum.eth.v1.StateRootResponse")
	proto.RegisterType((*StateForkResponse)(nil), "ethereum.eth.v1.StateForkResponse")
	proto.RegisterType((*StateFinalityCheckpointResponse)(nil), "ethereum.eth.v1.StateFinalityCheckpointResponse")
	proto.RegisterType((*StateValidatorsRequest)(nil), "ethereum.eth.v1.StateValidatorsRequest")
	proto.RegisterType((*StateValidatorsResponse)(nil), "ethereum.eth.v1.StateValidatorsResponse")
	proto.RegisterType((*StateValidatorRequest)(nil), "ethereum.eth.v1.StateValidatorRequest")
	proto.RegisterType((*StateValidatorResponse)(nil), "ethereum.eth.v1.StateValidatorResponse")
	proto.RegisterType((*StateCommitteesRequest)(nil), "ethereum.eth.v1.StateCommitteesRequest")
	proto.RegisterType((*StateCommitteesResponse)(nil), "ethereum.eth.v1.StateCommitteesResponse")
	proto.RegisterType((*BlockAttestationsResponse)(nil), "ethereum.eth.v1.BlockAttestationsResponse")
	proto.RegisterType((*BlockRootContainer)(nil), "ethereum.eth.v1.BlockRootContainer")
	proto.RegisterType((*BlockRootResponse)(nil), "ethereum.eth.v1.BlockRootResponse")
	proto.RegisterType((*BlockHeadersRequest)(nil), "ethereum.eth.v1.BlockHeadersRequest")
	proto.RegisterType((*BlockHeadersResponse)(nil), "ethereum.eth.v1.BlockHeadersResponse")
	proto.RegisterType((*BlockRequest)(nil), "ethereum.eth.v1.BlockRequest")
	proto.RegisterType((*BlockHeaderResponse)(nil), "ethereum.eth.v1.BlockHeaderResponse")
	proto.RegisterType((*BlockHeaderContainer)(nil), "ethereum.eth.v1.BlockHeaderContainer")
	proto.RegisterType((*BeaconBlockHeaderContainer)(nil), "ethereum.eth.v1.BeaconBlockHeaderContainer")
	proto.RegisterType((*BlockResponse)(nil), "ethereum.eth.v1.BlockResponse")
	proto.RegisterType((*BeaconBlockContainer)(nil), "ethereum.eth.v1.BeaconBlockContainer")
	proto.RegisterType((*AttestationsPoolRequest)(nil), "ethereum.eth.v1.AttestationsPoolRequest")
	proto.RegisterType((*AttestationsPoolResponse)(nil), "ethereum.eth.v1.AttestationsPoolResponse")
	proto.RegisterType((*AttesterSlashingsPoolResponse)(nil), "ethereum.eth.v1.AttesterSlashingsPoolResponse")
	proto.RegisterType((*ProposerSlashingPoolResponse)(nil), "ethereum.eth.v1.ProposerSlashingPoolResponse")
	proto.RegisterType((*VoluntaryExitsPoolResponse)(nil), "ethereum.eth.v1.VoluntaryExitsPoolResponse")
	proto.RegisterType((*ForkScheduleResponse)(nil), "ethereum.eth.v1.ForkScheduleResponse")
	proto.RegisterType((*SpecResponse)(nil), "ethereum.eth.v1.SpecResponse")
	proto.RegisterMapType((map[string]string)(nil), "ethereum.eth.v1.SpecResponse.DataEntry")
	proto.RegisterType((*DepositContractResponse)(nil), "ethereum.eth.v1.DepositContractResponse")
	proto.RegisterType((*DepositContract)(nil), "ethereum.eth.v1.DepositContract")
}

func init() { proto.RegisterFile("eth/v1/beacon_chain_service.proto", fileDescriptor_33987dc4bca2a2e7) }

var fileDescriptor_33987dc4bca2a2e7 = []byte{
	// 1872 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x59, 0xdd, 0x6e, 0x1b, 0xc7,
	0x15, 0xc6, 0xca, 0xac, 0x65, 0x1e, 0x31, 0x96, 0x34, 0xd6, 0x0f, 0x45, 0xcb, 0xb2, 0x34, 0xb6,
	0x22, 0xaa, 0xae, 0xc8, 0x58, 0x8e, 0xe3, 0xd8, 0x4e, 0x0b, 0x44, 0x8a, 0xa2, 0xc8, 0x70, 0x51,
	0x65, 0xd5, 0xea, 0xa2, 0x4d, 0x40, 0xac, 0x76, 0x47, 0xe4, 0x54, 0xe4, 0xce, 0x76, 0x67, 0x48,
	0x44, 0x36, 0x0c, 0xa7, 0x3f, 0x40, 0x81, 0xf6, 0xae, 0x41, 0x81, 0xf6, 0x2e, 0x40, 0x6f, 0x8a,
	0xbe, 0x40, 0x1f, 0xa0, 0x37, 0x45, 0xaf, 0x0a, 0xf4, 0x3e, 0x28, 0x8c, 0x3e, 0x81, 0x9f, 0xa0,
	0xd8, 0xd9, 0xd9, 0x7f, 0x2e, 0x97, 0x72, 0xee, 0x38, 0x33, 0xe7, 0x7c, 0xe7, 0x3b, 0x67, 0x67,
	0xcf, 0x7e, 0x07, 0x84, 0x35, 0x22, 0x3a, 0xcd, 0xc1, 0xdd, 0xe6, 0x09, 0x31, 0x4c, 0x66, 0xb7,
	0xcc, 0x8e, 0x41, 0xed, 0x16, 0x27, 0xee, 0x80, 0x9a, 0xa4, 0xe1, 0xb8, 0x4c, 0x30, 0x34, 0x4d,
	0x44, 0x87, 0xb8, 0xa4, 0xdf, 0x6b, 0x10, 0xd1, 0x69, 0x0c, 0xee, 0xd6, 0xb6, 0xda, 0x54, 0x74,
	0xfa, 0x27, 0x0d, 0x93, 0xf5, 0x9a, 0x6d, 0xd6, 0x66, 0x4d, 0x69, 0x77, 0xd2, 0x3f, 0x95, 0x2b,
	0xb9, 0x90, 0xbf, 0x7c, 0xff, 0xda, 0x72, 0x9b, 0xb1, 0x76, 0x97, 0x34, 0x0d, 0x87, 0x36, 0x0d,
	0xdb, 0x66, 0xc2, 0x10, 0x94, 0xd9, 0x5c, 0x9d, 0x5e, 0x57, 0xa7, 0x21, 0x06, 0xe9, 0x39, 0xe2,
	0x5c, 0x1d, 0x56, 0x15, 0x3b, 0x43, 0x08, 0xc2, 0x7d, 0x3f, 0x75, 0xb2, 0x94, 0xe4, 0x7d, 0xd2,
	0x65, 0xe6, 0xd9, 0xf0, 0x23, 0xcf, 0x4f, 0xa5, 0x52, 0x5b, 0x50, 0x47, 0x03, 0xa3, 0x4b, 0x2d,
	0x43, 0x30, 0xd7, 0xdf, 0xc7, 0xff, 0xd0, 0x60, 0x7a, 0x9f, 0xd8, 0x84, 0x53, 0xae, 0x13, 0xee,
	0x30, 0x9b, 0x13, 0xb4, 0x06, 0x95, 0xb6, 0xbf, 0xd5, 0x12, 0xb4, 0x47, 0xaa, 0xda, 0xaa, 0x56,
	0x2f, 0xe9, 0x53, 0x6a, 0xef, 0xc7, 0xb4, 0x47, 0xd0, 0x01, 0x2c, 0x06, 0x26, 0x21, 0x22, 0x6f,
	0xb9, 0x8c, 0x89, 0xea, 0xc4, 0xaa, 0x56, 0xaf, 0xec, 0xcc, 0xbe, 0xfe, 0xe6, 0xe6, 0x5b, 0x9c,
	0x3f, 0xdb, 0xe2, 0xf4, 0x19, 0x79, 0x84, 0xef, 0x6d, 0x63, 0x7d, 0x5e, 0x79, 0x1c, 0x87, 0x0e,
	0x3a, 0x63, 0x02, 0xed, 0xc0, 0x5c, 0x00, 0x75, 0xca, 0xdc, 0xb3, 0xd6, 0x80, 0xb8, 0x9c, 0x32,
	0xbb, 0x7a, 0x49, 0xe2, 0xcc, 0xbc, 0xfe, 0xe6, 0x66, 0x25, 0xc2, 0x79, 0x17, 0xeb, 0x48, 0x59,
	0x7f, 0xcc, 0xdc, 0xb3, 0x63, 0xdf, 0x16, 0x6f, 0x42, 0xe5, 0xc8, 0x4b, 0x56, 0x27, 0xbf, 0xe8,
	0x13, 0x2e, 0xd0, 0x12, 0x5c, 0x91, 0xc9, 0xb7, 0xa8, 0x25, 0xd9, 0x97, 0xf5, 0x49, 0xb9, 0x3e,
	0xb0, 0xf0, 0x1e, 0xcc, 0xfa, 0xa6, 0x8c, 0x89, 0x30, 0xe3, 0x77, 0x00, 0x7c, 0x7b, 0x99, 0x81,
	0x96, 0x97, 0x41, 0x99, 0x07, 0x9e, 0xf8, 0x07, 0x0a, 0xc6, 0x63, 0x11, 0xc2, 0x6c, 0x42, 0xc9,
	0x4b, 0x41, 0x02, 0x4c, 0x6d, 0xcf, 0x37, 0x52, 0xd7, 0xa7, 0x21, 0x8d, 0xa5, 0x09, 0x7e, 0xad,
	0xc1, 0x4d, 0x1f, 0x80, 0xda, 0x46, 0x97, 0x8a, 0xf3, 0xdd, 0x0e, 0x31, 0xcf, 0x1c, 0x46, 0xed,
	0x88, 0xd5, 0x13, 0x40, 0x8e, 0x4b, 0x06, 0x94, 0xf5, 0x79, 0xeb, 0xe7, 0x7d, 0x2e, 0xe8, 0x29,
	0x25, 0x96, 0x02, 0xbf, 0x9e, 0x01, 0x8f, 0x01, 0xcc, 0x06, 0x6e, 0x4f, 0x02, 0x2f, 0xf4, 0x09,
	0xcc, 0x9a, 0x7d, 0xd7, 0x25, 0xb6, 0x88, 0x41, 0x4d, 0x14, 0x43, 0xcd, 0x28, 0xaf, 0x08, 0xe9,
	0x21, 0x94, 0x4f, 0x25, 0xe7, 0x67, 0xc4, 0x92, 0x0f, 0xa9, 0x00, 0x21, 0xb2, 0xc6, 0x3f, 0x83,
	0x05, 0x99, 0x73, 0xec, 0x06, 0x14, 0x3e, 0x30, 0x74, 0x15, 0x26, 0xa8, 0x47, 0xf5, 0x52, 0xbd,
	0xac, 0x4f, 0x50, 0x0b, 0x2d, 0xc0, 0x65, 0xef, 0xa8, 0xcf, 0x65, 0xf0, 0xb2, 0xae, 0x56, 0x58,
	0x87, 0xc5, 0x0c, 0xb8, 0x2a, 0xe4, 0x03, 0x28, 0x59, 0x86, 0x30, 0xaa, 0xda, 0xea, 0xa5, 0xfa,
	0xd4, 0xf6, 0xad, 0x0c, 0xdb, 0xd0, 0x65, 0x97, 0xd9, 0xc2, 0xa0, 0x36, 0x71, 0x75, 0xe9, 0x80,
	0x7f, 0x02, 0xf3, 0x49, 0xcc, 0x31, 0xf8, 0xae, 0x41, 0x25, 0x7c, 0x25, 0x5a, 0xd4, 0x2f, 0x72,
	0x59, 0x9f, 0x0a, 0xf7, 0x0e, 0x2c, 0xfc, 0x69, 0xba, 0x0e, 0x43, 0x98, 0x6a, 0x17, 0x63, 0xca,
	0x15, 0xe4, 0x2e, 0xeb, 0xf5, 0xa8, 0x10, 0x84, 0x8c, 0x53, 0xda, 0x39, 0xf8, 0x0e, 0x71, 0x98,
	0xd9, 0x91, 0x1c, 0x4b, 0xba, 0xbf, 0xf0, 0x76, 0xa9, 0x6d, 0x91, 0x2f, 0x64, 0x7d, 0x4b, 0xba,
	0xbf, 0x40, 0x08, 0x4a, 0xbc, 0xcb, 0x44, 0xb5, 0x24, 0x37, 0xe5, 0x6f, 0x7c, 0xa0, 0x4a, 0x1e,
	0x0f, 0xaa, 0x12, 0x69, 0x24, 0x4a, 0x5e, 0xcb, 0x5e, 0x90, 0xc0, 0x45, 0xf1, 0xff, 0x21, 0x2c,
	0xed, 0x78, 0x9d, 0xec, 0xc3, 0xa8, 0xdf, 0xf1, 0xd8, 0xeb, 0x19, 0x07, 0x5b, 0xce, 0x80, 0xc5,
	0x9c, 0x14, 0xdc, 0x63, 0x40, 0x12, 0xce, 0x7b, 0x57, 0xc3, 0x52, 0xa1, 0x75, 0x28, 0x8d, 0x7e,
	0xc1, 0xe5, 0x31, 0x7e, 0x0a, 0xb3, 0xa1, 0xf3, 0xd8, 0x4f, 0x26, 0x1b, 0x4e, 0x51, 0xf9, 0x1c,
	0xae, 0xc9, 0xb3, 0x4f, 0x88, 0x61, 0x91, 0xe8, 0xc6, 0x07, 0xf5, 0xd4, 0xa2, 0x7a, 0xa2, 0x6d,
	0x98, 0x72, 0x0c, 0xf9, 0x8e, 0x8e, 0xee, 0xa4, 0xe0, 0x5b, 0xc9, 0x46, 0xf4, 0x29, 0xcc, 0x25,
	0xe1, 0x15, 0xdf, 0x87, 0x89, 0x9a, 0xad, 0x0f, 0xe7, 0xeb, 0x3b, 0xa5, 0x19, 0x6f, 0x42, 0xc5,
	0xcf, 0x26, 0xba, 0x41, 0xf2, 0x2b, 0x13, 0xdc, 0xa0, 0x8a, 0x3e, 0x29, 0xd7, 0x07, 0x16, 0x3e,
	0x4c, 0x24, 0x37, 0x24, 0xb8, 0x76, 0xd1, 0xe0, 0x5f, 0x6b, 0x89, 0x84, 0x2e, 0xfa, 0xf0, 0xd0,
	0x32, 0x94, 0x4d, 0xc3, 0x66, 0x36, 0x35, 0x8d, 0xae, 0xac, 0xe0, 0x15, 0x3d, 0xda, 0x40, 0xbb,
	0x70, 0xb9, 0x23, 0x71, 0x55, 0xe7, 0xba, 0x93, 0xa5, 0x26, 0xbf, 0x9d, 0x43, 0x09, 0x2a, 0x57,
	0xfc, 0x7b, 0x0d, 0x6a, 0xf9, 0x66, 0xe8, 0x03, 0x98, 0xec, 0x11, 0xce, 0x8d, 0x36, 0x51, 0xf9,
	0xe3, 0xe2, 0x20, 0x7a, 0xe0, 0x82, 0x9a, 0x50, 0xe6, 0xb4, 0x6d, 0x1b, 0xa2, 0xef, 0x92, 0xe1,
	0x37, 0xe0, 0xe1, 0x7b, 0xde, 0x97, 0x28, 0xb0, 0xc1, 0x4f, 0xe0, 0x2d, 0xf5, 0xb4, 0xc6, 0x2d,
	0x7e, 0x14, 0x3c, 0x5d, 0xfc, 0x97, 0x30, 0x37, 0xec, 0x14, 0xbd, 0x97, 0x4e, 0x69, 0x79, 0x14,
	0xea, 0xb7, 0x48, 0xe6, 0x18, 0x16, 0xe3, 0x1d, 0xe0, 0x90, 0xb1, 0xee, 0xa8, 0x17, 0x66, 0x03,
	0xa6, 0xcd, 0xa0, 0x91, 0xb4, 0xfc, 0xa6, 0xe5, 0xb7, 0xb2, 0xab, 0xe1, 0xf6, 0x81, 0xb7, 0x8b,
	0x9f, 0x42, 0x35, 0x8b, 0xfb, 0xc6, 0xdd, 0xe5, 0x18, 0x6e, 0xf8, 0x9b, 0xc4, 0x3d, 0xea, 0x1a,
	0xbc, 0x43, 0xed, 0x76, 0x12, 0xf2, 0x7e, 0x02, 0x72, 0x2d, 0x07, 0x32, 0xf2, 0x0e, 0x3f, 0x37,
	0xcb, 0x87, 0x2e, 0x73, 0x18, 0x8f, 0x4e, 0x2e, 0x04, 0x9b, 0x76, 0x0e, 0xe9, 0xd6, 0x8e, 0x59,
	0xb7, 0x6f, 0x0b, 0xc3, 0x3d, 0xdf, 0xfb, 0x82, 0x8a, 0x24, 0xd7, 0xf7, 0x13, 0xa0, 0xb7, 0x33,
	0xa0, 0x47, 0xb4, 0x6d, 0x13, 0x2b, 0x01, 0xa0, 0x70, 0x3f, 0x84, 0x39, 0x4f, 0xd1, 0x1c, 0x99,
	0x1d, 0x62, 0xf5, 0xbb, 0x24, 0x2e, 0x83, 0x62, 0x17, 0x30, 0x4f, 0x06, 0x49, 0x88, 0xdf, 0x68,
	0x50, 0x39, 0x72, 0x88, 0x19, 0xfa, 0x3e, 0x4e, 0xb0, 0xd9, 0xc8, 0xb2, 0x89, 0x19, 0x37, 0x3e,
	0x32, 0x84, 0xb1, 0x67, 0x0b, 0xf7, 0xdc, 0x47, 0xab, 0x3d, 0x80, 0x72, 0xb8, 0x85, 0x66, 0xe0,
	0xd2, 0x19, 0x39, 0x57, 0x9f, 0x3c, 0xef, 0xa7, 0xf7, 0x61, 0x1b, 0x18, 0xdd, 0x3e, 0x51, 0x9f,
	0x64, 0x7f, 0xf1, 0x68, 0xe2, 0x7d, 0x0d, 0xff, 0x08, 0x16, 0x3f, 0x22, 0x0e, 0xe3, 0x54, 0x76,
	0x6f, 0xd7, 0x30, 0xa3, 0xbe, 0xff, 0x6e, 0x22, 0x99, 0xd5, 0x0c, 0xa1, 0xb4, 0x9f, 0x9f, 0xd7,
	0xc7, 0x30, 0x9d, 0x3a, 0xf0, 0xba, 0xa8, 0x3f, 0x63, 0xa8, 0x2e, 0x5a, 0xd2, 0x27, 0xe5, 0xfa,
	0xc0, 0x42, 0x55, 0x98, 0x34, 0x2c, 0xcb, 0x25, 0x9c, 0x2b, 0x6a, 0xc1, 0x72, 0xfb, 0xef, 0x4b,
	0x30, 0xe5, 0xbf, 0x59, 0xbb, 0x9e, 0x2d, 0x3a, 0x05, 0xd8, 0x27, 0x42, 0x09, 0x76, 0xb4, 0xd0,
	0xf0, 0x47, 0x88, 0x46, 0x30, 0x42, 0x34, 0xf6, 0xbc, 0x11, 0xa2, 0x96, 0x65, 0x99, 0x92, 0xf8,
	0x78, 0xe5, 0x57, 0xff, 0xf9, 0xdf, 0x57, 0x13, 0x55, 0xb4, 0xd0, 0x4c, 0x8c, 0x0c, 0x4d, 0xa5,
	0xad, 0xd1, 0x97, 0x1a, 0x54, 0xf6, 0x89, 0x08, 0x95, 0x32, 0xba, 0x91, 0x7d, 0x12, 0x31, 0xc1,
	0x5d, 0xc3, 0x39, 0xc7, 0xb1, 0x2f, 0x28, 0xde, 0x92, 0x31, 0x37, 0xd0, 0x7a, 0x2a, 0xa6, 0x54,
	0x23, 0xbc, 0xf9, 0x3c, 0x50, 0x29, 0x2f, 0x9a, 0xb2, 0x91, 0xc7, 0x29, 0x78, 0x37, 0xe6, 0x0d,
	0x29, 0xc4, 0x05, 0xfa, 0x05, 0x28, 0x78, 0x22, 0x1d, 0xfd, 0x55, 0x83, 0x85, 0x7d, 0x22, 0xb2,
	0x12, 0x9d, 0x17, 0x91, 0x79, 0x27, 0x87, 0x4c, 0xae, 0xd8, 0xc7, 0xdf, 0x97, 0xd4, 0x1e, 0xa0,
	0xfb, 0xc5, 0xd4, 0x14, 0x48, 0xcb, 0x8c, 0xf1, 0xf9, 0x93, 0x06, 0x57, 0x9f, 0x52, 0x2e, 0x22,
	0xf5, 0x8b, 0x36, 0x86, 0x73, 0xc8, 0x88, 0xef, 0x5a, 0xbd, 0xd8, 0x50, 0x91, 0xbc, 0x27, 0x49,
	0x6e, 0xa1, 0x3b, 0x85, 0x24, 0xa3, 0xa9, 0x10, 0xfd, 0xc5, 0x7f, 0x90, 0x21, 0x1c, 0x7a, 0xbb,
	0x20, 0x5e, 0xc0, 0x6b, 0xa3, 0xd0, 0x4e, 0xd1, 0xda, 0x91, 0xb4, 0x3e, 0x40, 0x8f, 0x2e, 0x40,
	0xab, 0xf9, 0x3c, 0xae, 0xd2, 0x5f, 0xa0, 0xaf, 0x55, 0x01, 0x23, 0x2d, 0x9b, 0x57, 0xc0, 0x8c,
	0xc4, 0xce, 0x2b, 0x60, 0x56, 0x16, 0xe3, 0xc7, 0x92, 0xe9, 0x7d, 0x74, 0xaf, 0x90, 0x69, 0xf8,
	0x01, 0xe3, 0xcd, 0xe7, 0x52, 0x97, 0xbf, 0xf0, 0xde, 0x88, 0xab, 0xfb, 0x44, 0xc4, 0x64, 0xc3,
	0x90, 0x6b, 0x18, 0x57, 0x6e, 0xb5, 0xdb, 0xa3, 0x94, 0x57, 0x48, 0x6a, 0x53, 0x92, 0xba, 0x85,
	0xd6, 0x52, 0xa4, 0x7c, 0xb9, 0xc3, 0x9b, 0xcf, 0x03, 0xf5, 0xf7, 0x02, 0xbd, 0x84, 0x19, 0xaf,
	0x48, 0x71, 0xc5, 0x89, 0x46, 0x06, 0x09, 0x6b, 0xb4, 0x5e, 0x60, 0x55, 0xd0, 0x98, 0x14, 0x17,
	0x44, 0xa1, 0x7c, 0xc8, 0x14, 0x01, 0x34, 0x9e, 0xb6, 0xa9, 0xe5, 0xb4, 0x49, 0x7c, 0x43, 0xc6,
	0x5a, 0xc4, 0xf3, 0xa9, 0x58, 0x32, 0x5d, 0x8e, 0x38, 0x5c, 0x09, 0xaa, 0x5d, 0x54, 0xe7, 0x95,
	0xbc, 0x63, 0x95, 0x55, 0x5d, 0x46, 0xc2, 0x68, 0x75, 0x68, 0xa4, 0x78, 0x81, 0x55, 0xd7, 0x0b,
	0xa7, 0x89, 0xa2, 0xc8, 0x38, 0x7f, 0x10, 0x29, 0xec, 0x7a, 0x99, 0xe8, 0x7e, 0xe3, 0xfd, 0xb3,
	0x06, 0xf3, 0xe1, 0x43, 0x8e, 0xab, 0xa6, 0x22, 0x2e, 0xdf, 0x1d, 0x7e, 0x3c, 0x6c, 0xa4, 0xc3,
	0xf7, 0x25, 0xa7, 0x26, 0xda, 0x2a, 0xe4, 0x64, 0xc4, 0x19, 0xfc, 0x51, 0x83, 0x39, 0x8f, 0x9b,
	0xa7, 0x60, 0x12, 0xd4, 0xea, 0xa3, 0x64, 0x5b, 0x5c, 0x47, 0xd6, 0x36, 0xc7, 0xb0, 0x2c, 0x78,
	0x6c, 0x0e, 0x63, 0xdd, 0x24, 0x2f, 0x0e, 0xb3, 0x47, 0xfd, 0x93, 0x1e, 0x15, 0x31, 0x2c, 0x34,
	0x52, 0x4a, 0xe6, 0xde, 0x4a, 0x15, 0x14, 0x17, 0x07, 0xfd, 0x4a, 0x83, 0xa5, 0x64, 0x31, 0x62,
	0x7a, 0x34, 0x57, 0x1c, 0x34, 0x0a, 0xd5, 0x68, 0xb2, 0x08, 0x0d, 0xc9, 0xa7, 0x8e, 0xde, 0xce,
	0xe7, 0x43, 0xdc, 0x16, 0x0f, 0xe3, 0xfe, 0x52, 0x83, 0x39, 0xef, 0x15, 0x4d, 0xa3, 0xa2, 0x62,
	0x19, 0x9c, 0x5b, 0x13, 0xc5, 0x01, 0x8f, 0xcb, 0xe1, 0x0f, 0xb1, 0xca, 0xa4, 0x45, 0x71, 0x7e,
	0x65, 0xb6, 0x0a, 0x05, 0xf5, 0xf8, 0x85, 0x71, 0x94, 0x67, 0x8c, 0xd4, 0xaf, 0x35, 0x58, 0xf0,
	0x2f, 0x49, 0x1a, 0x16, 0x15, 0x4b, 0xf9, 0x37, 0x2b, 0xcd, 0x10, 0x16, 0xbf, 0xd3, 0x60, 0x21,
	0x28, 0x4d, 0x72, 0x2a, 0xc8, 0xad, 0x4b, 0x76, 0x48, 0xce, 0x1f, 0x27, 0xf0, 0x1d, 0xc9, 0x67,
	0x1d, 0xdd, 0x1a, 0xc6, 0x67, 0x10, 0xf8, 0xb5, 0x88, 0x8c, 0xf8, 0xa5, 0x06, 0xd7, 0xfc, 0x92,
	0x24, 0x10, 0xd1, 0x58, 0x53, 0x48, 0x6e, 0x49, 0x14, 0x05, 0x3c, 0x16, 0x85, 0x01, 0x4c, 0x7b,
	0x12, 0x2f, 0x36, 0xc7, 0xe4, 0xd6, 0x61, 0x7d, 0xe8, 0x24, 0x93, 0x1e, 0x7f, 0xf0, 0x6d, 0x19,
	0x7e, 0x05, 0x2d, 0x07, 0xe1, 0x4d, 0x66, 0x9f, 0xd2, 0xb6, 0x94, 0x94, 0x2d, 0x1e, 0x04, 0xf9,
	0x1c, 0x26, 0x3d, 0x75, 0xeb, 0x10, 0x33, 0x37, 0xde, 0x8d, 0x91, 0xd3, 0x0f, 0xbe, 0x2e, 0xe3,
	0xcc, 0xa3, 0x6b, 0xa9, 0x38, 0xdc, 0xc3, 0x7c, 0x09, 0x68, 0x9f, 0x88, 0xf4, 0x0c, 0x92, 0x17,
	0xa9, 0x5e, 0x38, 0xd6, 0x04, 0x41, 0x37, 0x64, 0xd0, 0x35, 0x74, 0x33, 0x15, 0xd4, 0xf2, 0xed,
	0x5b, 0xa6, 0x72, 0xd8, 0xf9, 0xad, 0xf6, 0xcf, 0x57, 0x2b, 0xda, 0xbf, 0x5f, 0xad, 0x68, 0xff,
	0x7d, 0xb5, 0xa2, 0xc1, 0x35, 0xe6, 0xb6, 0xd3, 0x41, 0x76, 0x66, 0x62, 0xa3, 0xcd, 0xa1, 0xc7,
	0xe8, 0x50, 0xfb, 0xe9, 0xf7, 0x62, 0x7f, 0xb1, 0x38, 0xee, 0x39, 0xef, 0x19, 0x82, 0x9a, 0x5d,
	0xe3, 0x84, 0x37, 0x03, 0x6f, 0xc3, 0xa1, 0x5c, 0x45, 0xff, 0xdb, 0xc4, 0xf4, 0x5e, 0x80, 0xb9,
	0x27, 0x31, 0xff, 0x15, 0xed, 0x7c, 0xb6, 0x27, 0x3a, 0x9f, 0x0d, 0xee, 0x9e, 0x5c, 0x96, 0xc9,
	0xde, 0xfb, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x11, 0xe7, 0x6e, 0x6a, 0xf1, 0x19, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BeaconChainClient is the client API for BeaconChain service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BeaconChainClient interface {
	GetGenesis(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*GenesisResponse, error)
	GetStateRoot(ctx context.Context, in *StateRequest, opts ...grpc.CallOption) (*StateRootResponse, error)
	GetStateFork(ctx context.Context, in *StateRequest, opts ...grpc.CallOption) (*StateForkResponse, error)
	GetFinalityCheckpoints(ctx context.Context, in *StateRequest, opts ...grpc.CallOption) (*StateFinalityCheckpointResponse, error)
	ListValidators(ctx context.Context, in *StateValidatorsRequest, opts ...grpc.CallOption) (*StateValidatorsResponse, error)
	GetValidator(ctx context.Context, in *StateValidatorRequest, opts ...grpc.CallOption) (*StateValidatorResponse, error)
	ListCommittees(ctx context.Context, in *StateCommitteesRequest, opts ...grpc.CallOption) (*StateCommitteesResponse, error)
	GetBlockHeader(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BlockHeaderResponse, error)
	ListBlockHeaders(ctx context.Context, in *BlockHeadersRequest, opts ...grpc.CallOption) (*BlockHeadersResponse, error)
	PostBlock(ctx context.Context, in *BeaconBlockContainer, opts ...grpc.CallOption) (*types.Empty, error)
	GetBlock(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BlockResponse, error)
	GetBlockRoot(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BlockRootResponse, error)
	ListBlockAttestations(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BlockAttestationsResponse, error)
	ListPoolAttestations(ctx context.Context, in *AttestationsPoolRequest, opts ...grpc.CallOption) (*AttestationsPoolResponse, error)
	SubmitAttestation(ctx context.Context, in *Attestation, opts ...grpc.CallOption) (*types.Empty, error)
	ListPoolAttesterSlashings(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*AttesterSlashingsPoolResponse, error)
	PostAttesterSlashing(ctx context.Context, in *AttesterSlashing, opts ...grpc.CallOption) (*types.Empty, error)
	ListPoolProposerSlashings(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*ProposerSlashingPoolResponse, error)
	SubmitProposerSlashing(ctx context.Context, in *ProposerSlashing, opts ...grpc.CallOption) (*types.Empty, error)
	ListPoolVoluntaryExits(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*VoluntaryExitsPoolResponse, error)
	SubmitVoluntaryExit(ctx context.Context, in *SignedVoluntaryExit, opts ...grpc.CallOption) (*types.Empty, error)
	GetForkSchedule(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*ForkScheduleResponse, error)
	GetSpec(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*SpecResponse, error)
	GetDepositContract(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*DepositContractResponse, error)
}

type beaconChainClient struct {
	cc *grpc.ClientConn
}

func NewBeaconChainClient(cc *grpc.ClientConn) BeaconChainClient {
	return &beaconChainClient{cc}
}

func (c *beaconChainClient) GetGenesis(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*GenesisResponse, error) {
	out := new(GenesisResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/GetGenesis", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetStateRoot(ctx context.Context, in *StateRequest, opts ...grpc.CallOption) (*StateRootResponse, error) {
	out := new(StateRootResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/GetStateRoot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetStateFork(ctx context.Context, in *StateRequest, opts ...grpc.CallOption) (*StateForkResponse, error) {
	out := new(StateForkResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/GetStateFork", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetFinalityCheckpoints(ctx context.Context, in *StateRequest, opts ...grpc.CallOption) (*StateFinalityCheckpointResponse, error) {
	out := new(StateFinalityCheckpointResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/GetFinalityCheckpoints", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListValidators(ctx context.Context, in *StateValidatorsRequest, opts ...grpc.CallOption) (*StateValidatorsResponse, error) {
	out := new(StateValidatorsResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/ListValidators", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetValidator(ctx context.Context, in *StateValidatorRequest, opts ...grpc.CallOption) (*StateValidatorResponse, error) {
	out := new(StateValidatorResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/GetValidator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListCommittees(ctx context.Context, in *StateCommitteesRequest, opts ...grpc.CallOption) (*StateCommitteesResponse, error) {
	out := new(StateCommitteesResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/ListCommittees", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetBlockHeader(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BlockHeaderResponse, error) {
	out := new(BlockHeaderResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/GetBlockHeader", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListBlockHeaders(ctx context.Context, in *BlockHeadersRequest, opts ...grpc.CallOption) (*BlockHeadersResponse, error) {
	out := new(BlockHeadersResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/ListBlockHeaders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) PostBlock(ctx context.Context, in *BeaconBlockContainer, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/PostBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetBlock(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BlockResponse, error) {
	out := new(BlockResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/GetBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetBlockRoot(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BlockRootResponse, error) {
	out := new(BlockRootResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/GetBlockRoot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListBlockAttestations(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BlockAttestationsResponse, error) {
	out := new(BlockAttestationsResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/ListBlockAttestations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListPoolAttestations(ctx context.Context, in *AttestationsPoolRequest, opts ...grpc.CallOption) (*AttestationsPoolResponse, error) {
	out := new(AttestationsPoolResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/ListPoolAttestations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) SubmitAttestation(ctx context.Context, in *Attestation, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/SubmitAttestation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListPoolAttesterSlashings(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*AttesterSlashingsPoolResponse, error) {
	out := new(AttesterSlashingsPoolResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/ListPoolAttesterSlashings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) PostAttesterSlashing(ctx context.Context, in *AttesterSlashing, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/PostAttesterSlashing", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListPoolProposerSlashings(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*ProposerSlashingPoolResponse, error) {
	out := new(ProposerSlashingPoolResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/ListPoolProposerSlashings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) SubmitProposerSlashing(ctx context.Context, in *ProposerSlashing, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/SubmitProposerSlashing", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListPoolVoluntaryExits(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*VoluntaryExitsPoolResponse, error) {
	out := new(VoluntaryExitsPoolResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/ListPoolVoluntaryExits", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) SubmitVoluntaryExit(ctx context.Context, in *SignedVoluntaryExit, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/SubmitVoluntaryExit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetForkSchedule(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*ForkScheduleResponse, error) {
	out := new(ForkScheduleResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/GetForkSchedule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetSpec(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*SpecResponse, error) {
	out := new(SpecResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/GetSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetDepositContract(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*DepositContractResponse, error) {
	out := new(DepositContractResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/GetDepositContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BeaconChainServer is the server API for BeaconChain service.
type BeaconChainServer interface {
	GetGenesis(context.Context, *types.Empty) (*GenesisResponse, error)
	GetStateRoot(context.Context, *StateRequest) (*StateRootResponse, error)
	GetStateFork(context.Context, *StateRequest) (*StateForkResponse, error)
	GetFinalityCheckpoints(context.Context, *StateRequest) (*StateFinalityCheckpointResponse, error)
	ListValidators(context.Context, *StateValidatorsRequest) (*StateValidatorsResponse, error)
	GetValidator(context.Context, *StateValidatorRequest) (*StateValidatorResponse, error)
	ListCommittees(context.Context, *StateCommitteesRequest) (*StateCommitteesResponse, error)
	GetBlockHeader(context.Context, *BlockRequest) (*BlockHeaderResponse, error)
	ListBlockHeaders(context.Context, *BlockHeadersRequest) (*BlockHeadersResponse, error)
	PostBlock(context.Context, *BeaconBlockContainer) (*types.Empty, error)
	GetBlock(context.Context, *BlockRequest) (*BlockResponse, error)
	GetBlockRoot(context.Context, *BlockRequest) (*BlockRootResponse, error)
	ListBlockAttestations(context.Context, *BlockRequest) (*BlockAttestationsResponse, error)
	ListPoolAttestations(context.Context, *AttestationsPoolRequest) (*AttestationsPoolResponse, error)
	SubmitAttestation(context.Context, *Attestation) (*types.Empty, error)
	ListPoolAttesterSlashings(context.Context, *types.Empty) (*AttesterSlashingsPoolResponse, error)
	PostAttesterSlashing(context.Context, *AttesterSlashing) (*types.Empty, error)
	ListPoolProposerSlashings(context.Context, *types.Empty) (*ProposerSlashingPoolResponse, error)
	SubmitProposerSlashing(context.Context, *ProposerSlashing) (*types.Empty, error)
	ListPoolVoluntaryExits(context.Context, *types.Empty) (*VoluntaryExitsPoolResponse, error)
	SubmitVoluntaryExit(context.Context, *SignedVoluntaryExit) (*types.Empty, error)
	GetForkSchedule(context.Context, *types.Empty) (*ForkScheduleResponse, error)
	GetSpec(context.Context, *types.Empty) (*SpecResponse, error)
	GetDepositContract(context.Context, *types.Empty) (*DepositContractResponse, error)
}

// UnimplementedBeaconChainServer can be embedded to have forward compatible implementations.
type UnimplementedBeaconChainServer struct {
}

func (*UnimplementedBeaconChainServer) GetGenesis(ctx context.Context, req *types.Empty) (*GenesisResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGenesis not implemented")
}
func (*UnimplementedBeaconChainServer) GetStateRoot(ctx context.Context, req *StateRequest) (*StateRootResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStateRoot not implemented")
}
func (*UnimplementedBeaconChainServer) GetStateFork(ctx context.Context, req *StateRequest) (*StateForkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStateFork not implemented")
}
func (*UnimplementedBeaconChainServer) GetFinalityCheckpoints(ctx context.Context, req *StateRequest) (*StateFinalityCheckpointResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFinalityCheckpoints not implemented")
}
func (*UnimplementedBeaconChainServer) ListValidators(ctx context.Context, req *StateValidatorsRequest) (*StateValidatorsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListValidators not implemented")
}
func (*UnimplementedBeaconChainServer) GetValidator(ctx context.Context, req *StateValidatorRequest) (*StateValidatorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetValidator not implemented")
}
func (*UnimplementedBeaconChainServer) ListCommittees(ctx context.Context, req *StateCommitteesRequest) (*StateCommitteesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCommittees not implemented")
}
func (*UnimplementedBeaconChainServer) GetBlockHeader(ctx context.Context, req *BlockRequest) (*BlockHeaderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockHeader not implemented")
}
func (*UnimplementedBeaconChainServer) ListBlockHeaders(ctx context.Context, req *BlockHeadersRequest) (*BlockHeadersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBlockHeaders not implemented")
}
func (*UnimplementedBeaconChainServer) PostBlock(ctx context.Context, req *BeaconBlockContainer) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostBlock not implemented")
}
func (*UnimplementedBeaconChainServer) GetBlock(ctx context.Context, req *BlockRequest) (*BlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlock not implemented")
}
func (*UnimplementedBeaconChainServer) GetBlockRoot(ctx context.Context, req *BlockRequest) (*BlockRootResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockRoot not implemented")
}
func (*UnimplementedBeaconChainServer) ListBlockAttestations(ctx context.Context, req *BlockRequest) (*BlockAttestationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBlockAttestations not implemented")
}
func (*UnimplementedBeaconChainServer) ListPoolAttestations(ctx context.Context, req *AttestationsPoolRequest) (*AttestationsPoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPoolAttestations not implemented")
}
func (*UnimplementedBeaconChainServer) SubmitAttestation(ctx context.Context, req *Attestation) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitAttestation not implemented")
}
func (*UnimplementedBeaconChainServer) ListPoolAttesterSlashings(ctx context.Context, req *types.Empty) (*AttesterSlashingsPoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPoolAttesterSlashings not implemented")
}
func (*UnimplementedBeaconChainServer) PostAttesterSlashing(ctx context.Context, req *AttesterSlashing) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostAttesterSlashing not implemented")
}
func (*UnimplementedBeaconChainServer) ListPoolProposerSlashings(ctx context.Context, req *types.Empty) (*ProposerSlashingPoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPoolProposerSlashings not implemented")
}
func (*UnimplementedBeaconChainServer) SubmitProposerSlashing(ctx context.Context, req *ProposerSlashing) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitProposerSlashing not implemented")
}
func (*UnimplementedBeaconChainServer) ListPoolVoluntaryExits(ctx context.Context, req *types.Empty) (*VoluntaryExitsPoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPoolVoluntaryExits not implemented")
}
func (*UnimplementedBeaconChainServer) SubmitVoluntaryExit(ctx context.Context, req *SignedVoluntaryExit) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitVoluntaryExit not implemented")
}
func (*UnimplementedBeaconChainServer) GetForkSchedule(ctx context.Context, req *types.Empty) (*ForkScheduleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetForkSchedule not implemented")
}
func (*UnimplementedBeaconChainServer) GetSpec(ctx context.Context, req *types.Empty) (*SpecResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSpec not implemented")
}
func (*UnimplementedBeaconChainServer) GetDepositContract(ctx context.Context, req *types.Empty) (*DepositContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDepositContract not implemented")
}

func RegisterBeaconChainServer(s *grpc.Server, srv BeaconChainServer) {
	s.RegisterService(&_BeaconChain_serviceDesc, srv)
}

func _BeaconChain_GetGenesis_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetGenesis(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/GetGenesis",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetGenesis(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetStateRoot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetStateRoot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/GetStateRoot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetStateRoot(ctx, req.(*StateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetStateFork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetStateFork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/GetStateFork",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetStateFork(ctx, req.(*StateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetFinalityCheckpoints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetFinalityCheckpoints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/GetFinalityCheckpoints",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetFinalityCheckpoints(ctx, req.(*StateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListValidators_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateValidatorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListValidators(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/ListValidators",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListValidators(ctx, req.(*StateValidatorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetValidator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateValidatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetValidator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/GetValidator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetValidator(ctx, req.(*StateValidatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListCommittees_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateCommitteesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListCommittees(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/ListCommittees",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListCommittees(ctx, req.(*StateCommitteesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetBlockHeader_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetBlockHeader(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/GetBlockHeader",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetBlockHeader(ctx, req.(*BlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListBlockHeaders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHeadersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListBlockHeaders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/ListBlockHeaders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListBlockHeaders(ctx, req.(*BlockHeadersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_PostBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BeaconBlockContainer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).PostBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/PostBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).PostBlock(ctx, req.(*BeaconBlockContainer))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/GetBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetBlock(ctx, req.(*BlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetBlockRoot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetBlockRoot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/GetBlockRoot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetBlockRoot(ctx, req.(*BlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListBlockAttestations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListBlockAttestations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/ListBlockAttestations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListBlockAttestations(ctx, req.(*BlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListPoolAttestations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttestationsPoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListPoolAttestations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/ListPoolAttestations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListPoolAttestations(ctx, req.(*AttestationsPoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_SubmitAttestation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Attestation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).SubmitAttestation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/SubmitAttestation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).SubmitAttestation(ctx, req.(*Attestation))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListPoolAttesterSlashings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListPoolAttesterSlashings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/ListPoolAttesterSlashings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListPoolAttesterSlashings(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_PostAttesterSlashing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttesterSlashing)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).PostAttesterSlashing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/PostAttesterSlashing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).PostAttesterSlashing(ctx, req.(*AttesterSlashing))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListPoolProposerSlashings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListPoolProposerSlashings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/ListPoolProposerSlashings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListPoolProposerSlashings(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_SubmitProposerSlashing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProposerSlashing)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).SubmitProposerSlashing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/SubmitProposerSlashing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).SubmitProposerSlashing(ctx, req.(*ProposerSlashing))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListPoolVoluntaryExits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListPoolVoluntaryExits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/ListPoolVoluntaryExits",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListPoolVoluntaryExits(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_SubmitVoluntaryExit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignedVoluntaryExit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).SubmitVoluntaryExit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/SubmitVoluntaryExit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).SubmitVoluntaryExit(ctx, req.(*SignedVoluntaryExit))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetForkSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetForkSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/GetForkSchedule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetForkSchedule(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/GetSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetSpec(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetDepositContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetDepositContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/GetDepositContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetDepositContract(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _BeaconChain_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ethereum.eth.v1.BeaconChain",
	HandlerType: (*BeaconChainServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetGenesis",
			Handler:    _BeaconChain_GetGenesis_Handler,
		},
		{
			MethodName: "GetStateRoot",
			Handler:    _BeaconChain_GetStateRoot_Handler,
		},
		{
			MethodName: "GetStateFork",
			Handler:    _BeaconChain_GetStateFork_Handler,
		},
		{
			MethodName: "GetFinalityCheckpoints",
			Handler:    _BeaconChain_GetFinalityCheckpoints_Handler,
		},
		{
			MethodName: "ListValidators",
			Handler:    _BeaconChain_ListValidators_Handler,
		},
		{
			MethodName: "GetValidator",
			Handler:    _BeaconChain_GetValidator_Handler,
		},
		{
			MethodName: "ListCommittees",
			Handler:    _BeaconChain_ListCommittees_Handler,
		},
		{
			MethodName: "GetBlockHeader",
			Handler:    _BeaconChain_GetBlockHeader_Handler,
		},
		{
			MethodName: "ListBlockHeaders",
			Handler:    _BeaconChain_ListBlockHeaders_Handler,
		},
		{
			MethodName: "PostBlock",
			Handler:    _BeaconChain_PostBlock_Handler,
		},
		{
			MethodName: "GetBlock",
			Handler:    _BeaconChain_GetBlock_Handler,
		},
		{
			MethodName: "GetBlockRoot",
			Handler:    _BeaconChain_GetBlockRoot_Handler,
		},
		{
			MethodName: "ListBlockAttestations",
			Handler:    _BeaconChain_ListBlockAttestations_Handler,
		},
		{
			MethodName: "ListPoolAttestations",
			Handler:    _BeaconChain_ListPoolAttestations_Handler,
		},
		{
			MethodName: "SubmitAttestation",
			Handler:    _BeaconChain_SubmitAttestation_Handler,
		},
		{
			MethodName: "ListPoolAttesterSlashings",
			Handler:    _BeaconChain_ListPoolAttesterSlashings_Handler,
		},
		{
			MethodName: "PostAttesterSlashing",
			Handler:    _BeaconChain_PostAttesterSlashing_Handler,
		},
		{
			MethodName: "ListPoolProposerSlashings",
			Handler:    _BeaconChain_ListPoolProposerSlashings_Handler,
		},
		{
			MethodName: "SubmitProposerSlashing",
			Handler:    _BeaconChain_SubmitProposerSlashing_Handler,
		},
		{
			MethodName: "ListPoolVoluntaryExits",
			Handler:    _BeaconChain_ListPoolVoluntaryExits_Handler,
		},
		{
			MethodName: "SubmitVoluntaryExit",
			Handler:    _BeaconChain_SubmitVoluntaryExit_Handler,
		},
		{
			MethodName: "GetForkSchedule",
			Handler:    _BeaconChain_GetForkSchedule_Handler,
		},
		{
			MethodName: "GetSpec",
			Handler:    _BeaconChain_GetSpec_Handler,
		},
		{
			MethodName: "GetDepositContract",
			Handler:    _BeaconChain_GetDepositContract_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "eth/v1/beacon_chain_service.proto",
}

func (m *GenesisResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenesisResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.GenesisForkVersion) > 0 {
		i -= len(m.GenesisForkVersion)
		copy(dAtA[i:], m.GenesisForkVersion)
		i = encodeVarintBeaconChainService(dAtA, i, uint64(len(m.GenesisForkVersion)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.GenesisValidatorsRoot) > 0 {
		i -= len(m.GenesisValidatorsRoot)
		copy(dAtA[i:], m.GenesisValidatorsRoot)
		i = encodeVarintBeaconChainService(dAtA, i, uint64(len(m.GenesisValidatorsRoot)))
		i--
		dAtA[i] = 0x12
	}
	if m.GenesisTime != 0 {
		i = encodeVarintBeaconChainService(dAtA, i, uint64(m.GenesisTime))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StateId) > 0 {
		i -= len(m.StateId)
		copy(dAtA[i:], m.StateId)
		i = encodeVarintBeaconChainService(dAtA, i, uint64(len(m.StateId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StateRootResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateRootResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateRootResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StateRoot) > 0 {
		i -= len(m.StateRoot)
		copy(dAtA[i:], m.StateRoot)
		i = encodeVarintBeaconChainService(dAtA, i, uint64(len(m.StateRoot)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StateForkResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateForkResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateForkResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Fork != nil {
		{
			size, err := m.Fork.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeaconChainService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StateFinalityCheckpointResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateFinalityCheckpointResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateFinalityCheckpointResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Finalized != nil {
		{
			size, err := m.Finalized.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeaconChainService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.CurrentJustified != nil {
		{
			size, err := m.CurrentJustified.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeaconChainService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PreviousJustified != nil {
		{
			size, err := m.PreviousJustified.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeaconChainService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StateValidatorsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateValidatorsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateValidatorsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintBeaconChainService(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Id) > 0 {
		for iNdEx := len(m.Id) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Id[iNdEx])
			copy(dAtA[i:], m.Id[iNdEx])
			i = encodeVarintBeaconChainService(dAtA, i, uint64(len(m.Id[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.StateId) > 0 {
		i -= len(m.StateId)
		copy(dAtA[i:], m.StateId)
		i = encodeVarintBeaconChainService(dAtA, i, uint64(len(m.StateId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StateValidatorsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateValidatorsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateValidatorsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBeaconChainService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StateValidatorRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateValidatorRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateValidatorRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ValidatorId) > 0 {
		i -= len(m.ValidatorId)
		copy(dAtA[i:], m.ValidatorId)
		i = encodeVarintBeaconChainService(dAtA, i, uint64(len(m.ValidatorId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.StateId) > 0 {
		i -= len(m.StateId)
		copy(dAtA[i:], m.StateId)
		i = encodeVarintBeaconChainService(dAtA, i, uint64(len(m.StateId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StateValidatorResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateValidatorResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateValidatorResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeaconChainService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StateCommitteesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateCommitteesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateCommitteesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Slot != 0 {
		i = encodeVarintBeaconChainService(dAtA, i, uint64(m.Slot))
		i--
		dAtA[i] = 0x20
	}
	if m.Index != 0 {
		i = encodeVarintBeaconChainService(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x18
	}
	if m.Epoch != 0 {
		i = encodeVarintBeaconChainService(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x10
	}
	if len(m.StateId) > 0 {
		i -= len(m.StateId)
		copy(dAtA[i:], m.StateId)
		i = encodeVarintBeaconChainService(dAtA, i, uint64(len(m.StateId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StateCommitteesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateCommitteesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateCommitteesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBeaconChainService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BlockAttestationsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockAttestationsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockAttestationsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBeaconChainService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BlockRootContainer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockRootContainer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockRootContainer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Root) > 0 {
		i -= len(m.Root)
		copy(dAtA[i:], m.Root)
		i = encodeVarintBeaconChainService(dAtA, i, uint64(len(m.Root)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockRootResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockRootResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockRootResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeaconChainService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockHeadersRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockHeadersRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockHeadersRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ParentRoot) > 0 {
		i -= len(m.ParentRoot)
		copy(dAtA[i:], m.ParentRoot)
		i = encodeVarintBeaconChainService(dAtA, i, uint64(len(m.ParentRoot)))
		i--
		dAtA[i] = 0x12
	}
	if m.Slot != 0 {
		i = encodeVarintBeaconChainService(dAtA, i, uint64(m.Slot))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlockHeadersResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockHeadersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockHeadersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBeaconChainService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BlockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.BlockId) > 0 {
		i -= len(m.BlockId)
		copy(dAtA[i:], m.BlockId)
		i = encodeVarintBeaconChainService(dAtA, i, uint64(len(m.BlockId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockHeaderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockHeaderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockHeaderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeaconChainService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockHeaderContainer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockHeaderContainer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockHeaderContainer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeaconChainService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Canonical {
		i--
		if m.Canonical {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Root) > 0 {
		i -= len(m.Root)
		copy(dAtA[i:], m.Root)
		i = encodeVarintBeaconChainService(dAtA, i, uint64(len(m.Root)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BeaconBlockHeaderContainer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BeaconBlockHeaderContainer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BeaconBlockHeaderContainer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintBeaconChainService(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if m.Message != nil {
		{
			size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeaconChainService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeaconChainService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BeaconBlockContainer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BeaconBlockContainer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BeaconBlockContainer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintBeaconChainService(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if m.Message != nil {
		{
			size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeaconChainService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AttestationsPoolRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttestationsPoolRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttestationsPoolRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CommitteeIndex != 0 {
		i = encodeVarintBeaconChainService(dAtA, i, uint64(m.CommitteeIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.Slot != 0 {
		i = encodeVarintBeaconChainService(dAtA, i, uint64(m.Slot))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AttestationsPoolResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttestationsPoolResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttestationsPoolResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBeaconChainService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AttesterSlashingsPoolResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttesterSlashingsPoolResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttesterSlashingsPoolResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBeaconChainService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProposerSlashingPoolResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposerSlashingPoolResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposerSlashingPoolResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBeaconChainService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *VoluntaryExitsPoolResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VoluntaryExitsPoolResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VoluntaryExitsPoolResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBeaconChainService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ForkScheduleResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForkScheduleResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ForkScheduleResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeaconChainService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpecResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpecResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpecResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		for k := range m.Data {
			v := m.Data[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintBeaconChainService(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintBeaconChainService(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintBeaconChainService(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DepositContractResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DepositContractResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DepositContractResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBeaconChainService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DepositContract) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DepositContract) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DepositContract) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintBeaconChainService(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if m.ChainId != 0 {
		i = encodeVarintBeaconChainService(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintBeaconChainService(dAtA []byte, offset int, v uint64) int {
	offset -= sovBeaconChainService(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GenesisResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GenesisTime != 0 {
		n += 1 + sovBeaconChainService(uint64(m.GenesisTime))
	}
	l = len(m.GenesisValidatorsRoot)
	if l > 0 {
		n += 1 + l + sovBeaconChainService(uint64(l))
	}
	l = len(m.GenesisForkVersion)
	if l > 0 {
		n += 1 + l + sovBeaconChainService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StateId)
	if l > 0 {
		n += 1 + l + sovBeaconChainService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StateRootResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StateRoot)
	if l > 0 {
		n += 1 + l + sovBeaconChainService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StateForkResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Fork != nil {
		l = m.Fork.Size()
		n += 1 + l + sovBeaconChainService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StateFinalityCheckpointResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PreviousJustified != nil {
		l = m.PreviousJustified.Size()
		n += 1 + l + sovBeaconChainService(uint64(l))
	}
	if m.CurrentJustified != nil {
		l = m.CurrentJustified.Size()
		n += 1 + l + sovBeaconChainService(uint64(l))
	}
	if m.Finalized != nil {
		l = m.Finalized.Size()
		n += 1 + l + sovBeaconChainService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StateValidatorsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StateId)
	if l > 0 {
		n += 1 + l + sovBeaconChainService(uint64(l))
	}
	if len(m.Id) > 0 {
		for _, s := range m.Id {
			l = len(s)
			n += 1 + l + sovBeaconChainService(uint64(l))
		}
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovBeaconChainService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StateValidatorsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovBeaconChainService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StateValidatorRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StateId)
	if l > 0 {
		n += 1 + l + sovBeaconChainService(uint64(l))
	}
	l = len(m.ValidatorId)
	if l > 0 {
		n += 1 + l + sovBeaconChainService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StateValidatorResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovBeaconChainService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StateCommitteesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StateId)
	if l > 0 {
		n += 1 + l + sovBeaconChainService(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovBeaconChainService(uint64(m.Epoch))
	}
	if m.Index != 0 {
		n += 1 + sovBeaconChainService(uint64(m.Index))
	}
	if m.Slot != 0 {
		n += 1 + sovBeaconChainService(uint64(m.Slot))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StateCommitteesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovBeaconChainService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockAttestationsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovBeaconChainService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockRootContainer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovBeaconChainService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockRootResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovBeaconChainService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockHeadersRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Slot != 0 {
		n += 1 + sovBeaconChainService(uint64(m.Slot))
	}
	l = len(m.ParentRoot)
	if l > 0 {
		n += 1 + l + sovBeaconChainService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockHeadersResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovBeaconChainService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BlockId)
	if l > 0 {
		n += 1 + l + sovBeaconChainService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockHeaderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovBeaconChainService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockHeaderContainer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovBeaconChainService(uint64(l))
	}
	if m.Canonical {
		n += 2
	}
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovBeaconChainService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BeaconBlockHeaderContainer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovBeaconChainService(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovBeaconChainService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovBeaconChainService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BeaconBlockContainer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovBeaconChainService(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovBeaconChainService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttestationsPoolRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Slot != 0 {
		n += 1 + sovBeaconChainService(uint64(m.Slot))
	}
	if m.CommitteeIndex != 0 {
		n += 1 + sovBeaconChainService(uint64(m.CommitteeIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttestationsPoolResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovBeaconChainService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttesterSlashingsPoolResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovBeaconChainService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProposerSlashingPoolResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovBeaconChainService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VoluntaryExitsPoolResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovBeaconChainService(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ForkScheduleResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovBeaconChainService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SpecResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for k, v := range m.Data {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovBeaconChainService(uint64(len(k))) + 1 + len(v) + sovBeaconChainService(uint64(len(v)))
			n += mapEntrySize + 1 + sovBeaconChainService(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DepositContractResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovBeaconChainService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DepositContract) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != 0 {
		n += 1 + sovBeaconChainService(uint64(m.ChainId))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovBeaconChainService(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBeaconChainService(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBeaconChainService(x uint64) (n int) {
	return sovBeaconChainService(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GenesisResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenesisResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenesisResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenesisTime", wireType)
			}
			m.GenesisTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GenesisTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenesisValidatorsRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GenesisValidatorsRoot = append(m.GenesisValidatorsRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.GenesisValidatorsRoot == nil {
				m.GenesisValidatorsRoot = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenesisForkVersion", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GenesisForkVersion = append(m.GenesisForkVersion[:0], dAtA[iNdEx:postIndex]...)
			if m.GenesisForkVersion == nil {
				m.GenesisForkVersion = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateRootResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateRootResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateRootResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateRoot = append(m.StateRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.StateRoot == nil {
				m.StateRoot = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateForkResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateForkResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateForkResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fork", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fork == nil {
				m.Fork = &Fork{}
			}
			if err := m.Fork.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateFinalityCheckpointResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateFinalityCheckpointResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateFinalityCheckpointResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousJustified", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreviousJustified == nil {
				m.PreviousJustified = &Checkpoint{}
			}
			if err := m.PreviousJustified.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentJustified", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CurrentJustified == nil {
				m.CurrentJustified = &Checkpoint{}
			}
			if err := m.CurrentJustified.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finalized", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Finalized == nil {
				m.Finalized = &Checkpoint{}
			}
			if err := m.Finalized.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateValidatorsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateValidatorsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateValidatorsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateValidatorsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateValidatorsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateValidatorsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &ValidatorContainer{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateValidatorRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateValidatorRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateValidatorRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateValidatorResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateValidatorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateValidatorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ValidatorContainer{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateCommitteesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateCommitteesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateCommitteesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slot", wireType)
			}
			m.Slot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Slot |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateCommitteesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateCommitteesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateCommitteesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &Committee{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockAttestationsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockAttestationsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockAttestationsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &Attestation{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockRootContainer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockRootContainer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockRootContainer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = append(m.Root[:0], dAtA[iNdEx:postIndex]...)
			if m.Root == nil {
				m.Root = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockRootResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockRootResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockRootResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &BlockRootContainer{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockHeadersRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockHeadersRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockHeadersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slot", wireType)
			}
			m.Slot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Slot |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentRoot = append(m.ParentRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.ParentRoot == nil {
				m.ParentRoot = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockHeadersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockHeadersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockHeadersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &BlockHeaderContainer{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockId = append(m.BlockId[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockId == nil {
				m.BlockId = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockHeaderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockHeaderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockHeaderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &BlockHeaderContainer{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockHeaderContainer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockHeaderContainer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockHeaderContainer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = append(m.Root[:0], dAtA[iNdEx:postIndex]...)
			if m.Root == nil {
				m.Root = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Canonical", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Canonical = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &BeaconBlockHeaderContainer{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BeaconBlockHeaderContainer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BeaconBlockHeaderContainer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BeaconBlockHeaderContainer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &BeaconBlockHeader{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &BeaconBlockContainer{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BeaconBlockContainer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BeaconBlockContainer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BeaconBlockContainer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &BeaconBlock{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttestationsPoolRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttestationsPoolRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttestationsPoolRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slot", wireType)
			}
			m.Slot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Slot |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitteeIndex", wireType)
			}
			m.CommitteeIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitteeIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttestationsPoolResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttestationsPoolResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttestationsPoolResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &Attestation{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttesterSlashingsPoolResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttesterSlashingsPoolResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttesterSlashingsPoolResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &AttesterSlashing{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposerSlashingPoolResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProposerSlashingPoolResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProposerSlashingPoolResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &ProposerSlashing{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VoluntaryExitsPoolResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VoluntaryExitsPoolResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VoluntaryExitsPoolResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &SignedVoluntaryExit{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForkScheduleResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForkScheduleResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForkScheduleResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &Fork{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpecResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpecResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpecResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBeaconChainService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChainService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBeaconChainService
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBeaconChainService
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBeaconChainService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthBeaconChainService
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthBeaconChainService
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBeaconChainService(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthBeaconChainService
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Data[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DepositContractResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DepositContractResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DepositContractResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &DepositContract{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DepositContract) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DepositContract: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DepositContract: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBeaconChainService(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBeaconChainService
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBeaconChainService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBeaconChainService
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBeaconChainService
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBeaconChainService
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBeaconChainService        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBeaconChainService          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBeaconChainService = fmt.Errorf("proto: unexpected end of group")
)
