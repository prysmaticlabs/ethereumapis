// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: eth/v1/beacon_pools.proto

package v1

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type AttestationsPoolRequest struct {
	Slot                 uint64   `protobuf:"varint,1,opt,name=slot,proto3" json:"slot,omitempty"`
	CommitteeIndex       uint64   `protobuf:"varint,2,opt,name=committee_index,json=committeeIndex,proto3" json:"committee_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AttestationsPoolRequest) Reset()         { *m = AttestationsPoolRequest{} }
func (m *AttestationsPoolRequest) String() string { return proto.CompactTextString(m) }
func (*AttestationsPoolRequest) ProtoMessage()    {}
func (*AttestationsPoolRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c08b889e08d4502e, []int{0}
}
func (m *AttestationsPoolRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttestationsPoolRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttestationsPoolRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttestationsPoolRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttestationsPoolRequest.Merge(m, src)
}
func (m *AttestationsPoolRequest) XXX_Size() int {
	return m.Size()
}
func (m *AttestationsPoolRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AttestationsPoolRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AttestationsPoolRequest proto.InternalMessageInfo

func (m *AttestationsPoolRequest) GetSlot() uint64 {
	if m != nil {
		return m.Slot
	}
	return 0
}

func (m *AttestationsPoolRequest) GetCommitteeIndex() uint64 {
	if m != nil {
		return m.CommitteeIndex
	}
	return 0
}

type AttestationsPoolResponse struct {
	Data                 []*Attestation `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *AttestationsPoolResponse) Reset()         { *m = AttestationsPoolResponse{} }
func (m *AttestationsPoolResponse) String() string { return proto.CompactTextString(m) }
func (*AttestationsPoolResponse) ProtoMessage()    {}
func (*AttestationsPoolResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c08b889e08d4502e, []int{1}
}
func (m *AttestationsPoolResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttestationsPoolResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttestationsPoolResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttestationsPoolResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttestationsPoolResponse.Merge(m, src)
}
func (m *AttestationsPoolResponse) XXX_Size() int {
	return m.Size()
}
func (m *AttestationsPoolResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AttestationsPoolResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AttestationsPoolResponse proto.InternalMessageInfo

func (m *AttestationsPoolResponse) GetData() []*Attestation {
	if m != nil {
		return m.Data
	}
	return nil
}

type AttesterSlashingsPoolResponse struct {
	Data                 []*AttesterSlashing `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *AttesterSlashingsPoolResponse) Reset()         { *m = AttesterSlashingsPoolResponse{} }
func (m *AttesterSlashingsPoolResponse) String() string { return proto.CompactTextString(m) }
func (*AttesterSlashingsPoolResponse) ProtoMessage()    {}
func (*AttesterSlashingsPoolResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c08b889e08d4502e, []int{2}
}
func (m *AttesterSlashingsPoolResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttesterSlashingsPoolResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttesterSlashingsPoolResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttesterSlashingsPoolResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttesterSlashingsPoolResponse.Merge(m, src)
}
func (m *AttesterSlashingsPoolResponse) XXX_Size() int {
	return m.Size()
}
func (m *AttesterSlashingsPoolResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AttesterSlashingsPoolResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AttesterSlashingsPoolResponse proto.InternalMessageInfo

func (m *AttesterSlashingsPoolResponse) GetData() []*AttesterSlashing {
	if m != nil {
		return m.Data
	}
	return nil
}

type ProposerSlashingPoolResponse struct {
	Data                 []*ProposerSlashing `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ProposerSlashingPoolResponse) Reset()         { *m = ProposerSlashingPoolResponse{} }
func (m *ProposerSlashingPoolResponse) String() string { return proto.CompactTextString(m) }
func (*ProposerSlashingPoolResponse) ProtoMessage()    {}
func (*ProposerSlashingPoolResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c08b889e08d4502e, []int{3}
}
func (m *ProposerSlashingPoolResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposerSlashingPoolResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposerSlashingPoolResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposerSlashingPoolResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposerSlashingPoolResponse.Merge(m, src)
}
func (m *ProposerSlashingPoolResponse) XXX_Size() int {
	return m.Size()
}
func (m *ProposerSlashingPoolResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposerSlashingPoolResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ProposerSlashingPoolResponse proto.InternalMessageInfo

func (m *ProposerSlashingPoolResponse) GetData() []*ProposerSlashing {
	if m != nil {
		return m.Data
	}
	return nil
}

type VoluntaryExitsPoolResponse struct {
	Data                 []*SignedVoluntaryExit `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *VoluntaryExitsPoolResponse) Reset()         { *m = VoluntaryExitsPoolResponse{} }
func (m *VoluntaryExitsPoolResponse) String() string { return proto.CompactTextString(m) }
func (*VoluntaryExitsPoolResponse) ProtoMessage()    {}
func (*VoluntaryExitsPoolResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c08b889e08d4502e, []int{4}
}
func (m *VoluntaryExitsPoolResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VoluntaryExitsPoolResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VoluntaryExitsPoolResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VoluntaryExitsPoolResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VoluntaryExitsPoolResponse.Merge(m, src)
}
func (m *VoluntaryExitsPoolResponse) XXX_Size() int {
	return m.Size()
}
func (m *VoluntaryExitsPoolResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VoluntaryExitsPoolResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VoluntaryExitsPoolResponse proto.InternalMessageInfo

func (m *VoluntaryExitsPoolResponse) GetData() []*SignedVoluntaryExit {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterType((*AttestationsPoolRequest)(nil), "ethereum.eth.v1.AttestationsPoolRequest")
	proto.RegisterType((*AttestationsPoolResponse)(nil), "ethereum.eth.v1.AttestationsPoolResponse")
	proto.RegisterType((*AttesterSlashingsPoolResponse)(nil), "ethereum.eth.v1.AttesterSlashingsPoolResponse")
	proto.RegisterType((*ProposerSlashingPoolResponse)(nil), "ethereum.eth.v1.ProposerSlashingPoolResponse")
	proto.RegisterType((*VoluntaryExitsPoolResponse)(nil), "ethereum.eth.v1.VoluntaryExitsPoolResponse")
}

func init() { proto.RegisterFile("eth/v1/beacon_pools.proto", fileDescriptor_c08b889e08d4502e) }

var fileDescriptor_c08b889e08d4502e = []byte{
	// 602 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x94, 0x5d, 0x8b, 0xd3, 0x4e,
	0x14, 0xc6, 0x99, 0xfe, 0xcb, 0x1f, 0x99, 0x05, 0xbb, 0x8c, 0xee, 0xda, 0xc6, 0x5a, 0x6a, 0x7c,
	0xab, 0xac, 0x4e, 0xec, 0x8a, 0xe0, 0xad, 0x85, 0x5e, 0x08, 0x5e, 0x94, 0x2e, 0xf6, 0x42, 0x16,
	0xca, 0xa4, 0x1d, 0x93, 0x60, 0x92, 0x13, 0x33, 0xd3, 0xb2, 0xbd, 0x55, 0xd0, 0x3b, 0x45, 0xfc,
	0x16, 0x7e, 0x12, 0xf1, 0x4a, 0xf0, 0x5a, 0x90, 0xe2, 0x07, 0x91, 0xbc, 0x6d, 0x9b, 0x34, 0x69,
	0xa3, 0x77, 0x65, 0xce, 0x3c, 0xcf, 0xf9, 0xf5, 0x99, 0x73, 0x82, 0x1b, 0x5c, 0x9a, 0xda, 0xbc,
	0xab, 0xe9, 0x9c, 0x4d, 0xc0, 0x1d, 0x7b, 0x00, 0xb6, 0xa0, 0x9e, 0x0f, 0x12, 0x48, 0x8d, 0x4b,
	0x93, 0xfb, 0x7c, 0xe6, 0x50, 0x2e, 0x4d, 0x3a, 0xef, 0x2a, 0x57, 0x0d, 0x00, 0xc3, 0xe6, 0x5a,
	0x58, 0xd6, 0x67, 0x2f, 0x35, 0xee, 0x78, 0x72, 0x11, 0xdd, 0x56, 0x9a, 0x71, 0x91, 0x79, 0x96,
	0xc6, 0x5c, 0x17, 0x24, 0x93, 0x16, 0xb8, 0xb1, 0x97, 0xa2, 0xa4, 0xdb, 0xe8, 0x36, 0x4c, 0x5e,
	0x25, 0xb5, 0x7a, 0x5c, 0x63, 0x52, 0x72, 0x11, 0xc9, 0xe2, 0x4a, 0x23, 0x47, 0x15, 0x95, 0xd4,
	0x11, 0xbe, 0xf2, 0x64, 0x75, 0x5f, 0x0c, 0x00, 0xec, 0x21, 0x7f, 0x3d, 0xe3, 0x42, 0x12, 0x82,
	0xab, 0xc2, 0x06, 0x59, 0x47, 0x6d, 0xd4, 0xa9, 0x0e, 0xc3, 0xdf, 0xe4, 0x0e, 0xae, 0x4d, 0xc0,
	0x71, 0x2c, 0x29, 0x39, 0x1f, 0x5b, 0xee, 0x94, 0x9f, 0xd5, 0x2b, 0x61, 0xf9, 0xe2, 0xf9, 0xf1,
	0xd3, 0xe0, 0x54, 0x7d, 0x86, 0xeb, 0x9b, 0xbe, 0xc2, 0x03, 0x57, 0x70, 0xf2, 0x00, 0x57, 0xa7,
	0x4c, 0xb2, 0x3a, 0x6a, 0xff, 0xd7, 0xd9, 0x3b, 0x6e, 0xd2, 0x4c, 0x3e, 0x74, 0x4d, 0x38, 0x0c,
	0x6f, 0xaa, 0x23, 0x7c, 0x2d, 0x3a, 0xe4, 0xfe, 0x89, 0xcd, 0x84, 0x69, 0xb9, 0x46, 0xda, 0xf2,
	0x51, 0xca, 0xf2, 0x7a, 0x81, 0xe5, 0x4a, 0x1d, 0xfb, 0x3e, 0xc7, 0xcd, 0x81, 0x0f, 0x1e, 0x88,
	0x55, 0xe5, 0xaf, 0x6c, 0xb3, 0xe2, 0x73, 0x5c, 0x65, 0x04, 0xf6, 0xcc, 0x95, 0xcc, 0x5f, 0xf4,
	0xcf, 0x2c, 0x99, 0x66, 0x7d, 0x9c, 0x32, 0xbd, 0xb9, 0x61, 0x7a, 0x62, 0x19, 0x2e, 0x9f, 0xa6,
	0x0c, 0x22, 0xdf, 0xe3, 0x9f, 0x17, 0xf0, 0x5e, 0x2f, 0x7c, 0xc3, 0xc0, 0x50, 0x90, 0x4f, 0x08,
	0xef, 0x67, 0x53, 0x26, 0x9d, 0x6d, 0x79, 0xae, 0x3f, 0xb0, 0x72, 0xb7, 0xc4, 0xcd, 0x88, 0x59,
	0xed, 0xbc, 0xf9, 0xf1, 0xfb, 0x73, 0x45, 0x25, 0x6d, 0x2d, 0x35, 0x4a, 0x5a, 0x30, 0xe7, 0xeb,
	0x03, 0x27, 0xc8, 0x1c, 0x5f, 0x1e, 0x80, 0x90, 0x1b, 0x58, 0x5b, 0x9f, 0x59, 0x39, 0xa4, 0xd1,
	0xd8, 0xd3, 0x64, 0x27, 0x68, 0x3f, 0xd8, 0x89, 0xa4, 0xaf, 0xba, 0xbb, 0xef, 0x47, 0x84, 0x0f,
	0x72, 0x67, 0x84, 0x14, 0x78, 0x2b, 0x74, 0xe7, 0x94, 0xa4, 0x33, 0xa0, 0x21, 0x4b, 0x87, 0xdc,
	0x2e, 0x66, 0xe1, 0xfe, 0x58, 0x24, 0x5a, 0xf2, 0x0e, 0xe1, 0xc6, 0x2a, 0x8a, 0x2c, 0xd5, 0xee,
	0x19, 0x2d, 0x0c, 0x25, 0x06, 0x51, 0xcb, 0x82, 0x7c, 0x40, 0xf8, 0x20, 0x3b, 0xa9, 0xdb, 0xa3,
	0xb9, 0xbf, 0x73, 0xd2, 0xcb, 0x27, 0xe3, 0xc5, 0xca, 0x9c, 0x64, 0xf2, 0xa1, 0x76, 0xaf, 0xd9,
	0xbf, 0x25, 0x93, 0x0f, 0x42, 0x36, 0x37, 0xb5, 0x30, 0x96, 0xa3, 0x0d, 0xb2, 0xe2, 0x35, 0x57,
	0x8f, 0x42, 0x96, 0x5b, 0xe4, 0x46, 0x1e, 0xcb, 0x3c, 0xd1, 0x8d, 0x79, 0x20, 0x24, 0x6f, 0x11,
	0x3e, 0x0c, 0x12, 0xc9, 0x81, 0x29, 0xf5, 0x81, 0x28, 0x4c, 0x24, 0xa6, 0x50, 0xcb, 0x50, 0xf4,
	0xde, 0xa3, 0xaf, 0xcb, 0x16, 0xfa, 0xbe, 0x6c, 0xa1, 0x5f, 0xcb, 0x16, 0xc2, 0x97, 0xc0, 0x37,
	0xb2, 0xcd, 0x7b, 0xfb, 0x6b, 0x1f, 0xa0, 0x41, 0xd0, 0x6b, 0x80, 0x5e, 0xdc, 0x33, 0x2c, 0x69,
	0xce, 0x74, 0x3a, 0x01, 0x47, 0xf3, 0xfc, 0x85, 0x70, 0x98, 0xb4, 0x26, 0x36, 0xd3, 0x85, 0x96,
	0xa8, 0x99, 0x67, 0x89, 0x98, 0xe0, 0x4b, 0xa5, 0xd6, 0x4f, 0x3c, 0xfb, 0xa1, 0xe7, 0xb7, 0xd5,
	0xc9, 0x69, 0x5f, 0x9a, 0xa7, 0xf3, 0xae, 0xfe, 0x7f, 0xf8, 0x37, 0x1e, 0xfe, 0x09, 0x00, 0x00,
	0xff, 0xff, 0x64, 0x86, 0x6c, 0x7e, 0x57, 0x07, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// BeaconPoolsClient is the client API for BeaconPools service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BeaconPoolsClient interface {
	AttestationsPool(ctx context.Context, in *AttestationsPoolRequest, opts ...grpc.CallOption) (*AttestationsPoolResponse, error)
	PostAttestationsPool(ctx context.Context, in *Attestation, opts ...grpc.CallOption) (*types.Empty, error)
	AttesterSlashingsPool(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*AttesterSlashingsPoolResponse, error)
	PostAttesterSlashingsPool(ctx context.Context, in *AttesterSlashing, opts ...grpc.CallOption) (*types.Empty, error)
	ProposerSlashingsPool(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*ProposerSlashingPoolResponse, error)
	PostProposerSlashingsPool(ctx context.Context, in *ProposerSlashing, opts ...grpc.CallOption) (*types.Empty, error)
	VoluntaryExitsPool(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*VoluntaryExitsPoolResponse, error)
	PostVoluntaryExitsPool(ctx context.Context, in *SignedVoluntaryExit, opts ...grpc.CallOption) (*types.Empty, error)
}

type beaconPoolsClient struct {
	cc *grpc.ClientConn
}

func NewBeaconPoolsClient(cc *grpc.ClientConn) BeaconPoolsClient {
	return &beaconPoolsClient{cc}
}

func (c *beaconPoolsClient) AttestationsPool(ctx context.Context, in *AttestationsPoolRequest, opts ...grpc.CallOption) (*AttestationsPoolResponse, error) {
	out := new(AttestationsPoolResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconPools/AttestationsPool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconPoolsClient) PostAttestationsPool(ctx context.Context, in *Attestation, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconPools/PostAttestationsPool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconPoolsClient) AttesterSlashingsPool(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*AttesterSlashingsPoolResponse, error) {
	out := new(AttesterSlashingsPoolResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconPools/AttesterSlashingsPool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconPoolsClient) PostAttesterSlashingsPool(ctx context.Context, in *AttesterSlashing, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconPools/PostAttesterSlashingsPool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconPoolsClient) ProposerSlashingsPool(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*ProposerSlashingPoolResponse, error) {
	out := new(ProposerSlashingPoolResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconPools/ProposerSlashingsPool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconPoolsClient) PostProposerSlashingsPool(ctx context.Context, in *ProposerSlashing, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconPools/PostProposerSlashingsPool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconPoolsClient) VoluntaryExitsPool(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*VoluntaryExitsPoolResponse, error) {
	out := new(VoluntaryExitsPoolResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconPools/VoluntaryExitsPool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconPoolsClient) PostVoluntaryExitsPool(ctx context.Context, in *SignedVoluntaryExit, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconPools/PostVoluntaryExitsPool", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BeaconPoolsServer is the server API for BeaconPools service.
type BeaconPoolsServer interface {
	AttestationsPool(context.Context, *AttestationsPoolRequest) (*AttestationsPoolResponse, error)
	PostAttestationsPool(context.Context, *Attestation) (*types.Empty, error)
	AttesterSlashingsPool(context.Context, *types.Empty) (*AttesterSlashingsPoolResponse, error)
	PostAttesterSlashingsPool(context.Context, *AttesterSlashing) (*types.Empty, error)
	ProposerSlashingsPool(context.Context, *types.Empty) (*ProposerSlashingPoolResponse, error)
	PostProposerSlashingsPool(context.Context, *ProposerSlashing) (*types.Empty, error)
	VoluntaryExitsPool(context.Context, *types.Empty) (*VoluntaryExitsPoolResponse, error)
	PostVoluntaryExitsPool(context.Context, *SignedVoluntaryExit) (*types.Empty, error)
}

// UnimplementedBeaconPoolsServer can be embedded to have forward compatible implementations.
type UnimplementedBeaconPoolsServer struct {
}

func (*UnimplementedBeaconPoolsServer) AttestationsPool(ctx context.Context, req *AttestationsPoolRequest) (*AttestationsPoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AttestationsPool not implemented")
}
func (*UnimplementedBeaconPoolsServer) PostAttestationsPool(ctx context.Context, req *Attestation) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostAttestationsPool not implemented")
}
func (*UnimplementedBeaconPoolsServer) AttesterSlashingsPool(ctx context.Context, req *types.Empty) (*AttesterSlashingsPoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AttesterSlashingsPool not implemented")
}
func (*UnimplementedBeaconPoolsServer) PostAttesterSlashingsPool(ctx context.Context, req *AttesterSlashing) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostAttesterSlashingsPool not implemented")
}
func (*UnimplementedBeaconPoolsServer) ProposerSlashingsPool(ctx context.Context, req *types.Empty) (*ProposerSlashingPoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProposerSlashingsPool not implemented")
}
func (*UnimplementedBeaconPoolsServer) PostProposerSlashingsPool(ctx context.Context, req *ProposerSlashing) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostProposerSlashingsPool not implemented")
}
func (*UnimplementedBeaconPoolsServer) VoluntaryExitsPool(ctx context.Context, req *types.Empty) (*VoluntaryExitsPoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VoluntaryExitsPool not implemented")
}
func (*UnimplementedBeaconPoolsServer) PostVoluntaryExitsPool(ctx context.Context, req *SignedVoluntaryExit) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostVoluntaryExitsPool not implemented")
}

func RegisterBeaconPoolsServer(s *grpc.Server, srv BeaconPoolsServer) {
	s.RegisterService(&_BeaconPools_serviceDesc, srv)
}

func _BeaconPools_AttestationsPool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttestationsPoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconPoolsServer).AttestationsPool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconPools/AttestationsPool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconPoolsServer).AttestationsPool(ctx, req.(*AttestationsPoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconPools_PostAttestationsPool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Attestation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconPoolsServer).PostAttestationsPool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconPools/PostAttestationsPool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconPoolsServer).PostAttestationsPool(ctx, req.(*Attestation))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconPools_AttesterSlashingsPool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconPoolsServer).AttesterSlashingsPool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconPools/AttesterSlashingsPool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconPoolsServer).AttesterSlashingsPool(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconPools_PostAttesterSlashingsPool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttesterSlashing)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconPoolsServer).PostAttesterSlashingsPool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconPools/PostAttesterSlashingsPool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconPoolsServer).PostAttesterSlashingsPool(ctx, req.(*AttesterSlashing))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconPools_ProposerSlashingsPool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconPoolsServer).ProposerSlashingsPool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconPools/ProposerSlashingsPool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconPoolsServer).ProposerSlashingsPool(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconPools_PostProposerSlashingsPool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProposerSlashing)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconPoolsServer).PostProposerSlashingsPool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconPools/PostProposerSlashingsPool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconPoolsServer).PostProposerSlashingsPool(ctx, req.(*ProposerSlashing))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconPools_VoluntaryExitsPool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconPoolsServer).VoluntaryExitsPool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconPools/VoluntaryExitsPool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconPoolsServer).VoluntaryExitsPool(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconPools_PostVoluntaryExitsPool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignedVoluntaryExit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconPoolsServer).PostVoluntaryExitsPool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconPools/PostVoluntaryExitsPool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconPoolsServer).PostVoluntaryExitsPool(ctx, req.(*SignedVoluntaryExit))
	}
	return interceptor(ctx, in, info, handler)
}

var _BeaconPools_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ethereum.eth.v1.BeaconPools",
	HandlerType: (*BeaconPoolsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AttestationsPool",
			Handler:    _BeaconPools_AttestationsPool_Handler,
		},
		{
			MethodName: "PostAttestationsPool",
			Handler:    _BeaconPools_PostAttestationsPool_Handler,
		},
		{
			MethodName: "AttesterSlashingsPool",
			Handler:    _BeaconPools_AttesterSlashingsPool_Handler,
		},
		{
			MethodName: "PostAttesterSlashingsPool",
			Handler:    _BeaconPools_PostAttesterSlashingsPool_Handler,
		},
		{
			MethodName: "ProposerSlashingsPool",
			Handler:    _BeaconPools_ProposerSlashingsPool_Handler,
		},
		{
			MethodName: "PostProposerSlashingsPool",
			Handler:    _BeaconPools_PostProposerSlashingsPool_Handler,
		},
		{
			MethodName: "VoluntaryExitsPool",
			Handler:    _BeaconPools_VoluntaryExitsPool_Handler,
		},
		{
			MethodName: "PostVoluntaryExitsPool",
			Handler:    _BeaconPools_PostVoluntaryExitsPool_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "eth/v1/beacon_pools.proto",
}

func (m *AttestationsPoolRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttestationsPoolRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttestationsPoolRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CommitteeIndex != 0 {
		i = encodeVarintBeaconPools(dAtA, i, uint64(m.CommitteeIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.Slot != 0 {
		i = encodeVarintBeaconPools(dAtA, i, uint64(m.Slot))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AttestationsPoolResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttestationsPoolResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttestationsPoolResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBeaconPools(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AttesterSlashingsPoolResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttesterSlashingsPoolResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttesterSlashingsPoolResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBeaconPools(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProposerSlashingPoolResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposerSlashingPoolResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposerSlashingPoolResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBeaconPools(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *VoluntaryExitsPoolResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VoluntaryExitsPoolResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VoluntaryExitsPoolResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBeaconPools(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintBeaconPools(dAtA []byte, offset int, v uint64) int {
	offset -= sovBeaconPools(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AttestationsPoolRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Slot != 0 {
		n += 1 + sovBeaconPools(uint64(m.Slot))
	}
	if m.CommitteeIndex != 0 {
		n += 1 + sovBeaconPools(uint64(m.CommitteeIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttestationsPoolResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovBeaconPools(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AttesterSlashingsPoolResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovBeaconPools(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProposerSlashingPoolResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovBeaconPools(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VoluntaryExitsPoolResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovBeaconPools(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBeaconPools(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBeaconPools(x uint64) (n int) {
	return sovBeaconPools(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AttestationsPoolRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconPools
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttestationsPoolRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttestationsPoolRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slot", wireType)
			}
			m.Slot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconPools
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Slot |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitteeIndex", wireType)
			}
			m.CommitteeIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconPools
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitteeIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconPools(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconPools
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconPools
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttestationsPoolResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconPools
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttestationsPoolResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttestationsPoolResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconPools
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconPools
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconPools
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &Attestation{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconPools(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconPools
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconPools
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttesterSlashingsPoolResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconPools
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttesterSlashingsPoolResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttesterSlashingsPoolResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconPools
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconPools
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconPools
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &AttesterSlashing{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconPools(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconPools
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconPools
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposerSlashingPoolResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconPools
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProposerSlashingPoolResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProposerSlashingPoolResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconPools
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconPools
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconPools
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &ProposerSlashing{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconPools(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconPools
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconPools
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VoluntaryExitsPoolResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBeaconPools
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VoluntaryExitsPoolResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VoluntaryExitsPoolResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBeaconPools
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBeaconPools
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBeaconPools
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &SignedVoluntaryExit{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBeaconPools(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBeaconPools
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthBeaconPools
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBeaconPools(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBeaconPools
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBeaconPools
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBeaconPools
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBeaconPools
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBeaconPools
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBeaconPools
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBeaconPools        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBeaconPools          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBeaconPools = fmt.Errorf("proto: unexpected end of group")
)
