// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// BeaconChainClient is the client API for BeaconChain service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BeaconChainClient interface {
	// GetGenesis retrieves details of the chain's genesis which can be used to identify chain.
	GetGenesis(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GenesisResponse, error)
	// GetStateRoot calculates HashTreeRoot for state with given 'stateId'. If stateId is root, same value will be returned.
	GetStateRoot(ctx context.Context, in *StateRequest, opts ...grpc.CallOption) (*StateRootResponse, error)
	// GetStateFork returns Fork object for state with given 'stateId'.
	GetStateFork(ctx context.Context, in *StateRequest, opts ...grpc.CallOption) (*StateForkResponse, error)
	// GetFinalityCheckpoints returns finality checkpoints for state with given 'stateId'. In case finality is
	// not yet achieved, checkpoint should return epoch 0 and ZERO_HASH as root.
	GetFinalityCheckpoints(ctx context.Context, in *StateRequest, opts ...grpc.CallOption) (*StateFinalityCheckpointResponse, error)
	// ListValidators returns a filterable list of validators with their balance, status and index.
	ListValidators(ctx context.Context, in *StateValidatorsRequest, opts ...grpc.CallOption) (*StateValidatorsResponse, error)
	// GetValidator returns a validator specified by state and id or public key along with status and balance.
	GetValidator(ctx context.Context, in *StateValidatorRequest, opts ...grpc.CallOption) (*StateValidatorResponse, error)
	// ListValidators returns a filterable list of validator balances.
	ListValidatorBalances(ctx context.Context, in *ValidatorBalancesRequest, opts ...grpc.CallOption) (*ValidatorBalancesResponse, error)
	// ListCommittees retrieves the committees for the given state at the given epoch.
	ListCommittees(ctx context.Context, in *StateCommitteesRequest, opts ...grpc.CallOption) (*StateCommitteesResponse, error)
	// ListBlockHeaders retrieves block headers matching given query. By default it will fetch current head slot blocks.
	ListBlockHeaders(ctx context.Context, in *BlockHeadersRequest, opts ...grpc.CallOption) (*BlockHeadersResponse, error)
	// GetBlockHeader retrieves block header for given block id.
	GetBlockHeader(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BlockHeaderResponse, error)
	// SubmitBlock instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be
	// included in the beacon chain. The beacon node is not required to validate the signed BeaconBlock, and a successful
	// response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the
	// new block into its state, and therefore validate the block internally, however blocks which fail the validation are
	// still broadcast but a different status code is returned (202).
	SubmitBlock(ctx context.Context, in *BeaconBlockContainer, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetBlock retrieves block details for given block id.
	GetBlock(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BlockResponse, error)
	// GetBlockSsz returns the SSZ-serialized version of block details for given block id.
	GetBlockSsz(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BlockSszResponse, error)
	// GetBlockRoot retrieves hashTreeRoot of BeaconBlock/BeaconBlockHeader.
	GetBlockRoot(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BlockRootResponse, error)
	// ListBlockAttestations retrieves attestation included in requested block.
	ListBlockAttestations(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BlockAttestationsResponse, error)
	// ListPoolAttestations retrieves attestations known by the node but
	// not necessarily incorporated into any block.
	ListPoolAttestations(ctx context.Context, in *AttestationsPoolRequest, opts ...grpc.CallOption) (*AttestationsPoolResponse, error)
	// SubmitAttestations submits Attestation objects to node. If attestation passes all validation
	// constraints, node MUST publish attestation on appropriate subnet.
	SubmitAttestations(ctx context.Context, in *SubmitAttestationsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// ListPoolAttesterSlashings retrieves attester slashings known by the node but
	// not necessarily incorporated into any block.
	ListPoolAttesterSlashings(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*AttesterSlashingsPoolResponse, error)
	// SubmitAttesterSlashing submits AttesterSlashing object to node's pool and
	// if passes validation node MUST broadcast it to network.
	SubmitAttesterSlashing(ctx context.Context, in *AttesterSlashing, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// ListPoolProposerSlashings retrieves proposer slashings known by the node
	// but not necessarily incorporated into any block.
	ListPoolProposerSlashings(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ProposerSlashingPoolResponse, error)
	// SubmitProposerSlashing submits AttesterSlashing object to node's pool and if
	// passes validation node MUST broadcast it to network.
	SubmitProposerSlashing(ctx context.Context, in *ProposerSlashing, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// ListPoolVoluntaryExits retrieves voluntary exits known by the node but
	// not necessarily incorporated into any block.
	ListPoolVoluntaryExits(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*VoluntaryExitsPoolResponse, error)
	// SubmitVoluntaryExit submits SignedVoluntaryExit object to node's pool
	// and if passes validation node MUST broadcast it to network.
	SubmitVoluntaryExit(ctx context.Context, in *SignedVoluntaryExit, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GetForkSchedule retrieve all scheduled upcoming forks this node is aware of.
	GetForkSchedule(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ForkScheduleResponse, error)
	// Spec retrieves specification configuration (without Phase 1 params) used on this node. Specification params list
	// Values are returned with following format:
	// - any value starting with 0x in the spec is returned as a hex string
	// - all other values are returned as number
	GetSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SpecResponse, error)
	// GetDepositContract retrieves deposit contract address and genesis fork version.
	GetDepositContract(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*DepositContractResponse, error)
}

type beaconChainClient struct {
	cc grpc.ClientConnInterface
}

func NewBeaconChainClient(cc grpc.ClientConnInterface) BeaconChainClient {
	return &beaconChainClient{cc}
}

func (c *beaconChainClient) GetGenesis(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GenesisResponse, error) {
	out := new(GenesisResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/GetGenesis", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetStateRoot(ctx context.Context, in *StateRequest, opts ...grpc.CallOption) (*StateRootResponse, error) {
	out := new(StateRootResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/GetStateRoot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetStateFork(ctx context.Context, in *StateRequest, opts ...grpc.CallOption) (*StateForkResponse, error) {
	out := new(StateForkResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/GetStateFork", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetFinalityCheckpoints(ctx context.Context, in *StateRequest, opts ...grpc.CallOption) (*StateFinalityCheckpointResponse, error) {
	out := new(StateFinalityCheckpointResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/GetFinalityCheckpoints", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListValidators(ctx context.Context, in *StateValidatorsRequest, opts ...grpc.CallOption) (*StateValidatorsResponse, error) {
	out := new(StateValidatorsResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/ListValidators", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetValidator(ctx context.Context, in *StateValidatorRequest, opts ...grpc.CallOption) (*StateValidatorResponse, error) {
	out := new(StateValidatorResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/GetValidator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListValidatorBalances(ctx context.Context, in *ValidatorBalancesRequest, opts ...grpc.CallOption) (*ValidatorBalancesResponse, error) {
	out := new(ValidatorBalancesResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/ListValidatorBalances", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListCommittees(ctx context.Context, in *StateCommitteesRequest, opts ...grpc.CallOption) (*StateCommitteesResponse, error) {
	out := new(StateCommitteesResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/ListCommittees", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListBlockHeaders(ctx context.Context, in *BlockHeadersRequest, opts ...grpc.CallOption) (*BlockHeadersResponse, error) {
	out := new(BlockHeadersResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/ListBlockHeaders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetBlockHeader(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BlockHeaderResponse, error) {
	out := new(BlockHeaderResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/GetBlockHeader", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) SubmitBlock(ctx context.Context, in *BeaconBlockContainer, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/SubmitBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetBlock(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BlockResponse, error) {
	out := new(BlockResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/GetBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetBlockSsz(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BlockSszResponse, error) {
	out := new(BlockSszResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/GetBlockSsz", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetBlockRoot(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BlockRootResponse, error) {
	out := new(BlockRootResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/GetBlockRoot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListBlockAttestations(ctx context.Context, in *BlockRequest, opts ...grpc.CallOption) (*BlockAttestationsResponse, error) {
	out := new(BlockAttestationsResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/ListBlockAttestations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListPoolAttestations(ctx context.Context, in *AttestationsPoolRequest, opts ...grpc.CallOption) (*AttestationsPoolResponse, error) {
	out := new(AttestationsPoolResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/ListPoolAttestations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) SubmitAttestations(ctx context.Context, in *SubmitAttestationsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/SubmitAttestations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListPoolAttesterSlashings(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*AttesterSlashingsPoolResponse, error) {
	out := new(AttesterSlashingsPoolResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/ListPoolAttesterSlashings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) SubmitAttesterSlashing(ctx context.Context, in *AttesterSlashing, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/SubmitAttesterSlashing", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListPoolProposerSlashings(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ProposerSlashingPoolResponse, error) {
	out := new(ProposerSlashingPoolResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/ListPoolProposerSlashings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) SubmitProposerSlashing(ctx context.Context, in *ProposerSlashing, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/SubmitProposerSlashing", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) ListPoolVoluntaryExits(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*VoluntaryExitsPoolResponse, error) {
	out := new(VoluntaryExitsPoolResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/ListPoolVoluntaryExits", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) SubmitVoluntaryExit(ctx context.Context, in *SignedVoluntaryExit, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/SubmitVoluntaryExit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetForkSchedule(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ForkScheduleResponse, error) {
	out := new(ForkScheduleResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/GetForkSchedule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetSpec(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SpecResponse, error) {
	out := new(SpecResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/GetSpec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconChainClient) GetDepositContract(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*DepositContractResponse, error) {
	out := new(DepositContractResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconChain/GetDepositContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BeaconChainServer is the server API for BeaconChain service.
// All implementations must embed UnimplementedBeaconChainServer
// for forward compatibility
type BeaconChainServer interface {
	// GetGenesis retrieves details of the chain's genesis which can be used to identify chain.
	GetGenesis(context.Context, *emptypb.Empty) (*GenesisResponse, error)
	// GetStateRoot calculates HashTreeRoot for state with given 'stateId'. If stateId is root, same value will be returned.
	GetStateRoot(context.Context, *StateRequest) (*StateRootResponse, error)
	// GetStateFork returns Fork object for state with given 'stateId'.
	GetStateFork(context.Context, *StateRequest) (*StateForkResponse, error)
	// GetFinalityCheckpoints returns finality checkpoints for state with given 'stateId'. In case finality is
	// not yet achieved, checkpoint should return epoch 0 and ZERO_HASH as root.
	GetFinalityCheckpoints(context.Context, *StateRequest) (*StateFinalityCheckpointResponse, error)
	// ListValidators returns a filterable list of validators with their balance, status and index.
	ListValidators(context.Context, *StateValidatorsRequest) (*StateValidatorsResponse, error)
	// GetValidator returns a validator specified by state and id or public key along with status and balance.
	GetValidator(context.Context, *StateValidatorRequest) (*StateValidatorResponse, error)
	// ListValidators returns a filterable list of validator balances.
	ListValidatorBalances(context.Context, *ValidatorBalancesRequest) (*ValidatorBalancesResponse, error)
	// ListCommittees retrieves the committees for the given state at the given epoch.
	ListCommittees(context.Context, *StateCommitteesRequest) (*StateCommitteesResponse, error)
	// ListBlockHeaders retrieves block headers matching given query. By default it will fetch current head slot blocks.
	ListBlockHeaders(context.Context, *BlockHeadersRequest) (*BlockHeadersResponse, error)
	// GetBlockHeader retrieves block header for given block id.
	GetBlockHeader(context.Context, *BlockRequest) (*BlockHeaderResponse, error)
	// SubmitBlock instructs the beacon node to broadcast a newly signed beacon block to the beacon network, to be
	// included in the beacon chain. The beacon node is not required to validate the signed BeaconBlock, and a successful
	// response (20X) only indicates that the broadcast has been successful. The beacon node is expected to integrate the
	// new block into its state, and therefore validate the block internally, however blocks which fail the validation are
	// still broadcast but a different status code is returned (202).
	SubmitBlock(context.Context, *BeaconBlockContainer) (*emptypb.Empty, error)
	// GetBlock retrieves block details for given block id.
	GetBlock(context.Context, *BlockRequest) (*BlockResponse, error)
	// GetBlockSsz returns the SSZ-serialized version of block details for given block id.
	GetBlockSsz(context.Context, *BlockRequest) (*BlockSszResponse, error)
	// GetBlockRoot retrieves hashTreeRoot of BeaconBlock/BeaconBlockHeader.
	GetBlockRoot(context.Context, *BlockRequest) (*BlockRootResponse, error)
	// ListBlockAttestations retrieves attestation included in requested block.
	ListBlockAttestations(context.Context, *BlockRequest) (*BlockAttestationsResponse, error)
	// ListPoolAttestations retrieves attestations known by the node but
	// not necessarily incorporated into any block.
	ListPoolAttestations(context.Context, *AttestationsPoolRequest) (*AttestationsPoolResponse, error)
	// SubmitAttestations submits Attestation objects to node. If attestation passes all validation
	// constraints, node MUST publish attestation on appropriate subnet.
	SubmitAttestations(context.Context, *SubmitAttestationsRequest) (*emptypb.Empty, error)
	// ListPoolAttesterSlashings retrieves attester slashings known by the node but
	// not necessarily incorporated into any block.
	ListPoolAttesterSlashings(context.Context, *emptypb.Empty) (*AttesterSlashingsPoolResponse, error)
	// SubmitAttesterSlashing submits AttesterSlashing object to node's pool and
	// if passes validation node MUST broadcast it to network.
	SubmitAttesterSlashing(context.Context, *AttesterSlashing) (*emptypb.Empty, error)
	// ListPoolProposerSlashings retrieves proposer slashings known by the node
	// but not necessarily incorporated into any block.
	ListPoolProposerSlashings(context.Context, *emptypb.Empty) (*ProposerSlashingPoolResponse, error)
	// SubmitProposerSlashing submits AttesterSlashing object to node's pool and if
	// passes validation node MUST broadcast it to network.
	SubmitProposerSlashing(context.Context, *ProposerSlashing) (*emptypb.Empty, error)
	// ListPoolVoluntaryExits retrieves voluntary exits known by the node but
	// not necessarily incorporated into any block.
	ListPoolVoluntaryExits(context.Context, *emptypb.Empty) (*VoluntaryExitsPoolResponse, error)
	// SubmitVoluntaryExit submits SignedVoluntaryExit object to node's pool
	// and if passes validation node MUST broadcast it to network.
	SubmitVoluntaryExit(context.Context, *SignedVoluntaryExit) (*emptypb.Empty, error)
	// GetForkSchedule retrieve all scheduled upcoming forks this node is aware of.
	GetForkSchedule(context.Context, *emptypb.Empty) (*ForkScheduleResponse, error)
	// Spec retrieves specification configuration (without Phase 1 params) used on this node. Specification params list
	// Values are returned with following format:
	// - any value starting with 0x in the spec is returned as a hex string
	// - all other values are returned as number
	GetSpec(context.Context, *emptypb.Empty) (*SpecResponse, error)
	// GetDepositContract retrieves deposit contract address and genesis fork version.
	GetDepositContract(context.Context, *emptypb.Empty) (*DepositContractResponse, error)
	mustEmbedUnimplementedBeaconChainServer()
}

// UnimplementedBeaconChainServer must be embedded to have forward compatible implementations.
type UnimplementedBeaconChainServer struct {
}

func (UnimplementedBeaconChainServer) GetGenesis(context.Context, *emptypb.Empty) (*GenesisResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGenesis not implemented")
}
func (UnimplementedBeaconChainServer) GetStateRoot(context.Context, *StateRequest) (*StateRootResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStateRoot not implemented")
}
func (UnimplementedBeaconChainServer) GetStateFork(context.Context, *StateRequest) (*StateForkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStateFork not implemented")
}
func (UnimplementedBeaconChainServer) GetFinalityCheckpoints(context.Context, *StateRequest) (*StateFinalityCheckpointResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFinalityCheckpoints not implemented")
}
func (UnimplementedBeaconChainServer) ListValidators(context.Context, *StateValidatorsRequest) (*StateValidatorsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListValidators not implemented")
}
func (UnimplementedBeaconChainServer) GetValidator(context.Context, *StateValidatorRequest) (*StateValidatorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetValidator not implemented")
}
func (UnimplementedBeaconChainServer) ListValidatorBalances(context.Context, *ValidatorBalancesRequest) (*ValidatorBalancesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListValidatorBalances not implemented")
}
func (UnimplementedBeaconChainServer) ListCommittees(context.Context, *StateCommitteesRequest) (*StateCommitteesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCommittees not implemented")
}
func (UnimplementedBeaconChainServer) ListBlockHeaders(context.Context, *BlockHeadersRequest) (*BlockHeadersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBlockHeaders not implemented")
}
func (UnimplementedBeaconChainServer) GetBlockHeader(context.Context, *BlockRequest) (*BlockHeaderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockHeader not implemented")
}
func (UnimplementedBeaconChainServer) SubmitBlock(context.Context, *BeaconBlockContainer) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitBlock not implemented")
}
func (UnimplementedBeaconChainServer) GetBlock(context.Context, *BlockRequest) (*BlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlock not implemented")
}
func (UnimplementedBeaconChainServer) GetBlockSsz(context.Context, *BlockRequest) (*BlockSszResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockSsz not implemented")
}
func (UnimplementedBeaconChainServer) GetBlockRoot(context.Context, *BlockRequest) (*BlockRootResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockRoot not implemented")
}
func (UnimplementedBeaconChainServer) ListBlockAttestations(context.Context, *BlockRequest) (*BlockAttestationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBlockAttestations not implemented")
}
func (UnimplementedBeaconChainServer) ListPoolAttestations(context.Context, *AttestationsPoolRequest) (*AttestationsPoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPoolAttestations not implemented")
}
func (UnimplementedBeaconChainServer) SubmitAttestations(context.Context, *SubmitAttestationsRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitAttestations not implemented")
}
func (UnimplementedBeaconChainServer) ListPoolAttesterSlashings(context.Context, *emptypb.Empty) (*AttesterSlashingsPoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPoolAttesterSlashings not implemented")
}
func (UnimplementedBeaconChainServer) SubmitAttesterSlashing(context.Context, *AttesterSlashing) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitAttesterSlashing not implemented")
}
func (UnimplementedBeaconChainServer) ListPoolProposerSlashings(context.Context, *emptypb.Empty) (*ProposerSlashingPoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPoolProposerSlashings not implemented")
}
func (UnimplementedBeaconChainServer) SubmitProposerSlashing(context.Context, *ProposerSlashing) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitProposerSlashing not implemented")
}
func (UnimplementedBeaconChainServer) ListPoolVoluntaryExits(context.Context, *emptypb.Empty) (*VoluntaryExitsPoolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPoolVoluntaryExits not implemented")
}
func (UnimplementedBeaconChainServer) SubmitVoluntaryExit(context.Context, *SignedVoluntaryExit) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitVoluntaryExit not implemented")
}
func (UnimplementedBeaconChainServer) GetForkSchedule(context.Context, *emptypb.Empty) (*ForkScheduleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetForkSchedule not implemented")
}
func (UnimplementedBeaconChainServer) GetSpec(context.Context, *emptypb.Empty) (*SpecResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSpec not implemented")
}
func (UnimplementedBeaconChainServer) GetDepositContract(context.Context, *emptypb.Empty) (*DepositContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDepositContract not implemented")
}
func (UnimplementedBeaconChainServer) mustEmbedUnimplementedBeaconChainServer() {}

// UnsafeBeaconChainServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BeaconChainServer will
// result in compilation errors.
type UnsafeBeaconChainServer interface {
	mustEmbedUnimplementedBeaconChainServer()
}

func RegisterBeaconChainServer(s *grpc.Server, srv BeaconChainServer) {
	s.RegisterService(&_BeaconChain_serviceDesc, srv)
}

func _BeaconChain_GetGenesis_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetGenesis(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/GetGenesis",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetGenesis(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetStateRoot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetStateRoot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/GetStateRoot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetStateRoot(ctx, req.(*StateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetStateFork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetStateFork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/GetStateFork",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetStateFork(ctx, req.(*StateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetFinalityCheckpoints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetFinalityCheckpoints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/GetFinalityCheckpoints",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetFinalityCheckpoints(ctx, req.(*StateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListValidators_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateValidatorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListValidators(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/ListValidators",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListValidators(ctx, req.(*StateValidatorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetValidator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateValidatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetValidator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/GetValidator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetValidator(ctx, req.(*StateValidatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListValidatorBalances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidatorBalancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListValidatorBalances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/ListValidatorBalances",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListValidatorBalances(ctx, req.(*ValidatorBalancesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListCommittees_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StateCommitteesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListCommittees(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/ListCommittees",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListCommittees(ctx, req.(*StateCommitteesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListBlockHeaders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHeadersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListBlockHeaders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/ListBlockHeaders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListBlockHeaders(ctx, req.(*BlockHeadersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetBlockHeader_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetBlockHeader(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/GetBlockHeader",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetBlockHeader(ctx, req.(*BlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_SubmitBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BeaconBlockContainer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).SubmitBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/SubmitBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).SubmitBlock(ctx, req.(*BeaconBlockContainer))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/GetBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetBlock(ctx, req.(*BlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetBlockSsz_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetBlockSsz(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/GetBlockSsz",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetBlockSsz(ctx, req.(*BlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetBlockRoot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetBlockRoot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/GetBlockRoot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetBlockRoot(ctx, req.(*BlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListBlockAttestations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListBlockAttestations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/ListBlockAttestations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListBlockAttestations(ctx, req.(*BlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListPoolAttestations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttestationsPoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListPoolAttestations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/ListPoolAttestations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListPoolAttestations(ctx, req.(*AttestationsPoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_SubmitAttestations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitAttestationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).SubmitAttestations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/SubmitAttestations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).SubmitAttestations(ctx, req.(*SubmitAttestationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListPoolAttesterSlashings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListPoolAttesterSlashings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/ListPoolAttesterSlashings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListPoolAttesterSlashings(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_SubmitAttesterSlashing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttesterSlashing)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).SubmitAttesterSlashing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/SubmitAttesterSlashing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).SubmitAttesterSlashing(ctx, req.(*AttesterSlashing))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListPoolProposerSlashings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListPoolProposerSlashings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/ListPoolProposerSlashings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListPoolProposerSlashings(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_SubmitProposerSlashing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProposerSlashing)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).SubmitProposerSlashing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/SubmitProposerSlashing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).SubmitProposerSlashing(ctx, req.(*ProposerSlashing))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_ListPoolVoluntaryExits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).ListPoolVoluntaryExits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/ListPoolVoluntaryExits",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).ListPoolVoluntaryExits(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_SubmitVoluntaryExit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignedVoluntaryExit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).SubmitVoluntaryExit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/SubmitVoluntaryExit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).SubmitVoluntaryExit(ctx, req.(*SignedVoluntaryExit))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetForkSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetForkSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/GetForkSchedule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetForkSchedule(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetSpec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetSpec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/GetSpec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetSpec(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconChain_GetDepositContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconChainServer).GetDepositContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconChain/GetDepositContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconChainServer).GetDepositContract(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _BeaconChain_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ethereum.eth.v1.BeaconChain",
	HandlerType: (*BeaconChainServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetGenesis",
			Handler:    _BeaconChain_GetGenesis_Handler,
		},
		{
			MethodName: "GetStateRoot",
			Handler:    _BeaconChain_GetStateRoot_Handler,
		},
		{
			MethodName: "GetStateFork",
			Handler:    _BeaconChain_GetStateFork_Handler,
		},
		{
			MethodName: "GetFinalityCheckpoints",
			Handler:    _BeaconChain_GetFinalityCheckpoints_Handler,
		},
		{
			MethodName: "ListValidators",
			Handler:    _BeaconChain_ListValidators_Handler,
		},
		{
			MethodName: "GetValidator",
			Handler:    _BeaconChain_GetValidator_Handler,
		},
		{
			MethodName: "ListValidatorBalances",
			Handler:    _BeaconChain_ListValidatorBalances_Handler,
		},
		{
			MethodName: "ListCommittees",
			Handler:    _BeaconChain_ListCommittees_Handler,
		},
		{
			MethodName: "ListBlockHeaders",
			Handler:    _BeaconChain_ListBlockHeaders_Handler,
		},
		{
			MethodName: "GetBlockHeader",
			Handler:    _BeaconChain_GetBlockHeader_Handler,
		},
		{
			MethodName: "SubmitBlock",
			Handler:    _BeaconChain_SubmitBlock_Handler,
		},
		{
			MethodName: "GetBlock",
			Handler:    _BeaconChain_GetBlock_Handler,
		},
		{
			MethodName: "GetBlockSsz",
			Handler:    _BeaconChain_GetBlockSsz_Handler,
		},
		{
			MethodName: "GetBlockRoot",
			Handler:    _BeaconChain_GetBlockRoot_Handler,
		},
		{
			MethodName: "ListBlockAttestations",
			Handler:    _BeaconChain_ListBlockAttestations_Handler,
		},
		{
			MethodName: "ListPoolAttestations",
			Handler:    _BeaconChain_ListPoolAttestations_Handler,
		},
		{
			MethodName: "SubmitAttestations",
			Handler:    _BeaconChain_SubmitAttestations_Handler,
		},
		{
			MethodName: "ListPoolAttesterSlashings",
			Handler:    _BeaconChain_ListPoolAttesterSlashings_Handler,
		},
		{
			MethodName: "SubmitAttesterSlashing",
			Handler:    _BeaconChain_SubmitAttesterSlashing_Handler,
		},
		{
			MethodName: "ListPoolProposerSlashings",
			Handler:    _BeaconChain_ListPoolProposerSlashings_Handler,
		},
		{
			MethodName: "SubmitProposerSlashing",
			Handler:    _BeaconChain_SubmitProposerSlashing_Handler,
		},
		{
			MethodName: "ListPoolVoluntaryExits",
			Handler:    _BeaconChain_ListPoolVoluntaryExits_Handler,
		},
		{
			MethodName: "SubmitVoluntaryExit",
			Handler:    _BeaconChain_SubmitVoluntaryExit_Handler,
		},
		{
			MethodName: "GetForkSchedule",
			Handler:    _BeaconChain_GetForkSchedule_Handler,
		},
		{
			MethodName: "GetSpec",
			Handler:    _BeaconChain_GetSpec_Handler,
		},
		{
			MethodName: "GetDepositContract",
			Handler:    _BeaconChain_GetDepositContract_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "eth/v1/beacon_chain_service.proto",
}
