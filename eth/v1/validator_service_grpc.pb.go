// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// BeaconValidatorClient is the client API for BeaconValidator service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BeaconValidatorClient interface {
	// GetAttesterDuties requests the beacon node to provide a set of attestation duties, which should be performed
	// by validators, for a particular epoch. Duties should only need to be checked once per epoch, however
	// a chain reorganization (of > MIN_SEED_LOOKAHEAD epochs) could occur, resulting in a change of duties.
	// For full safety, you should monitor chain reorganization events.
	GetAttesterDuties(ctx context.Context, in *AttesterDutiesRequest, opts ...grpc.CallOption) (*AttesterDutiesResponse, error)
	// GetProposerDuties requests beacon node to provide all validators that are scheduled to
	// propose a block in the given epoch
	GetProposerDuties(ctx context.Context, in *ProposerDutiesRequest, opts ...grpc.CallOption) (*ProposerDutiesResponse, error)
	// GetBlock requests the beacon node to produce a valid unsigned beacon block,
	// which can then be signed by a proposer and submitted.
	GetBlock(ctx context.Context, in *ProposerBlockRequest, opts ...grpc.CallOption) (*ProposerBlockResponse, error)
	// GetAttestationData requests that the beacon node provides the attestation data for
	// the requested committee index and slot based on the nodes current head.
	GetAttestationData(ctx context.Context, in *AttestationDataRequest, opts ...grpc.CallOption) (*AttestationDataResponse, error)
	// GetAggregateAttestation aggregates all attestations matching the given attestation data root and slot,
	// returning the aggregated result.
	GetAggregateAttestation(ctx context.Context, in *AggregateAttestationRequest, opts ...grpc.CallOption) (*AttestationResponse, error)
	// SubmitAggregateAndProofs verifies given aggregate and proofs and publishes them on appropriate gossipsub topic.
	//
	// Response usage:
	// - 200: Successful response
	//
	// - 400: Invalid request syntax.
	//
	// - 500: Beacon node internal error.
	SubmitAggregateAndProofs(ctx context.Context, in *AggregateAndProofsSubmit, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// SubmitBeaconCommitteeSubscription requests the beacon node to search using discv5 for peers related to
	// the provided subnet information and replaces current peers with those ones if necessary.
	//
	// If validator is_aggregator, beacon node must:
	//   - announce subnet topic subscription on gossipsub.
	//   - aggregate attestations received on that subnet.
	//
	// Response usage:
	// - 200: Slot signature is valid and beacon node has prepared the attestation subnet.
	//   Note that, we cannot be certain Beacon node will find peers for that subnet for various reasons.
	//
	// - 500: Beacon node internal error.
	//
	// - 503: Beacon node is currently syncing, try again later.
	SubmitBeaconCommitteeSubscription(ctx context.Context, in *BeaconCommitteeSubscribeSubmit, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type beaconValidatorClient struct {
	cc grpc.ClientConnInterface
}

func NewBeaconValidatorClient(cc grpc.ClientConnInterface) BeaconValidatorClient {
	return &beaconValidatorClient{cc}
}

func (c *beaconValidatorClient) GetAttesterDuties(ctx context.Context, in *AttesterDutiesRequest, opts ...grpc.CallOption) (*AttesterDutiesResponse, error) {
	out := new(AttesterDutiesResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconValidator/GetAttesterDuties", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconValidatorClient) GetProposerDuties(ctx context.Context, in *ProposerDutiesRequest, opts ...grpc.CallOption) (*ProposerDutiesResponse, error) {
	out := new(ProposerDutiesResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconValidator/GetProposerDuties", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconValidatorClient) GetBlock(ctx context.Context, in *ProposerBlockRequest, opts ...grpc.CallOption) (*ProposerBlockResponse, error) {
	out := new(ProposerBlockResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconValidator/GetBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconValidatorClient) GetAttestationData(ctx context.Context, in *AttestationDataRequest, opts ...grpc.CallOption) (*AttestationDataResponse, error) {
	out := new(AttestationDataResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconValidator/GetAttestationData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconValidatorClient) GetAggregateAttestation(ctx context.Context, in *AggregateAttestationRequest, opts ...grpc.CallOption) (*AttestationResponse, error) {
	out := new(AttestationResponse)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconValidator/GetAggregateAttestation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconValidatorClient) SubmitAggregateAndProofs(ctx context.Context, in *AggregateAndProofsSubmit, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconValidator/SubmitAggregateAndProofs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *beaconValidatorClient) SubmitBeaconCommitteeSubscription(ctx context.Context, in *BeaconCommitteeSubscribeSubmit, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/ethereum.eth.v1.BeaconValidator/SubmitBeaconCommitteeSubscription", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BeaconValidatorServer is the server API for BeaconValidator service.
// All implementations must embed UnimplementedBeaconValidatorServer
// for forward compatibility
type BeaconValidatorServer interface {
	// GetAttesterDuties requests the beacon node to provide a set of attestation duties, which should be performed
	// by validators, for a particular epoch. Duties should only need to be checked once per epoch, however
	// a chain reorganization (of > MIN_SEED_LOOKAHEAD epochs) could occur, resulting in a change of duties.
	// For full safety, you should monitor chain reorganization events.
	GetAttesterDuties(context.Context, *AttesterDutiesRequest) (*AttesterDutiesResponse, error)
	// GetProposerDuties requests beacon node to provide all validators that are scheduled to
	// propose a block in the given epoch
	GetProposerDuties(context.Context, *ProposerDutiesRequest) (*ProposerDutiesResponse, error)
	// GetBlock requests the beacon node to produce a valid unsigned beacon block,
	// which can then be signed by a proposer and submitted.
	GetBlock(context.Context, *ProposerBlockRequest) (*ProposerBlockResponse, error)
	// GetAttestationData requests that the beacon node provides the attestation data for
	// the requested committee index and slot based on the nodes current head.
	GetAttestationData(context.Context, *AttestationDataRequest) (*AttestationDataResponse, error)
	// GetAggregateAttestation aggregates all attestations matching the given attestation data root and slot,
	// returning the aggregated result.
	GetAggregateAttestation(context.Context, *AggregateAttestationRequest) (*AttestationResponse, error)
	// SubmitAggregateAndProofs verifies given aggregate and proofs and publishes them on appropriate gossipsub topic.
	//
	// Response usage:
	// - 200: Successful response
	//
	// - 400: Invalid request syntax.
	//
	// - 500: Beacon node internal error.
	SubmitAggregateAndProofs(context.Context, *AggregateAndProofsSubmit) (*emptypb.Empty, error)
	// SubmitBeaconCommitteeSubscription requests the beacon node to search using discv5 for peers related to
	// the provided subnet information and replaces current peers with those ones if necessary.
	//
	// If validator is_aggregator, beacon node must:
	//   - announce subnet topic subscription on gossipsub.
	//   - aggregate attestations received on that subnet.
	//
	// Response usage:
	// - 200: Slot signature is valid and beacon node has prepared the attestation subnet.
	//   Note that, we cannot be certain Beacon node will find peers for that subnet for various reasons.
	//
	// - 500: Beacon node internal error.
	//
	// - 503: Beacon node is currently syncing, try again later.
	SubmitBeaconCommitteeSubscription(context.Context, *BeaconCommitteeSubscribeSubmit) (*emptypb.Empty, error)
	mustEmbedUnimplementedBeaconValidatorServer()
}

// UnimplementedBeaconValidatorServer must be embedded to have forward compatible implementations.
type UnimplementedBeaconValidatorServer struct {
}

func (UnimplementedBeaconValidatorServer) GetAttesterDuties(context.Context, *AttesterDutiesRequest) (*AttesterDutiesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAttesterDuties not implemented")
}
func (UnimplementedBeaconValidatorServer) GetProposerDuties(context.Context, *ProposerDutiesRequest) (*ProposerDutiesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProposerDuties not implemented")
}
func (UnimplementedBeaconValidatorServer) GetBlock(context.Context, *ProposerBlockRequest) (*ProposerBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlock not implemented")
}
func (UnimplementedBeaconValidatorServer) GetAttestationData(context.Context, *AttestationDataRequest) (*AttestationDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAttestationData not implemented")
}
func (UnimplementedBeaconValidatorServer) GetAggregateAttestation(context.Context, *AggregateAttestationRequest) (*AttestationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAggregateAttestation not implemented")
}
func (UnimplementedBeaconValidatorServer) SubmitAggregateAndProofs(context.Context, *AggregateAndProofsSubmit) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitAggregateAndProofs not implemented")
}
func (UnimplementedBeaconValidatorServer) SubmitBeaconCommitteeSubscription(context.Context, *BeaconCommitteeSubscribeSubmit) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitBeaconCommitteeSubscription not implemented")
}
func (UnimplementedBeaconValidatorServer) mustEmbedUnimplementedBeaconValidatorServer() {}

// UnsafeBeaconValidatorServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BeaconValidatorServer will
// result in compilation errors.
type UnsafeBeaconValidatorServer interface {
	mustEmbedUnimplementedBeaconValidatorServer()
}

func RegisterBeaconValidatorServer(s *grpc.Server, srv BeaconValidatorServer) {
	s.RegisterService(&_BeaconValidator_serviceDesc, srv)
}

func _BeaconValidator_GetAttesterDuties_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttesterDutiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconValidatorServer).GetAttesterDuties(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconValidator/GetAttesterDuties",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconValidatorServer).GetAttesterDuties(ctx, req.(*AttesterDutiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconValidator_GetProposerDuties_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProposerDutiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconValidatorServer).GetProposerDuties(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconValidator/GetProposerDuties",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconValidatorServer).GetProposerDuties(ctx, req.(*ProposerDutiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconValidator_GetBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProposerBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconValidatorServer).GetBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconValidator/GetBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconValidatorServer).GetBlock(ctx, req.(*ProposerBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconValidator_GetAttestationData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttestationDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconValidatorServer).GetAttestationData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconValidator/GetAttestationData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconValidatorServer).GetAttestationData(ctx, req.(*AttestationDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconValidator_GetAggregateAttestation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregateAttestationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconValidatorServer).GetAggregateAttestation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconValidator/GetAggregateAttestation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconValidatorServer).GetAggregateAttestation(ctx, req.(*AggregateAttestationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconValidator_SubmitAggregateAndProofs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregateAndProofsSubmit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconValidatorServer).SubmitAggregateAndProofs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconValidator/SubmitAggregateAndProofs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconValidatorServer).SubmitAggregateAndProofs(ctx, req.(*AggregateAndProofsSubmit))
	}
	return interceptor(ctx, in, info, handler)
}

func _BeaconValidator_SubmitBeaconCommitteeSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BeaconCommitteeSubscribeSubmit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BeaconValidatorServer).SubmitBeaconCommitteeSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ethereum.eth.v1.BeaconValidator/SubmitBeaconCommitteeSubscription",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BeaconValidatorServer).SubmitBeaconCommitteeSubscription(ctx, req.(*BeaconCommitteeSubscribeSubmit))
	}
	return interceptor(ctx, in, info, handler)
}

var _BeaconValidator_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ethereum.eth.v1.BeaconValidator",
	HandlerType: (*BeaconValidatorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAttesterDuties",
			Handler:    _BeaconValidator_GetAttesterDuties_Handler,
		},
		{
			MethodName: "GetProposerDuties",
			Handler:    _BeaconValidator_GetProposerDuties_Handler,
		},
		{
			MethodName: "GetBlock",
			Handler:    _BeaconValidator_GetBlock_Handler,
		},
		{
			MethodName: "GetAttestationData",
			Handler:    _BeaconValidator_GetAttestationData_Handler,
		},
		{
			MethodName: "GetAggregateAttestation",
			Handler:    _BeaconValidator_GetAggregateAttestation_Handler,
		},
		{
			MethodName: "SubmitAggregateAndProofs",
			Handler:    _BeaconValidator_SubmitAggregateAndProofs_Handler,
		},
		{
			MethodName: "SubmitBeaconCommitteeSubscription",
			Handler:    _BeaconValidator_SubmitBeaconCommitteeSubscription_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "eth/v1/validator_service.proto",
}
